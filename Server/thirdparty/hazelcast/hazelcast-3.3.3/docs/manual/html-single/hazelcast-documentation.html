<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>Hazelcast Documentation Version: 3.3.3</title>

    <link type="text/css" rel="stylesheet" href="assets/css/reset.css">
    <link type="text/css" rel="stylesheet" href="http://yandex.st/highlightjs/7.3/styles/github.min.css">
    <link type="text/css" rel="stylesheet" href="assets/css/docs.css">
    <link type="text/css" rel="stylesheet" href="assets/css/print.css" media="print">
    

    <script type="text/javascript" src="assets/js/jquery-1.10.1.min.js"></script>
    <script type="text/javascript" src="assets/js/jquery.sticky-kit.js"></script>
    <script type="text/javascript" src="http://yandex.st/highlightjs/6.1/highlight.min.js"></script>
    <script type="text/javascript" src="assets/js/lunr.min.js"></script>

    

    <script type="text/javascript">var BASE_URL = "";</script>
    <script type="text/javascript" src="assets/js/viewer.js"></script>

    <script type="text/javascript"> 
  	$(function(){
		$("#sidebar").stick_in_parent()
	});
    </script>
    <script type="text/javascript">
        var _gaq = _gaq || [];
        _gaq.push(['_setAccount', 'UA-3921306-1']);
        _gaq.push(['_setDomainName', 'hazelcast.com']);
        _gaq.push(['_trackPageview']);
        (function() {
            var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
            ga.src = ('https:' == document.location.protocol ? 'https://' : 'http://') + 'stats.g.doubleclick.net/dc.js';
            var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
        })();
    </script>
    <script type="text/javascript">
        setTimeout(function(){var a=document.createElement("script");
            var b=document.getElementsByTagName("script")[0];
            a.src=document.location.protocol+"//dnn506yrbagrg.cloudfront.net/pages/scripts/0020/7413.js?"+Math.floor(new Date().getTime()/3600000);
            a.async=true;a.type="text/javascript";b.parentNode.insertBefore(a,b)}, 1);
    </script>

</head>
<body>
    <div id="page">
        <a name="top" />
        <div id="sitebar">
    <div class="content">
      <p><a href="http://hazelcast.org/documentation">Go to <span style="font-weight:bold">hazelcast.org/documentation</span></a></p>
      </div>
  </div>

        <header id="header">
			<div class="content">
			<div style="overflow:hidden">
				<div style="float:left">
                    <a href="http://www.hazelcast.org"><img src="assets/img/logo.png" style="width: 199px;padding-top: 18px"/></a>
					
				</div>	
				<div style="float:left;padding-top: 15px;padding-left: 30px;">
<h1><a href="">Documentation <span style="font-size:12px"> Version: 3.3.3 - Publication Date : Nov 12, 2014 </span></a></h1>
				</div>
			</div>
			</div>
        </header>
        <div class="content">
	        
	<div id="sidebar" style="overflow-y:auto">
	    <form action="search.html"><input id="search" type="text" placeholder="Search" name="q" /></form>
	    <nav id="toc">
	        
    <ol>
    
        <li>
            <a href="hazelcast-documentation.html#preface">Preface</a>
            
                
    <ol>
    
</ol>

            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#whats-new-in-hazelcast-33">What's New in Hazelcast 3.3</a>
            
                
    <ol>
    
        <li>
            <a href="hazelcast-documentation.html#release-notes">Release Notes</a>
            
                
    <ol>
    
        <li>
            <a href="hazelcast-documentation.html#new-features">New Features</a>
            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#fixes">Fixes</a>
            
        </li>
    
</ol>

            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#upgrading-from-2x-versions">Upgrading from 2.x versions</a>
            
                
    <ol>
    
</ol>

            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#document-revision-history">Document Revision History</a>
            
                
    <ol>
    
</ol>

            
        </li>
    
</ol>

            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#getting-started">Getting Started</a>
            
                
    <ol>
    
        <li>
            <a href="hazelcast-documentation.html#hazelcast-overview">Hazelcast Overview</a>
            
                
    <ol>
    
</ol>

            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#why-hazelcast">Why Hazelcast?</a>
            
                
    <ol>
    
</ol>

            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#installation">Installation</a>
            
                
    <ol>
    
        <li>
            <a href="hazelcast-documentation.html#hazelcast">Hazelcast</a>
            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#hazelcast-enterprise">Hazelcast Enterprise</a>
            
        </li>
    
</ol>

            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#starting-the-cluster-and-client">Starting the Cluster and Client</a>
            
                
    <ol>
    
</ol>

            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#configuring-hazelcast">Configuring Hazelcast</a>
            
                
    <ol>
    
</ol>

            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#use-cases">Use Cases</a>
            
                
    <ol>
    
</ol>

            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#resources">Resources</a>
            
                
    <ol>
    
</ol>

            
        </li>
    
</ol>

            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#distributed-data-structures">Distributed Data Structures</a>
            
                
    <ol>
    
        <li>
            <a href="hazelcast-documentation.html#map">Map</a>
            
                
    <ol>
    
        <li>
            <a href="hazelcast-documentation.html#map-overview">Map Overview</a>
            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#map-backups">Map Backups</a>
            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#eviction">Eviction</a>
            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#in-memory-format">In Memory Format</a>
            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#map-persistence">Map Persistence</a>
            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#near-cache">Near Cache</a>
            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#map-locks">Map Locks</a>
            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#entry-statistics">Entry Statistics</a>
            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#entry-listener">Entry Listener</a>
            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#interceptors">Interceptors</a>
            
        </li>
    
</ol>

            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#queue">Queue</a>
            
                
    <ol>
    
        <li>
            <a href="hazelcast-documentation.html#queue-overview">Queue Overview</a>
            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#sample-queue-code">Sample Queue Code</a>
            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#bounded-queue">Bounded Queue</a>
            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#queue-persistence">Queue Persistence</a>
            
        </li>
    
</ol>

            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#multimap">MultiMap</a>
            
                
    <ol>
    
        <li>
            <a href="hazelcast-documentation.html#sample-multimap-code">Sample MultiMap Code</a>
            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#multimap-configuration">MultiMap Configuration</a>
            
        </li>
    
</ol>

            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#set">Set</a>
            
                
    <ol>
    
        <li>
            <a href="hazelcast-documentation.html#sample-set-code">Sample Set Code</a>
            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#event-registration-and-configuration-for-set">Event Registration and Configuration for Set</a>
            
        </li>
    
</ol>

            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#list">List</a>
            
                
    <ol>
    
        <li>
            <a href="hazelcast-documentation.html#sample-list-code">Sample List Code</a>
            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#event-registration-and-configuration-for-list">Event Registration and Configuration for List</a>
            
        </li>
    
</ol>

            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#topic">Topic</a>
            
                
    <ol>
    
        <li>
            <a href="hazelcast-documentation.html#sample-topic-code">Sample Topic Code</a>
            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#statistics">Statistics</a>
            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#internals">Internals</a>
            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#topic-configuration">Topic Configuration</a>
            
        </li>
    
</ol>

            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#lock">Lock</a>
            
                
    <ol>
    
        <li>
            <a href="hazelcast-documentation.html#icondition">ICondition</a>
            
        </li>
    
</ol>

            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#iatomiclong">IAtomicLong</a>
            
                
    <ol>
    
</ol>

            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#isemaphore">ISemaphore</a>
            
                
    <ol>
    
</ol>

            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#iatomicreference">IAtomicReference</a>
            
                
    <ol>
    
</ol>

            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#icountdownlatch">ICountDownLatch</a>
            
                
    <ol>
    
</ol>

            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#idgenerator">IdGenerator</a>
            
                
    <ol>
    
</ol>

            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#replicated-map">Replicated Map</a>
            
                
    <ol>
    
        <li>
            <a href="hazelcast-documentation.html#for-consideration">For Consideration</a>
            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#breakage-of-the-map-contract">Breakage of the Map-Contract</a>
            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#technical-design">Technical design</a>
            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#in-memory-format-on-replicatedmap">In Memory Format on ReplicatedMap</a>
            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#entrylistener-on-replicatedmap">EntryListener on ReplicatedMap</a>
            
        </li>
    
</ol>

            
        </li>
    
</ol>

            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#distributed-events">Distributed Events</a>
            
                
    <ol>
    
        <li>
            <a href="hazelcast-documentation.html#event-listeners">Event Listeners</a>
            
                
    <ol>
    
</ol>

            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#global-event-configuration">Global Event Configuration</a>
            
                
    <ol>
    
</ol>

            
        </li>
    
</ol>

            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#distributed-computing">Distributed Computing</a>
            
                
    <ol>
    
        <li>
            <a href="hazelcast-documentation.html#executor-service">Executor Service</a>
            
                
    <ol>
    
        <li>
            <a href="hazelcast-documentation.html#executor-overview">Executor Overview</a>
            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#execution">Execution</a>
            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#execution-cancellation">Execution Cancellation</a>
            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#execution-callback">Execution Callback</a>
            
        </li>
    
</ol>

            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#entry-processor">Entry Processor</a>
            
                
    <ol>
    
        <li>
            <a href="hazelcast-documentation.html#entry-processor-overview">Entry Processor Overview</a>
            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#sample-entry-processor-code">Sample Entry Processor Code</a>
            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#abstract-entry-processor">Abstract Entry Processor</a>
            
        </li>
    
</ol>

            
        </li>
    
</ol>

            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#distributed-query">Distributed Query</a>
            
                
    <ol>
    
        <li>
            <a href="hazelcast-documentation.html#query-overview">Query Overview</a>
            
                
    <ol>
    
        <li>
            <a href="hazelcast-documentation.html#criteria-api">Criteria API</a>
            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#distributed-sql-query">Distributed SQL Query</a>
            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#paging-predicate-order-limit">Paging Predicate (Order &amp; Limit)</a>
            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#indexing">Indexing</a>
            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#query-thread-configuration">Query Thread Configuration</a>
            
        </li>
    
</ol>

            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#mapreduce">MapReduce</a>
            
                
    <ol>
    
        <li>
            <a href="hazelcast-documentation.html#mapreduce-essentials">MapReduce Essentials</a>
            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#introduction-to-mapreduce-api">Introduction to MapReduce API</a>
            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#hazelcast-mapreduce-architecture">Hazelcast MapReduce Architecture</a>
            
        </li>
    
</ol>

            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#aggregators">Aggregators</a>
            
                
    <ol>
    
        <li>
            <a href="hazelcast-documentation.html#aggregations-basics">Aggregations Basics</a>
            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#introduction-to-aggregations-api">Introduction to Aggregations API</a>
            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#aggregations-examples">Aggregations Examples</a>
            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#implementing-aggregations">Implementing Aggregations</a>
            
        </li>
    
</ol>

            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#continuous-query">Continuous Query</a>
            
                
    <ol>
    
</ol>

            
        </li>
    
</ol>

            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#user-defined-services">User Defined Services</a>
            
                
    <ol>
    
        <li>
            <a href="hazelcast-documentation.html#sample-case">Sample Case</a>
            
                
    <ol>
    
        <li>
            <a href="hazelcast-documentation.html#create-the-class">Create the Class</a>
            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#enable-the-class">Enable the Class</a>
            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#add-properties">Add Properties</a>
            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#start-the-service">Start the Service</a>
            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#place-a-remote-call-proxy">Place a Remote Call - Proxy</a>
            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#create-the-containers">Create the Containers</a>
            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#partition-migration">Partition Migration</a>
            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#create-the-backups">Create the Backups</a>
            
        </li>
    
</ol>

            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#waitnotifyservice">WaitNotifyService</a>
            
                
    <ol>
    
</ol>

            
        </li>
    
</ol>

            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#transactions">Transactions</a>
            
                
    <ol>
    
        <li>
            <a href="hazelcast-documentation.html#transaction-interface">Transaction Interface</a>
            
                
    <ol>
    
</ol>

            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#xa-transactions">XA Transactions</a>
            
                
    <ol>
    
</ol>

            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#j2ee-integration">J2EE Integration</a>
            
                
    <ol>
    
        <li>
            <a href="hazelcast-documentation.html#sample-code-for-j2ee-integration">Sample Code for J2EE Integration</a>
            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#resource-adapter-configuration">Resource Adapter Configuration</a>
            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#sample-glassfish-v3-web-application-configuration">Sample Glassfish v3 Web Application Configuration</a>
            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#sample-jboss-as-5-web-application-configuration">Sample JBoss AS 5 Web Application Configuration</a>
            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#sample-jboss-as-7-eap-6-web-application-configuration">Sample JBoss AS 7 / EAP 6 Web Application Configuration</a>
            
        </li>
    
</ol>

            
        </li>
    
</ol>

            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#hazelcast-jcache-implementation">Hazelcast JCache Implementation</a>
            
                
    <ol>
    
        <li>
            <a href="hazelcast-documentation.html#jcache-overview">JCache Overview</a>
            
                
    <ol>
    
</ol>

            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#setup-and-usage">Setup and Usage</a>
            
                
    <ol>
    
</ol>

            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#provider-types">Provider Types</a>
            
                
    <ol>
    
        <li>
            <a href="hazelcast-documentation.html#client-provider">Client Provider</a>
            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#server-provider">Server Provider</a>
            
        </li>
    
</ol>

            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#provider-setup">Provider Setup</a>
            
                
    <ol>
    
        <li>
            <a href="hazelcast-documentation.html#hazelcast-specific-system-property">Hazelcast Specific System Property</a>
            
        </li>
    
</ol>

            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#sample-jcache-code">Sample JCache Code</a>
            
                
    <ol>
    
</ol>

            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#hazelcast-cache-extension-icache">Hazelcast Cache Extension - ICache</a>
            
                
    <ol>
    
        <li>
            <a href="hazelcast-documentation.html#async-operations">Async operations</a>
            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#custom-expirypolicy">Custom ExpiryPolicy</a>
            
        </li>
    
</ol>

            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#running-the-jcache-tck">Running the JCache TCK</a>
            
                
    <ol>
    
</ol>

            
        </li>
    
</ol>

            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#integrated-clustering">Integrated Clustering</a>
            
                
    <ol>
    
        <li>
            <a href="hazelcast-documentation.html#hibernate-second-level-cache">Hibernate Second Level Cache</a>
            
                
    <ol>
    
        <li>
            <a href="hazelcast-documentation.html#sample-code-for-hibernate">Sample Code for Hibernate</a>
            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#supported-hibernate-versions">Supported Hibernate Versions</a>
            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#hibernate-configuration">Hibernate Configuration</a>
            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#hazelcast-configuration">Hazelcast Configuration</a>
            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#regionfactory-options">RegionFactory Options</a>
            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#hazelcast-modes-for-hibernate-usage">Hazelcast Modes for Hibernate Usage</a>
            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#hibernate-concurrency-strategies">Hibernate Concurrency Strategies</a>
            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#advanced-settings">Advanced Settings</a>
            
        </li>
    
</ol>

            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#web-session-replication">Web Session Replication</a>
            
                
    <ol>
    
        <li>
            <a href="hazelcast-documentation.html#filter-based-web-session-replication">Filter Based Web Session Replication</a>
            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#spring-security-support">Spring Security Support</a>
            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#tomcat-based-web-session-replication">Tomcat Based Web Session Replication</a>
            
        </li>
    
</ol>

            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#spring-integration">Spring Integration</a>
            
                
    <ol>
    
        <li>
            <a href="hazelcast-documentation.html#supported-versions">Supported Versions</a>
            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#spring-configuration">Spring Configuration</a>
            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#spring-managed-context-with-springaware">Spring Managed Context with @SpringAware</a>
            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#spring-cache">Spring Cache</a>
            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#hibernate-2nd-level-cache-config">Hibernate 2nd Level Cache Config</a>
            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#best-practices">Best Practices</a>
            
        </li>
    
</ol>

            
        </li>
    
</ol>

            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#storage">Storage</a>
            
                
    <ol>
    
        <li>
            <a href="hazelcast-documentation.html#off-heap">Off-Heap</a>
            
                
    <ol>
    
</ol>

            
        </li>
    
</ol>

            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#clients">Clients</a>
            
                
    <ol>
    
        <li>
            <a href="hazelcast-documentation.html#java-client">Java Client</a>
            
                
    <ol>
    
        <li>
            <a href="hazelcast-documentation.html#java-client-overview">Java Client Overview</a>
            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#java-client-dependencies">Java Client Dependencies</a>
            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#getting-started-with-client-api">Getting Started with Client API</a>
            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#java-client-operation-modes">Java Client Operation modes</a>
            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#fail-case-handling">Fail Case Handling</a>
            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#supported-distributed-data-structures">Supported Distributed Data Structures</a>
            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#client-services">Client Services</a>
            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#client-listeners">Client Listeners</a>
            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#client-transactions">Client Transactions</a>
            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#network-configuration-options">Network Configuration Options</a>
            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#client-near-cache">Client Near Cache</a>
            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#client-sslconfig">Client SSLConfig</a>
            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#java-client-configuration">Java Client Configuration</a>
            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#sample-codes-for-client">Sample Codes for Client</a>
            
        </li>
    
</ol>

            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#c-client">C++ Client</a>
            
                
    <ol>
    
        <li>
            <a href="hazelcast-documentation.html#how-to-setup">How to Setup</a>
            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#platform-specific-installation-guides">Platform Specific Installation Guides</a>
            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#code-examples">Code Examples</a>
            
        </li>
    
</ol>

            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#net-client">.NET Client</a>
            
                
    <ol>
    
        <li>
            <a href="hazelcast-documentation.html#client-configuration">Client Configuration</a>
            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#client-startup">Client Startup</a>
            
        </li>
    
</ol>

            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#rest-client">REST Client</a>
            
                
    <ol>
    
</ol>

            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#memcache-client">Memcache Client</a>
            
                
    <ol>
    
        <li>
            <a href="hazelcast-documentation.html#unsupported-operations">Unsupported Operations</a>
            
        </li>
    
</ol>

            
        </li>
    
</ol>

            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#serialization">Serialization</a>
            
                
    <ol>
    
        <li>
            <a href="hazelcast-documentation.html#serialization-overview">Serialization Overview</a>
            
                
    <ol>
    
</ol>

            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#serialization-interfaces">Serialization Interfaces</a>
            
                
    <ol>
    
</ol>

            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#comparison-table">Comparison Table</a>
            
                
    <ol>
    
</ol>

            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#serializable-externalizable">Serializable &amp; Externalizable</a>
            
                
    <ol>
    
</ol>

            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#dataserializable">DataSerializable</a>
            
                
    <ol>
    
        <li>
            <a href="hazelcast-documentation.html#identifieddataserializable">IdentifiedDataSerializable</a>
            
        </li>
    
</ol>

            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#portable">Portable</a>
            
                
    <ol>
    
        <li>
            <a href="hazelcast-documentation.html#versions">Versions</a>
            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#null-portable-serialization">Null Portable Serialization</a>
            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#distributedobject-serialization">DistributedObject Serialization</a>
            
        </li>
    
</ol>

            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#custom-serialization">Custom Serialization</a>
            
                
    <ol>
    
        <li>
            <a href="hazelcast-documentation.html#streamserializer">StreamSerializer</a>
            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#bytearrayserializer">ByteArraySerializer</a>
            
        </li>
    
</ol>

            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#hazelcastinstanceaware-interface">HazelcastInstanceAware Interface</a>
            
                
    <ol>
    
</ol>

            
        </li>
    
</ol>

            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#management">Management</a>
            
                
    <ol>
    
        <li>
            <a href="hazelcast-documentation.html#statistics-api-per-node">Statistics API per Node</a>
            
                
    <ol>
    
        <li>
            <a href="hazelcast-documentation.html#map-statistics">Map Statistics</a>
            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#multimap-statistics">Multimap Statistics</a>
            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#queue-statistics">Queue Statistics</a>
            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#topic-statistics">Topic Statistics</a>
            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#executor-statistics">Executor Statistics</a>
            
        </li>
    
</ol>

            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#jmx-api-per-node">JMX API per Node</a>
            
                
    <ol>
    
</ol>

            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#monitoring-with-jmx">Monitoring with JMX</a>
            
                
    <ol>
    
</ol>

            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#cluster-utilities">Cluster Utilities</a>
            
                
    <ol>
    
        <li>
            <a href="hazelcast-documentation.html#cluster-interface">Cluster Interface</a>
            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#member-attributes">Member Attributes</a>
            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#cluster-member-safety-check">Cluster-Member Safety Check</a>
            
        </li>
    
</ol>

            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#management-center">Management Center</a>
            
                
    <ol>
    
        <li>
            <a href="hazelcast-documentation.html#introduction">Introduction</a>
            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#tool-overview">Tool Overview</a>
            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#home-page">Home Page</a>
            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#caches">Caches</a>
            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#maps">Maps</a>
            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#queues">Queues</a>
            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#topics">Topics</a>
            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#multimaps">MultiMaps</a>
            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#executors">Executors</a>
            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#members">Members</a>
            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#scripting">Scripting</a>
            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#console">Console</a>
            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#alerts">Alerts</a>
            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#administration">Administration</a>
            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#time-travel">Time Travel</a>
            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#documentation">Documentation</a>
            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#suggested-heap-size">Suggested Heap Size</a>
            
        </li>
    
</ol>

            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#clustered-jmx">Clustered JMX</a>
            
                
    <ol>
    
        <li>
            <a href="hazelcast-documentation.html#clustered-jmx-configuration">Clustered JMX Configuration</a>
            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#api-documentation">API Documentation</a>
            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#new-relic-integration">New Relic Integration</a>
            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#appdynamics-integration">AppDynamics Integration</a>
            
        </li>
    
</ol>

            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#clustered-rest">Clustered REST</a>
            
                
    <ol>
    
        <li>
            <a href="hazelcast-documentation.html#enabling-clustered-rest">Enabling Clustered REST</a>
            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#clustered-rest-api-root">Clustered REST API Root</a>
            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#clusters-resource">Clusters Resource</a>
            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#cluster-resource">Cluster Resource</a>
            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#members-resource">Members Resource</a>
            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#member-resource">Member Resource</a>
            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#clients-resource">Clients Resource</a>
            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#maps-resource">Maps Resource</a>
            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#multimaps-resource">MultiMaps Resource</a>
            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#queues-resource">Queues Resource</a>
            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#topics-resource">Topics Resource</a>
            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#executors-resource">Executors Resource</a>
            
        </li>
    
</ol>

            
        </li>
    
</ol>

            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#security">Security</a>
            
                
    <ol>
    
        <li>
            <a href="hazelcast-documentation.html#enabling-security-for-hazelcast-enterprise">Enabling Security for Hazelcast Enterprise</a>
            
                
    <ol>
    
</ol>

            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#socket-interceptor">Socket Interceptor</a>
            
                
    <ol>
    
</ol>

            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#security-interceptor">Security Interceptor</a>
            
                
    <ol>
    
</ol>

            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#encryption">Encryption</a>
            
                
    <ol>
    
</ol>

            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#ssl">SSL</a>
            
                
    <ol>
    
</ol>

            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#credentials">Credentials</a>
            
                
    <ol>
    
</ol>

            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#clusterloginmodule">ClusterLoginModule</a>
            
                
    <ol>
    
</ol>

            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#cluster-member-security">Cluster Member Security</a>
            
                
    <ol>
    
</ol>

            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#native-client-security">Native Client Security</a>
            
                
    <ol>
    
        <li>
            <a href="hazelcast-documentation.html#authentication">Authentication</a>
            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#authorization">Authorization</a>
            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#permissions">Permissions</a>
            
        </li>
    
</ol>

            
        </li>
    
</ol>

            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#performance">Performance</a>
            
                
    <ol>
    
        <li>
            <a href="hazelcast-documentation.html#data-affinity">Data Affinity</a>
            
                
    <ol>
    
</ol>

            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#threading-model">Threading Model</a>
            
                
    <ol>
    
        <li>
            <a href="hazelcast-documentation.html#io-threading">I/O Threading</a>
            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#event-threading">Event Threading</a>
            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#iexecutor-threading">IExecutor Threading</a>
            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#operation-threading">Operation Threading</a>
            
        </li>
    
</ol>

            
        </li>
    
</ol>

            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#wan">WAN</a>
            
                
    <ol>
    
        <li>
            <a href="hazelcast-documentation.html#wan-replication">WAN Replication</a>
            
                
    <ol>
    
        <li>
            <a href="hazelcast-documentation.html#wan-replication-configuration">WAN Replication Configuration</a>
            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#wan-replication-queue-size">WAN Replication Queue Size</a>
            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#wan-replication-additional-information">WAN Replication Additional Information</a>
            
        </li>
    
</ol>

            
        </li>
    
</ol>

            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#configuration">Configuration</a>
            
                
    <ol>
    
        <li>
            <a href="hazelcast-documentation.html#using-wildcard">Using Wildcard</a>
            
                
    <ol>
    
</ol>

            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#network-configuration">Network Configuration</a>
            
                
    <ol>
    
        <li>
            <a href="hazelcast-documentation.html#configuring-tcpip-cluster">Configuring TCP/IP Cluster</a>
            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#specifying-network-interfaces">Specifying Network Interfaces</a>
            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#ec2-auto-discovery">EC2 Auto Discovery</a>
            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#ports">Ports</a>
            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#ipv6-support">IPv6 Support</a>
            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#partition-grouping">Partition Grouping</a>
            
        </li>
    
</ol>

            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#listener-configurations">Listener Configurations</a>
            
                
    <ol>
    
</ol>

            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#logging-configuration">Logging Configuration</a>
            
                
    <ol>
    
</ol>

            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#advanced-configuration-properties">Advanced Configuration Properties</a>
            
                
    <ol>
    
        <li>
            <a href="hazelcast-documentation.html#declarative-configuration">Declarative Configuration</a>
            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#programmatic-configuration">Programmatic Configuration</a>
            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#system-property">System Property</a>
            
        </li>
    
</ol>

            
        </li>
    
</ol>

            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#network-partitioning-split-brain-syndrome">Network Partitioning - Split Brain Syndrome</a>
            
                
    <ol>
    
</ol>

            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#frequently-asked-questions">Frequently Asked Questions</a>
            
                
    <ol>
    
        <li>
            <a href="hazelcast-documentation.html#why-271-as-the-default-partition-count">Why 271 as the default partition count</a>
            
                
    <ol>
    
</ol>

            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#is-hazelcast-thread-safe">Is Hazelcast thread safe</a>
            
                
    <ol>
    
</ol>

            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#how-do-nodes-discover-each-other">How do nodes discover each other</a>
            
                
    <ol>
    
</ol>

            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#what-happens-when-a-node-goes-down">What happens when a node goes down</a>
            
                
    <ol>
    
</ol>

            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#how-do-i-test-the-connectivity">How do I test the connectivity</a>
            
                
    <ol>
    
</ol>

            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#how-do-i-choose-keys-properly">How do I choose keys properly</a>
            
                
    <ol>
    
</ol>

            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#how-do-i-reflect-value-modifications">How do I reflect value modifications</a>
            
                
    <ol>
    
</ol>

            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#how-do-i-test-my-hazelcast-cluster">How do I test my Hazelcast cluster</a>
            
                
    <ol>
    
</ol>

            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#how-do-i-create-separate-clusters">How do I create separate clusters</a>
            
                
    <ol>
    
</ol>

            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#does-hazelcast-support-hundreds-of-nodes">Does Hazelcast support hundreds of nodes</a>
            
                
    <ol>
    
</ol>

            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#does-hazelcast-support-thousands-of-clients">Does Hazelcast support thousands of clients</a>
            
                
    <ol>
    
</ol>

            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#what-is-the-difference-between-old-litemember-and-new-smart-client">What is the difference between old LiteMember and new Smart Client</a>
            
                
    <ol>
    
</ol>

            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#how-do-you-give-support">How do you give support</a>
            
                
    <ol>
    
</ol>

            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#does-hazelcast-persist">Does Hazelcast persist</a>
            
                
    <ol>
    
</ol>

            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#can-i-use-hazelcast-in-a-single-server">Can I use Hazelcast in a single server</a>
            
                
    <ol>
    
</ol>

            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#how-can-i-monitor-hazelcast">How can I monitor Hazelcast</a>
            
                
    <ol>
    
</ol>

            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#how-can-i-see-debug-level-logs">How can I see debug level logs</a>
            
                
    <ol>
    
</ol>

            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#what-is-the-difference-between-client-server-and-embedded-topologies">What is the difference between client-server and embedded topologies</a>
            
                
    <ol>
    
</ol>

            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#how-do-i-know-it-is-safe-to-kill-the-second-node">How do I know it is safe to kill the second node</a>
            
                
    <ol>
    
</ol>

            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#when-do-i-need-off-heap-solutions">When do I need Off-heap solutions</a>
            
                
    <ol>
    
</ol>

            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#is-there-any-disadvantage-of-using-near-cache">Is there any disadvantage of using near-cache</a>
            
                
    <ol>
    
</ol>

            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#is-hazelcast-secure">Is Hazelcast secure</a>
            
                
    <ol>
    
</ol>

            
        </li>
    
</ol>

            
        </li>
    
        <li>
            <a href="hazelcast-documentation.html#glossary">Glossary</a>
            
                
    <ol>
    
</ol>

            
        </li>
    
</ol>

	    </nav>
	    
	    <nav id="links">
	        <ul>
	            
	        </ul>
	    </nav>
	    
		<div id="copyright">
			Powered by <a href="http://github.com/maximebf/beautiful-docs">beautiful-docs</a> -
	        <a href="#top">Back to top</a>
		</div>
	</div>

	        <div id="content">
	            <h1 id="preface">Preface</h1>
<p>Welcome to Hazelcast Reference Manual. This manual includes concepts, instructions and samples to guide you on how to use Hazelcast and build Hazelcast applications.</p>
<p>As the reader of this manual, you must be familiar with Java programming language and should have your preferred IDE.</p>
<h5 id="product-naming">Product Naming</h5>
<p>Throughout this manual;</p>
<ul>
<li><strong>Hazelcast</strong> refers to the open source edition of Hazelcast in-memory data grid middleware. It is also the name of company providing it.</li>
<li><strong>Hazelcast Enterprise</strong> refers to the commercial edition of Hazelcast.</li>
</ul>
<h5 id="licensing">Licensing</h5>
<p>Hazelcast is free provided under Apache 2 license. Hazelcast Enterprise is commercially licensed by Hazelcast, Inc.</p>
<h5 id="trademarks">Trademarks</h5>
<p>Hazelcast is a registered trademark of Hazelcast, Inc. All other trademarks in this manual are held by their respective owners. </p>
<h5 id="customer-support">Customer Support</h5>
<p>Support for Hazelcast is provided via <a href="https://github.com/hazelcast/hazelcast/issues">GitHub</a>, <a href="https://groups.google.com/forum/#!forum/hazelcast">Mail Group</a> and <a href="http://www.stackoverflow.com">StackOverflow</a>. </p>
<p>For information on support for Hazelcast Enterprise, please see <a href="http://hazelcast.com/support/commercial/">hazelcast.com/support/commercial</a>.</p>
<h5 id="typographical-conventions">Typographical Conventions</h5>
<p>Below table shows the conventions used in this manual.</p>
<table>
<thead>
<tr>
<th style="text-align:left">Convention</th>
<th style="text-align:left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>bold font</strong></td>
<td style="text-align:left">- Indicates words in a sentence requiring reader&#39;s specific attention. <br> - Also indicates property/parameter values.</td>
</tr>
<tr>
<td style="text-align:left"><em>italic font</em></td>
<td style="text-align:left">- When used with &quot;&lt;&quot; and &quot;&gt;&quot; before and after it, indicates a variable in a command or code syntax that you must replace, e.g. <code>hazelcast-&lt;</code><em>version</em><code>&gt;.jar</code>. <br> - Also, Note and Related Information texts are in italic fonts.</td>
</tr>
<tr>
<td style="text-align:left"><code>monospace</code></td>
<td style="text-align:left">- Indicates file, folder, class and library names, code snippets, and inline code words in a sentence.</td>
</tr>
<tr>
<td style="text-align:left"><strong><em>RELATED INFORMATION</em></strong></td>
<td style="text-align:left">- Indicates a resource that is relevant to the topic, usually with a link or cross-reference.</td>
</tr>
<tr>
<td style="text-align:left"><img src="images/NoteSmall.jpg" alt="image"> <strong><em>NOTE</em></strong></td>
<td style="text-align:left">Indicates information that is of special interest or importance, e.g. an additional action required only in certain circumstances.</td>
</tr>
</tbody>
</table>
<p><br></br></p>
<h1 id="what-s-new-in-hazelcast-3-3">What&#39;s New in Hazelcast 3.3</h1>
<h2 id="release-notes">Release Notes</h2>
<h3 id="new-features">New Features</h3>
<p>This section provides the new features introduced with Hazelcast 3.3 release. </p>
<ul>
<li>Heartbeat for Java client: Before this release, a Java client could not detect a node as dead, if the client is not trying to connect to it. With this heartbeat feature, each node will be pinged periodically. If no response is returned from a node, it will be deemed as dead. Main goal of this feature is to decrease the time for detection of dead (disconnected) nodes by Java clients, so that the user operations will be sent directly to a responsive one. For more information, please see <a href="#client-properties">Client Properties</a>.</li>
<li>Tomcat 6 and 7 Web Sessions Clustering: Please see <a href="#web-session-replication">Web Session Replication</a>.</li>
<li>Replicated Map implemented: Please see <a href="#replicated-map-beta">Replicated Map</a></li>
<li>WAN Replication improved: Added configurable replication queue size <a href="#wan-replication-queue-size">WAN Replication Queue Size</a>.</li>
<li>Data Aggregation implemented: Added common data aggregations, please find <a href="#aggregators">Aggregators</a> documentation.</li>
<li>EvictAll and LoadAll features for IMap: <code>evictAll</code> and <code>loadAll</code> methods have been introduced to be able to evict all entries except the locked ones and that loads all or a set of keys from a configured map store, respectively. Please see <a href="#evicting-all-entries">Evicting All Entries</a> and <a href="#forcing-all-keys-to-be-loaded">Forcing All Keys to be Loaded</a> sections for more information.</li>
<li>Hazelcast JCache implementation introduced: Starting with release 3.3.1, Hazelcast offers its JCache implementation. Please see <a href="#hazelcast-jcache-implementation">Hazelcast JCache Implementation</a> for details.</li>
</ul>
<h3 id="fixes">Fixes</h3>
<p><strong>3.3.2 Fixes</strong></p>
<p>This section lists issues solved for <strong>Hazelcast 3.3.2</strong> release.</p>
<ul>
<li>Reject multicast messages if the group configuration is not matching <a href="https://github.com/hazelcast/hazelcast/issues/3806">[#3806]</a>.</li>
<li><code>Map#getEntryView</code> should check expiration of a key <a href="https://github.com/hazelcast/hazelcast/issues/3801">[#3801]</a>.</li>
<li>Hazelcast gets stuck in <code>HazelcastInstanceNotActiveException</code> loop during multicast join <a href="https://github.com/hazelcast/hazelcast/issues/3732">[#3732]</a>.</li>
<li>Hazelcast fails to comply with <code>maxIdleTime</code> expiration when running EntryProcessors. A delay should be added to expiration times on backups <a href="https://github.com/hazelcast/hazelcast/issues/3710">[#3710]</a>.</li>
<li><code>containsKey()</code> in transactional context returns wrong value for keys deleted within transaction <a href="https://github.com/hazelcast/hazelcast/issues/3682">[#3682]</a>.</li>
<li><code>TransactionalMap.values()</code> returns stale values that was updated within the transaction boundary <a href="https://github.com/hazelcast/hazelcast/issues/3668">[#3668]</a>.</li>
<li>Number of loaded keys should not exceed map&#39;s maximum size <a href="https://github.com/hazelcast/hazelcast/issues/3608">[#3608]</a>.</li>
<li>During client node shutdown, if the cluster happens to be down, Hazelcast logs some extra messages at SEVERE level <a href="https://github.com/hazelcast/hazelcast/issues/3493">[#3493]</a>.</li>
</ul>
<p><strong>3.3.1 Fixes</strong></p>
<p>This section lists issues solved for <strong>Hazelcast 3.3.1</strong> release.</p>
<ul>
<li>MapReduce Combiner creation is not threadsafe, but certain operations on mapping phase might need a concurrent creation of the combiners <a href="https://github.com/hazelcast/hazelcast/issues/3625">[#3625]</a>.</li>
<li>When <code>connectionTimeout</code> property in ClientNetworkConfig is set to <code>Integer.MAX_VALUE</code>, the client could not connect to cluster since a default 2000 ms. extra value is added to <code>connectionTimeout</code> while connecting <a href="https://github.com/hazelcast/hazelcast/issues/3615">[#3615]</a>.</li>
<li>User provided list results from combiner is colliding with the internally used multi-result list <a href="https://github.com/hazelcast/hazelcast/issues/3614">[#3614]</a>.</li>
<li>While committing collection transactions, the collection item is being added to the collection container. However, this gives the warning &quot;There is no suitable de-serializer for type&quot; warning. Instead of collection item, transactional item should be added to the container <a href="https://github.com/hazelcast/hazelcast/issues/3603">[#3603]</a>.</li>
<li><code>MaxSizeConfig</code> constructor should convert zero size to <code>Integer.MAX_VALUE</code> <a href="https://github.com/hazelcast/hazelcast/issues/3579">[#3579]</a>.</li>
<li>If deserialization of the client request fails, the exception is not propagated back to the client  <a href="https://github.com/hazelcast/hazelcast/issues/3557">[#3557]</a>.</li>
<li>&quot;Lock is not owned by by the transaction&quot; exception. This exception was received while testing how transactions are working with Map and MultiMap for some last Hazelcast releases <a href="https://github.com/hazelcast/hazelcast/issues/3545">[#3545]</a>.</li>
<li>Main classes in <code>manifest.mf</code> files are not correctly set <a href="https://github.com/hazelcast/hazelcast/issues/3537">#3537</a>.</li>
<li>Count of evicted events may exceed the map size when &quot;read backup data&quot; feature is enabled <a href="https://github.com/hazelcast/hazelcast/issues/3515">#3515</a>.</li>
<li><code>mancenter.war</code> from Hazelcast release 3.2.5 cannot be deployed to Glassfish 3.1.2.2 and it fails to deploy <a href="https://github.com/hazelcast/hazelcast/issues/3501">#3501</a>.</li>
<li>While evicting entries from a map with the method <code>evictAll</code>, locked keys should stay in the map <a href="https://github.com/hazelcast/hazelcast/issues/3473">#3473</a>.</li>
<li>In <code>hazelcast-vm</code> module, before every test, new server container is started. And after every test, running server is terminated. This behavior causes a long test execution time. Server start-up and termination should be done before and after test class initialization and finalization <a href="https://github.com/hazelcast/hazelcast/issues/3473">#3473</a>.</li>
<li>The method <code>IQueue.take()</code> method should throw InterruptedException, but throws HazelcastException instead <a href="https://github.com/hazelcast/hazelcast/issues/3133">#3133</a>.</li>
<li>Multicast discovery doesn&#39;t work without network <a href="https://github.com/hazelcast/hazelcast/issues/2594">#2594</a>.</li>
</ul>
<p><strong>3.3 Fixes</strong></p>
<p>This section lists issues solved for <strong>Hazelcast 3.3</strong> release.</p>
<ul>
<li>TxQueue cannot find reserved items upon ownership changes <a href="https://github.com/hazelcast/hazelcast/issues/3432">[#3432]</a>.</li>
<li>Documentation update is needed to tell that PagingPredicate is only supported for Comparable objects if there is no comparator <a href="https://github.com/hazelcast/hazelcast/issues/3432">[#3428]</a>.</li>
<li><code>java.lang.NullPointerException</code> is thrown when publishing an event in ClientEndPointImpl <a href="https://github.com/hazelcast/hazelcast/issues/3407">[#3407]</a>.</li>
<li>The <code>entryUpdated()</code> callback of a listener during a transaction always has a null <code>oldValue</code> in the EntryEvent <a href="https://github.com/hazelcast/hazelcast/issues/3406">[#3406]</a>.</li>
<li>Documentation update with the links to code samples for integration modules <a href="https://github.com/hazelcast/hazelcast/issues/3389">[#3389]</a>.</li>
<li>Hazelcast write-behind with <code>map.replace()</code> stores replaced items <a href="https://github.com/hazelcast/hazelcast/issues/3386">[#3386]</a>.</li>
<li>XAResource&#39;s <code>setTransactionTimeout()</code> method is not correctly implemented <a href="https://github.com/hazelcast/hazelcast/issues/3384">[#3384]</a>.</li>
<li>Hazelcast web session replication filter may die if response committed <a href="https://github.com/hazelcast/hazelcast/issues/3360">[#3360]</a>.</li>
<li>Resource adapter state is never reset to <code>isStarted == false</code>, resulting in errors down the line <a href="https://github.com/hazelcast/hazelcast/issues/3350">[#3350]</a>.</li>
<li><code>PagingPredicate.getAnchor</code> does not return the correct value <a href="https://github.com/hazelcast/hazelcast/issues/3241">[#3241]</a>.</li>
<li>If deserialization fails, calling node is not informed <a href="https://github.com/hazelcast/hazelcast/issues/2509">[#2509]</a>.</li>
<li>CallerNotMemberException and WrongTargetException exceptions are thrown at random intervals <a href="https://github.com/hazelcast/hazelcast/issues/2253">[#2253]</a>.</li>
</ul>
<p><strong>RC3 Fixes</strong></p>
<p>This section lists issues solved for <strong>Hazelcast 3.3-RC3</strong> release.</p>
<ul>
<li>Parallel execution of <code>MapStore#store</code> method for the same key triggered by <code>IMap#flush</code> <a href="https://github.com/hazelcast/hazelcast/issues/3338">[#3338]</a>.</li>
<li>When offering null argument in queue throws an exception but it adds null argument to collection, then <code>addAll()</code> performed on this list does not throw an exception <a href="https://github.com/hazelcast/hazelcast/issues/3330">[#3330]</a>.</li>
<li><code>java.io.FileNotFoundException</code> thrown by MapLoaderTest <a href="https://github.com/hazelcast/hazelcast/issues/3324">[#3324]</a>.</li>
<li>MapMaxSizeTest Stabilizer test with SoftKill <a href="https://github.com/hazelcast/hazelcast/issues/3291">[#3291]</a>.</li>
<li>Incompatible Spring and Hazelcast configuration XSDs <a href="https://github.com/hazelcast/hazelcast/issues/3275">[#3275]</a>.</li>
<li><code>ExpirationManager</code> partition sorting can fail <a href="https://github.com/hazelcast/hazelcast/issues/3271">[#3271]</a>.</li>
<li>Configuration validation is broken <a href="https://github.com/hazelcast/hazelcast/issues/3257">[#3257]</a>.</li>
<li>Code Samples for Spring Security and WebFilter Integration <a href="https://github.com/hazelcast/hazelcast/issues/3252">[#3252]</a>.</li>
<li>WebFilter Test Cases are slow <a href="https://github.com/hazelcast/hazelcast/issues/3250">[#3250]</a>.</li>
<li>Management Center and Weblogic Deployment Problem <a href="https://github.com/hazelcast/hazelcast/issues/3247">[#3247]</a>.</li>
<li>Enabling Multicast and TCP/IP node discovery methods freeze the instances <a href="https://github.com/hazelcast/hazelcast/issues/3246">[#3246]</a>.</li>
<li><code>getOldValue</code> and <code>getValue</code> returns the same value when removing item from IMap <a href="https://github.com/hazelcast/hazelcast/issues/3198">[#3198]</a>.</li>
<li>MapTransactionContextTest: member SoftKill and then HazelcastSerializationException and IegalStateException: Nested are thrown <a href="https://github.com/hazelcast/hazelcast/issues/3196">[#3196]</a>.</li>
<li><code>IMap.delete()</code> should not call <code>MapLoader.load()</code><a href="https://github.com/hazelcast/hazelcast/issues/3178">[#3178]</a>.</li>
<li>3.3-RC3+: NPE in the method <code>connectionMarkedAsNotResponsive</code> <a href="https://github.com/hazelcast/hazelcast/issues/3169">[#3169]</a>.</li>
<li><code>WebFilter.HazelcastHttpSession.isNew()</code> does not check the Hazelcast Session Cache <a href="https://github.com/hazelcast/hazelcast/issues/3132">[#3132]</a>.</li>
<li>Hazelcast Spring XSD files are not version agnostic <a href="https://github.com/hazelcast/hazelcast/issues/3131">[#3131]</a>.</li>
<li><code>ClassCastException: java.lang.Integer</code> cannot be cast to <code>java.lang.String</code> Query <a href="https://github.com/hazelcast/hazelcast/issues/3091">[#3091]</a>.</li>
<li>Predicate returns a value not matching the predicate <a href="https://github.com/hazelcast/hazelcast/issues/3090">[#3090]</a>.</li>
<li>Modifications made by Entry Processor are lost in 3.3-RC-2 <a href="https://github.com/hazelcast/hazelcast/issues/3062">[#3062]</a>.</li>
<li>Hazelcast Session Clustering with Spring Security Problem <a href="https://github.com/hazelcast/hazelcast/issues/3049">[#3049]</a>.</li>
<li>PagingPredicate returning duplicated elements results in an infinite loop <a href="https://github.com/hazelcast/hazelcast/issues/3047">[#3047]</a>.</li>
<li><code>expirationTime</code> on EntryView is not set <a href="https://github.com/hazelcast/hazelcast/issues/3038">[#3038]</a>.</li>
<li><code>BasicRecordStoreLoader</code> cannot handle retry responses <a href="https://github.com/hazelcast/hazelcast/issues/3033">[#3033]</a>. </li>
<li>Short <code>await()</code> on condition of contended lock causes IllegalStateException <a href="https://github.com/hazelcast/hazelcast/issues/3025">[#3025]</a>. </li>
<li>Indices and Comparable<T>: not documented <a href="https://github.com/hazelcast/hazelcast/issues/3024">[#3024]</a>. </li>
<li>Marking Heartbeat as healthy is too late <a href="https://github.com/hazelcast/hazelcast/issues/3014">[#3014]</a>.</li>
<li>3.3-RC2: <code>IMap#keySet</code> triggers value deserialization <a href="https://github.com/hazelcast/hazelcast/issues/3008">[#3008]</a>.</li>
<li><code>map.destroy()</code> throws DistributedObjectDestroyedException <a href="https://github.com/hazelcast/hazelcast/issues/3001">[#3001]</a>.</li>
<li>Stabilizer tests Final profile, Xlarge cluster OperationTimeoutException <a href="https://github.com/hazelcast/hazelcast/issues/2999">[#2999]</a>.</li>
<li><code>com.hazelcast.jca.HazelcastConnection::getExecutorService</code> returns plain ExecutorService <a href="https://github.com/hazelcast/hazelcast/issues/2986">[#2986]</a>.</li>
<li>Serialization NPE in MapStoreTest stabilizer, 3.3-RC3-SNAPSHOT <a href="https://github.com/hazelcast/hazelcast/issues/2985">[#2985]</a>.</li>
<li>Bug with <code>IMap.getAll()</code> <a href="https://github.com/hazelcast/hazelcast/issues/2982">[#2982]</a>.</li>
<li>Client deadlock on single core machines <a href="https://github.com/hazelcast/hazelcast/issues/2971">[#2971]</a>.</li>
<li>Retrieve number of futures in loop in calling thread <a href="https://github.com/hazelcast/hazelcast/issues/2964">[#2964]</a>.</li>
</ul>
<p><strong>RC2 Fixes</strong></p>
<p>This section lists issues solved for <strong>Hazelcast 3.3-RC2</strong> release.</p>
<ul>
<li><code>evictAll</code> should flush to staging area <a href="https://github.com/hazelcast/hazelcast/issues/2969">#2969</a>.</li>
<li>NPE exception in MapStoreTest <a href="https://github.com/hazelcast/hazelcast/issues/2956">[#2956]</a>.</li>
<li>Fixed <code>AddSessionEntryProcessor</code> <a href="https://github.com/hazelcast/hazelcast/issues/2955">[#2955]</a>.</li>
<li>Added <code>StripedExecutor</code> to WanReplicationService <a href="https://github.com/hazelcast/hazelcast/issues/2947">[#2947]</a>.</li>
<li>All read operations of map should respect expired keys <a href="https://github.com/hazelcast/hazelcast/issues/2946">[#2946]</a>.</li>
<li>Fix test EvictionTest#testMapWideEviction <a href="https://github.com/hazelcast/hazelcast/issues/2944">[#2944]</a>.</li>
<li>Heartbeat check of clients from nodes <a href="https://github.com/hazelcast/hazelcast/issues/2936">[#2936]</a>.</li>
<li>WebFilter does not clean up timed-    out sessions <a href="https://github.com/hazelcast/hazelcast/issues/2930">[#2930]</a>.</li>
<li>Fix leaking empty concurrent hashmaps <a href="https://github.com/hazelcast/hazelcast/issues/2929">[#2929]</a>.</li>
<li>Data loss fix in <code>hazelcast-wm</code> module <a href="https://github.com/hazelcast/hazelcast/issues/2927">[#2927]</a>.</li>
<li>Configured event queue capacity <a href="https://github.com/hazelcast/hazelcast/issues/2924">[#2924]</a>.</li>
<li>Client closes owner connection when a connection to the same address is closed <a href="https://github.com/hazelcast/hazelcast/issues/2921">[#2921]</a>.</li>
<li>Close the owner connection if heartbeat timeout when client is smart <a href="https://github.com/hazelcast/hazelcast/issues/2916">[#2916]</a>.</li>
<li>Set application buffer size to not exceed <code>tls</code> record size <a href="https://github.com/hazelcast/hazelcast/issues/2914">[#2914]</a>.</li>
<li>EntryProcessor makes unnecessary serialization <a href="https://github.com/hazelcast/hazelcast/issues/2913">[#2913]</a>.</li>
<li>Make evictable time window configurable <a href="https://github.com/hazelcast/hazelcast/issues/2910">[#2910]</a>.</li>
<li>Fixes data loss issue when partition table is being synced and a node is gracefully shutdown <a href="https://github.com/hazelcast/hazelcast/issues/2908">[#2908]</a>.</li>
<li>MapStoreConfig; implementation instance is not set, when configured via XML <a href="https://github.com/hazelcast/hazelcast/issues/2898">[#2898]</a>.</li>
<li>LocalMapStats does not record stats about locked entries in 3.x <a href="https://github.com/hazelcast/hazelcast/issues/2876">[#2876]</a>.</li>
<li>Concurrency security interceptor <a href="https://github.com/hazelcast/hazelcast/issues/2874">[#2874]</a>.</li>
<li>Client hangs during split, if split occurs due to network error <a href="https://github.com/hazelcast/hazelcast/issues/2850">[#2850]</a>.</li>
<li>Network connection loss does not release lock <a href="https://github.com/hazelcast/hazelcast/issues/2818">[#2818]</a>.</li>
</ul>
<p><strong>RC1 Fixes</strong></p>
<p>This section lists issues solved for <strong>Hazelcast 3.3-RC1</strong> release.</p>
<ul>
<li>It is not possible to copy the link from <a href="http://hazelcast.org/download/">http://hazelcast.org/download/</a> and run <code>wget</code> on it <a href="https://github.com/hazelcast/hazelcast/issues/2814">[#2814]</a>.</li>
<li><code>mapCleared</code> method for EntryListener is needed <a href="https://github.com/hazelcast/hazelcast/issues/2789">[#2789]</a>.</li>
<li>The method <code>keySet</code> with predicate should trigger loading of MapStore <a href="https://github.com/hazelcast/hazelcast/issues/2692">[#2692]</a>.</li>
<li>MapStore with write-behind: The method <code>IMap.remove()</code> followed by <code>IMap.putIfAbsent(key,value)</code> still returns the old value <a href="https://github.com/hazelcast/hazelcast/issues/2685">[#2685]</a>.</li>
<li>Hazelcast cannot read UTF-8 String if &quot;multiple-byte&quot; characters end up at position that is an even multiple of buffer size <a href="https://github.com/hazelcast/hazelcast/issues/2674">[#2674]</a>.</li>
<li>Current implementation of record expiration relies on undefined behavior of <code>System.nanoTime()</code> <a href="https://github.com/hazelcast/hazelcast/issues/2666">[#2666]</a>.</li>
<li>Inconsistency at Hazelcast Bootup &quot;Editions&quot; message <a href="https://github.com/hazelcast/hazelcast/issues/2641">[#2641]</a>.</li>
<li><code>AbstractReachabilityHandler</code> writes to standard output <a href="https://github.com/hazelcast/hazelcast/issues/2591">[#2591]</a>.</li>
<li><code>IMap.set()</code> does not not remove a key from write behind deletions queue <a href="https://github.com/hazelcast/hazelcast/issues/2588">[#2588]</a>.</li>
<li><code>com.hazelcast.core.EntryView#getLastAccessTime</code> is invalid<a href="https://github.com/hazelcast/hazelcast/issues/2581">[#2581]</a>.</li>
</ul>
<h2 id="upgrading-from-2-x-versions">Upgrading from 2.x versions</h2>
<p>In this section, we list the changes what users should take into account before upgrading to latest Hazelcast from earlier versions.</p>
<ul>
<li><strong>Removal of deprecated static methods:</strong>
The static methods of Hazelcast class reaching Hazelcast data components have been removed. The functionality of these methods can be reached from HazelcastInstance interface. Namely you should replace following:</li>
</ul>
<pre><code class="lang-java">Map&lt;Integer, String&gt; customers = Hazelcast.getMap( &quot;customers&quot; );
</code></pre>
<p>with</p>
<pre><code class="lang-java">HazelcastInstance hazelcastInstance = Hazelcast.newHazelcastInstance();
// or if you already started an instance named &quot;instance1&quot;
// HazelcastInstance hazelcastInstance = Hazelcast.getHazelcastInstanceByName( &quot;instance1&quot; );
Map&lt;Integer, String&gt; customers = hazelcastInstance.getMap( &quot;customers&quot; );
</code></pre>
<ul>
<li><p><strong>Removal of lite members:</strong>
With 3.0 there will be no member type as lite member. As 3.0 clients are smart client that they know in which node the data is located, you can replace your lite members with native clients.</p>
</li>
<li><p><strong>Renaming &quot;instance&quot; to &quot;distributed object&quot;:</strong>
Before 3.0 there was a confusion for the term &quot;instance&quot;. It was used for both the cluster members and the distributed objects (map, queue, topic, etc. instances). Starting 3.0, the term instance will be only used for Hazelcast instances, namely cluster members. We will use the term &quot;distributed object&quot; for map, queue, etc. instances. So you should replace the related methods with the new renamed ones. As 3.0 clients are smart client that they know in which node the data is located, you can replace your lite members with native clients.</p>
</li>
</ul>
<pre><code class="lang-java">public static void main( String[] args ) throws InterruptedException {
  HazelcastInstance hazelcastInstance = Hazelcast.newHazelcastInstance();
  IMap map = hazelcastInstance.getMap( &quot;test&quot; );
  Collection&lt;Instance&gt; instances = hazelcastInstance.getInstances();
  for ( Instance instance : instances ) {
    if ( instance.getInstanceType() == Instance.InstanceType.MAP ) {
      System.out.println( &quot;There is a map with name: &quot; + instance.getId() );
    }
  }
}
</code></pre>
<p>with</p>
<pre><code class="lang-java">public static void main( String[] args ) throws InterruptedException {
  HazelcastInstance hazelcastInstance = Hazelcast.newHazelcastInstance();
  IMap map = hz.getMap( &quot;test&quot; );
  Collection&lt;DistributedObject&gt; objects = hazelcastInstance.getDistributedObjects();
  for ( DistributedObject distributedObject : objects ) {
    if ( distributedObject instanceof IMap ) {
      System.out.println( &quot;There is a map with name: &quot; + distributedObject.getName() );
    }
  }
}
</code></pre>
<ul>
<li><strong>Package structure change:</strong>
PartitionService has been moved to package <code>com.hazelcast.core</code> from <code>com.hazelcast.partition</code>.</li>
</ul>
<ul>
<li><strong>Listener API change:</strong>
Before 3.0, <code>removeListener</code> methods was taking the Listener object as parameter. But, it causes confusion as same listener object may be used as parameter for different listener registrations. So we have changed the listener API. <code>addListener</code> methods return you an unique ID and you can remove listener by using this ID. So you should do following replacement if needed:</li>
</ul>
<pre><code class="lang-java">IMap map = hazelcastInstance.getMap( &quot;map&quot; );
map.addEntryListener( listener, true );
map.removeEntryListener( listener );
</code></pre>
<p>with</p>
<pre><code class="lang-java">IMap map = hazelcastInstance.getMap( &quot;map&quot; );
String listenerId = map.addEntryListener( listener, true );
map.removeEntryListener( listenerId );
</code></pre>
<ul>
<li><strong>IMap changes:</strong></li>
<li><code>tryRemove(K key, long timeout, TimeUnit timeunit)</code> returns boolean indicating whether operation is successful.</li>
<li><code>tryLockAndGet(K key, long time, TimeUnit timeunit)</code> is removed.</li>
<li><code>putAndUnlock(K key, V value)</code> is removed.</li>
<li><code>lockMap(long time, TimeUnit timeunit)</code> and <code>unlockMap()</code> are removed.</li>
<li><code>getMapEntry(K key)</code> is renamed as <code>getEntryView(K key)</code>. The returned object&#39;s type, MapEntry class is renamed as EntryView.</li>
<li>There is no predefined names for merge policies. You just give the full class name of the merge policy implementation.</li>
</ul>
<pre><code class="lang-xml">&lt;merge-policy&gt;com.hazelcast.map.merge.PassThroughMergePolicy&lt;/merge-policy&gt;
</code></pre>
<p>Also MergePolicy interface has been renamed to MapMergePolicy and also returning null from the implemented <code>merge()</code> method causes the existing entry to be removed.</p>
<ul>
<li><strong>IQueue changes:</strong>
There is no change on IQueue API but there are changes on how <code>IQueue</code> is configured. With Hazelcast 3.0 there will not be backing map configuration for queue. Settings like backup count will be directly configured on queue config. For queue configuration details, please see <a href="#queue">Queue</a>.</li>
<li><strong>Transaction API change:</strong>
In Hazelcast 3.0, transaction API is completely different. Please see <a href="#transactions">Transactions</a>.</li>
<li><strong>ExecutorService API change:</strong>
Classes MultiTask and DistributedTask have been removed. All the functionality is supported by the newly presented interface IExecutorService. Please see <a href="#executor-service">Executor Service</a>.</li>
<li><strong>LifeCycleService API:</strong>
The lifecycle has been simplified. <code>pause()</code>, <code>resume()</code>, <code>restart()</code> methods have been removed.</li>
<li><strong>AtomicNumber:</strong>
<code>AtomicNumber</code> class has been renamed to <code>IAtomicLong</code>.</li>
<li><strong>ICountDownLatch:</strong>
<code>await()</code> operation has been removed. We expect users to use <code>await()</code> method with timeout parameters.</li>
<li><strong>ISemaphore API:</strong>
The <code>ISemaphore</code> has been substantially changed. <code>attach()</code>, <code>detach()</code> methods have been removed.</li>
<li>In 2.x releases, the default value for <code>max-size</code> eviction policy was <strong>cluster_wide_map_size</strong>. In 3.x releases, default is <strong>PER_NODE</strong>. After upgrading, the <code>max-size</code> should be set according to this new default, if it is not changed. Otherwise, it is likely that OutOfMemory exception may be thrown.</li>
</ul>
<h2 id="document-revision-history">Document Revision History</h2>
<table>
<thead>
<tr>
<th style="text-align:left">Chapter</th>
<th style="text-align:left">Section</th>
<th style="text-align:left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><a href="#preface">Chapter 1 - Preface</a></td>
<td style="text-align:left"></td>
<td style="text-align:left">Added as a new chapter.</td>
</tr>
<tr>
<td style="text-align:left"><a href="#distributed-data-structures">Chapter 4 - Distributed Data Structures</a></td>
<td style="text-align:left"><a href="#idgenerator">IdGenerator</a>, <a href="#icountdownlatch">ICountDownLatch</a>, <a href="#iatomic-reference">IAtomicReference</a></td>
<td style="text-align:left">Added as new sections.</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"><a href="#multimap">MultiMap</a></td>
<td style="text-align:left">Section improved by adding information about how it is implemented and by providing configuration information.</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"><a href="#map">Map</a></td>
<td style="text-align:left">Eviction section improved by adding the detailed policy and parameter explanations. A subsection on how to evict particular map entries added (<a href="#evicting-specific-entries">Evicting Specific Entries</a>). Also <a href="#map-overview">Map Overview</a> and <a href="#backups">Backups</a> sections enhanced with &quot;how it works&quot; information. Added <a href="#entry-listener">Entry Listener</a> and <a href="#map-locks">Map Locks</a> as new sections. Added <a href="#evicting-all-entries">Evicting All Entries</a> section to explain the method <code>evictAll</code>.</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"><a href="#map-persistence">Map Persistence</a></td>
<td style="text-align:left">Added <a href="#forcing-all-keys-to-be-loaded">Forcing All Keys To Be Loaded</a> section to explain the method <code>loadAll</code>. Also, added <a href="#read-through">Read-Through</a>, <a href="#write-through">Write-Through</a> and <a href="#write-behind">Write-Behind</a> sections. Section also enhanced by adding MapStore and MapLoader descriptions with a sample code. Thread information related to MapLoader interface added as a note.</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"><a href="#queue">Queue</a></td>
<td style="text-align:left">Section improved with new subsections. QueueStore interface explanations added. Bounded Queue section modified for a cleaner description.</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"><a href="#lock">Lock</a>, <a href="#isemaphore">ISemaphore</a></td>
<td style="text-align:left">Sections updated by adding fairness related warnings.</td>
</tr>
<tr>
<td style="text-align:left"><a href="#distributed-computing">Chapter 6 - Distributed Computing</a></td>
<td style="text-align:left"><a href="#executor-service">Executor Service</a></td>
<td style="text-align:left">HazelcastInstanceAware related information added.</td>
</tr>
<tr>
<td style="text-align:left"><a href="#distributed-query">Chapter 7 - Distributed Query</a></td>
<td style="text-align:left"></td>
<td style="text-align:left">Query section improved by adding &#39;how it works&#39; information. Also, <a href="#continuous-query">Continuous Query</a> section re-written and sample codes added. <a href="#aggregators">Aggregators</a> added as a new section. A note related to the indexing of non-primitive types added to <a href="#indexing">Indexing</a> section.</td>
</tr>
<tr>
<td style="text-align:left"><a href="#user-defined-services">Chapter 8 - User Defined Services</a></td>
<td style="text-align:left"></td>
<td style="text-align:left">Added as a new chapter explaining Hazelcast&#39;s Service Provider Interface (SPI).</td>
</tr>
<tr>
<td style="text-align:left"><a href="#transactions">Chapter 9 - Transactions</a></td>
<td style="text-align:left"><a href="#xa-transactions">XA Transactions</a></td>
<td style="text-align:left">Added as a new section.</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"><a href="#sample-JBoss-AS-7-EAP-6-web-application-configuration">Sample JBoss AS 7 - EAP 6 Web Application Configuration</a></td>
<td style="text-align:left">Added as a new section.</td>
</tr>
<tr>
<td style="text-align:left"><a href="#hazelcast-jcache-implementation">Chapter 10 - Hazelcast JCache Implementation</a></td>
<td style="text-align:left"></td>
<td style="text-align:left">Added as a new chapter.</td>
</tr>
<tr>
<td style="text-align:left"><a href="#integrated-clustering">Chapter 11 - Integrated Clustering</a></td>
<td style="text-align:left"><a href="#tomcat-based-web-session-replication">Tomcat Based Web Session Replication</a></td>
<td style="text-align:left">Added as a new section (Enterprise Only feature).</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"><a href="#filter-based-web-session-replication">Filter Based Web Session Replication</a></td>
<td style="text-align:left">Updated by adding SpringAwareWebFilter related information.</td>
</tr>
<tr>
<td style="text-align:left"><a href="#clients">Chapter 13 - Clients</a></td>
<td style="text-align:left"><a href="#java-client">Java Client</a></td>
<td style="text-align:left">Client configuration related to AWS added and the whole section enhanced. Also, Load Balancer related configuration information added.</td>
</tr>
<tr>
<td style="text-align:left"><a href="#serialization">Chapter 14 - Serialization</a></td>
<td style="text-align:left"></td>
<td style="text-align:left">All sections under this chapter re-written and enhanced. Also added HazelcastInstanceAware, Stream &amp; ByteArray Serializer, Serializable &amp; Externalizable sections. Chapter introduction enhanced by adding an overview, a section explaining serialization interfaces and a comparison table for these interfaces.</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"><a href="#null-portable-serialization">Null Portable Serialization</a></td>
<td style="text-align:left">Added as a new section.</td>
</tr>
<tr>
<td style="text-align:left"><a href="#management">Chapter 15 - Management</a></td>
<td style="text-align:left"><a href="#clustered-jmx">Clustered JMX</a></td>
<td style="text-align:left">Added as a new section explaining how to monitor the statistics of distributed objects from a JMX interface (Enterprise Only feature).</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"><a href="#cluster-utilities">Cluster Utilities</a></td>
<td style="text-align:left"><a href="#member-attributes">Member Attributes</a> added as a new section. Also, <a href="#cluster-member-safety-check">Cluster-Member Safety Check</a> section added explaining the PartitionService interface of Hazelcast.</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"><a href="#clustered-rest">Clustered REST</a></td>
<td style="text-align:left">Added as a new section (Enterprise Only feature).</td>
</tr>
<tr>
<td style="text-align:left"><a href="#performance">Chapter 17 - Performance</a></td>
<td style="text-align:left"><a href="#threading-model">Threading Model</a></td>
<td style="text-align:left">Added as a new section.</td>
</tr>
<tr>
<td style="text-align:left"><a href="#wan">Chapter 18 - WAN</a></td>
<td style="text-align:left"><a href="#wan-replication-queue-size">WAN Replication Queue Size</a></td>
<td style="text-align:left">Added as a new section (Enterprise only feature).</td>
</tr>
<tr>
<td style="text-align:left"><a href="#configuration">Chapter 19 - Configuration</a></td>
<td style="text-align:left"><a href="#configuring-tcp-ip-cluster">Configuring TCP/IP Cluster</a></td>
<td style="text-align:left">Section improved by adding more detailed configuration options.</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"><a href="#ec2-auto-discovery">EC2 Auto Discovery</a></td>
<td style="text-align:left">Section improved by adding AWSClient Class description, Debugging information and more detailed tag explanations.</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"><a href="#ports">Ports</a></td>
<td style="text-align:left">Added as a new section explaining how to configure ports which Hazelcast uses to communicate between nodes. Also existing &quot;Restricting Outbound Ports&quot; moved under this new section with the heading &quot;Outbound Ports&quot;.</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"><a href="#system-property">System Property</a></td>
<td style="text-align:left">Updated by adding the descriptions of missing system properties.</td>
</tr>
<tr>
<td style="text-align:left"><a href="#network-partitioning-split-brain-syndrome">Chapter 20 - Network Partitioning</a></td>
<td style="text-align:left"></td>
<td style="text-align:left">Added as a new chapter.</td>
</tr>
<tr>
<td style="text-align:left"><a href="#frequently-asked-questions">Chapter 21 - FAQ</a></td>
<td style="text-align:left"></td>
<td style="text-align:left">Updated with new questions.</td>
</tr>
<tr>
<td style="text-align:left"><a href="#glossary">Chapter 22 - Glossary</a></td>
<td style="text-align:left"></td>
<td style="text-align:left">Added as a new chapter.</td>
</tr>
</tbody>
</table>
<p><br> </br></p>
<h1 id="getting-started">Getting Started</h1>
<h2 id="hazelcast-overview">Hazelcast Overview</h2>
<p>Hazelcast is an open source In-Memory Data Grid (IMDG). 
As such it provides elastically scalable distributed In-Memory computing, widely recognized as the fastest and most scalable approach to application performance, and Hazelcast does so in open source.
More importantly it makes distributed computing simple by offering distributed implementations of developer friendly interfaces from Java such as Map, Queue, ExecutorService, Lock, JCache and many more. For example, the Map interface provides an In-Memory Key Value store which confers many of the advantages of NoSQL in terms of developer friendliness and developer productivity.</p>
<p>In addition to distributing data In-Memory, Hazelcast provides a convenient set of APIs to access the CPUs in your cluster for maximum processing speed. 
Hazelcast is designed to be lightweight and easy to use. Since Hazelcast is delivered as a compact library (JAR) and has no external dependencies other than Java, it is easily pluggable into your software solution to provide distributed data structures and distributed computing utilities. </p>
<p>Hazelcast is highly scalable and available. Distributed applications can use Hazelcast for distributed caching, synchronization, clustering, processing, pub/sub messaging, etc. Hazelcast is implemented in Java and has clients for Java, C/C++, .NET as well as REST. Hazelcast can also speak memcache protocol. It also plugs in to Hibernate and can easily be used with any existing database system.</p>
<p>If you are looking for In-Memory speed, elastic scalability and the developer friendliness of NoSQL, Hazelcast is a great choice for you.</p>
<p><strong>Hazelcast is simple</strong></p>
<p>Hazelcast is written in Java with no other dependencies. It exposes the same API from the familiar Java util package. Just add <code>hazelcast.jar</code> to your classpath, enjoy JVMs clustering in less than a minute and start building scalable applications. </p>
<p><strong>Hazelcast is Peer-to-Peer</strong></p>
<p>Unlike many NoSQL solutions, Hazelcast is peer-to-peer. There is no master and slave; there is no single point of failure. All nodes store equal amount of data and do equal amount of processing. Hazelcast can be embedded to your existing application or used in client and server mode where your application is client to the Hazelcast nodes.</p>
<p><strong>Hazelcast is scalable</strong></p>
<p>Hazelcast is designed to scale up to hundreds and thousands of nodes. Simply add new nodes and they will automatically discover the cluster and will linearly increase both memory and processing capacity. The nodes maintain a TCP connection between each other and all communication is performed through this layer.</p>
<p><strong>Hazelcast is fast</strong></p>
<p>Hazelcast stores everything in-memory. It is designed to perform very fast reads and updates.</p>
<p><strong>Hazelcast is redundant</strong></p>
<p>Hazelcast keeps the backup of each data entry on multiple nodes. On a node failure, the data is restored from the backup and cluster will continue to operate without a downtime.</p>
<p><strong>Sharding in Hazelcast</strong></p>
<p>Hazelcast shards are called Partitions. By default, Hazelcast has 271 partitions. Given a key; we serialize, hash and mode it with the number of partitions to find the partition it belongs to. The partitions themselves are distributed equally among the members of the cluster. Hazelcast also creates the backups of partitions and also distributes them among nodes for redundancy.</p>
<p>Partitions in a 1 node Hazelcast cluster.</p>
<p><img src="images/NodePartition.jpg" alt=""></p>
<p>Partitions in a 2 node cluster. </p>
<p><img src="images/BackupPartitions.jpg" alt=""></p>
<p>The blacks are primary partitions and reds are backups. In the above illustration, first node has 135 primary partitions (black) and each of these partitions are backed up in the second node (red). At the same time, first node has the backup partitions of second node&#39;s primary partitions.</p>
<p>As you add more nodes, Hazelcast will move one by one some of the primary and backup partitions to new nodes to make all nodes equal and redundant. Only minimum amount of partitions will be moved to scale out Hazelcast.</p>
<p><img src="images/4NodeCluster.jpg" alt=""></p>
<p><strong>Hazelcast Topology</strong></p>
<p>If you have an application whose main focal point is asynchronous or high performance computing and lots of task executions, then embedded deployment is the most useful. In this type, nodes include both the application and data, see the below illustration.</p>
<p><img src="images/P2Pcluster.jpg" alt=""></p>
<p>You can have a cluster of server nodes that can be independently created and scaled. Your clients communicate with these server nodes to reach to the data on them. Hazelcast provides native clients (Java, .NET and C++), Memcache clients and REST clients. See the below illustration.</p>
<p><img src="images/CSCluster.jpg" alt=""></p>
<h2 id="why-hazelcast-">Why Hazelcast?</h2>
<p><strong>A Glance at Traditional Data Persistence</strong></p>
<p>Data is at the core of software systems and in conventional architectures, relational database persists and provides access to data. Basically, applications are talking directly with a database which has its backup as another machine. To increase the performance, tuning or a faster machine is required. This leads to a large amount of money or effort.</p>
<p>Then, there is the idea of keeping copies of data next to the database. This is performed using technologies like external key-value stores or second level caching. This helps to offload the database. However, when the database is saturated or if the applications perform mostly &quot;put&quot; operations (writes), this approach is of no use, since it insulates the database only from the &quot;get&quot; loads (reads). Even if the applications is read intensive, then there can be consistency problems: when data changes, what happens to the cache, and how are the changes handled? This is when concepts like time-to-live (TTL) or write-through come in.</p>
<p>However, in the case of TTL, if the access is less frequent then the TTL, the result will always be a cache miss. On the other hand, in the case of write-through caches; if there are more than one of these caches in a cluster, then we again have consistency issues. This can be avoided by having the nodes communicating with each other so that entry invalidations can be propagated.</p>
<p>We can conclude that an ideal cache would combine TTL and write-through features. And, there are several cache servers and in-memory database solutions in this field. However, those are stand-alone single instances with a distribution mechanism to an extent provided by other technologies. This brings us back to square one: we would experience saturation or capacity issues if the product is a single instance or if consistency is not provided by the distribution.</p>
<p><strong>And, there is Hazelcast</strong></p>
<p>Hazelcast, a brand new approach to data, is designed around the concept of distribution. Data is shared around the cluster for flexibility and performance. It is an in-memory data grid for clustering and highly scalable data distribution.</p>
<p>One of the main features of Hazelcast is not having a master node. Each node in the cluster is configured to be the same in terms of functionality. The oldest node manages the cluster members, i.e. automatically performs the data assignment to nodes.</p>
<p>Another main feature is the data being held entirely in-memory. This is fast. In the case of a failure, such as a node crash, no data will be lost since Hazelcast distributes copies of data across all the nodes of cluster.</p>
<p>As it can be seen in the feature list given in <a href="#hazelcast-overview">Hazelcast Overview</a> section, Hazelcast supports a number of distributed data structures and distributed computing utilities. This provides powerful ways of accessing distributed clustered memory, but also CPUs for true distributed computing. </p>
<p><strong>Hazelcast&#39;s Distinctive Strengths</strong></p>
<ul>
<li>It is open source.</li>
<li>It is a small JAR file. You do not need to install software.</li>
<li>It is a library, it does not impose an architecture on Hazelcast users.</li>
<li>It provides out of the box distributed data structures (i.e. Map, Queue, MultiMap, Topic, Lock, Executor, etc.).</li>
<li>There is no &quot;master&quot;, so no single point of failure in Hazelcast cluster; each node in the cluster is configured to be functionally the same.</li>
<li>When the size of your memory and compute requirement increases, new nodes can be dynamically joined to the cluster to scale elastically.</li>
<li>Data is resilient to node failure. Data backups are also distributed across the cluster. As can be noticed, this is a big benefit when a node in the cluster is gone (e.g. crashes). Data will not be lost.</li>
<li>Nodes are always aware of each other (and they communicate) unlike traditional key-value caching solutions.</li>
<li>You can build your own custom distributed data structures using the Service Programming Interface (SPI), if you are not happy with the ones provided.</li>
</ul>
<p>Finally, Hazelcast has a vibrant open source community enabling it to be continuously developed.</p>
<p>Hazelcast is a fit when you need:</p>
<ul>
<li>Analytic applications requiring big data processing by partitioning the data,</li>
<li>Retaining frequently accessed data in the grid,</li>
<li>A cache, particularly an open source JCache provider with elastic distributed scalability,</li>
<li>A primary data store for applications with utmost performance, scalability and low-latency requirements,</li>
<li>An In-Memory NoSQL Key Value Store,</li>
<li>Publish/subscribe communication at highest speed and scalability between applications,</li>
<li>Applications that need to scale elastically in distributed and cloud environments,</li>
<li>A highly available distributed cache for applications,</li>
<li>As an alternative to Coherence, Gemfire and Terracotta.</li>
</ul>
<h2 id="installation">Installation</h2>
<h3 id="hazelcast">Hazelcast</h3>
<p>It is more than simple to start enjoying Hazelcast:</p>
<ul>
<li><p>Download <code>hazelcast-&lt;</code><em>version</em><code>&gt;.zip</code> from <a href="http://www.hazelcast.org/download/">www.hazelcast.org</a>.</p>
</li>
<li><p>Unzip <code>hazelcast-&lt;</code><em>version</em><code>&gt;.zip</code> file.</p>
</li>
<li><p>Add <code>hazelcast-&lt;</code><em>version</em><code>&gt;.jar</code> file into your classpath.</p>
</li>
</ul>
<p>That is all.</p>
<p>Alternatively, Hazelcast can be found in standard Maven repositories. So, if your project uses Maven, you do not need to add additional repositories to your <code>pom.xml</code>. Just add the following lines to <code>pom.xml</code>:</p>
<pre><code class="lang-xml">&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;com.hazelcast&lt;/groupId&gt;
        &lt;artifactId&gt;hazelcast&lt;/artifactId&gt;
        &lt;version&gt;3.3&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
<h3 id="hazelcast-enterprise">Hazelcast Enterprise</h3>
<p>There are two Maven repositories defined for Hazelcast Enterprise:</p>
<pre><code>&lt;repository&gt;
       &lt;id&gt;Hazelcast Private Snapshot Repository&lt;/id&gt;
       &lt;url&gt;https://repository-hazelcast-l337.forge.cloudbees.com/snapshot/&lt;/url&gt;
&lt;/repository&gt;
&lt;repository&gt;
        &lt;id&gt;Hazelcast Private Release Repository&lt;/id&gt;
        &lt;url&gt;https://repository-hazelcast-l337.forge.cloudbees.com/release/&lt;/url&gt;
&lt;/repository&gt;
</code></pre><p>Hazelcast Enterprise customers may also define dependencies, a sample of which is shown below.</p>
<pre><code>&lt;dependency&gt;
     &lt;groupId&gt;com.hazelcast&lt;/groupId&gt;
     &lt;artifactId&gt;hazelcast-enterprise-tomcat6&lt;/artifactId&gt;
     &lt;version&gt;${project.version}&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
     &lt;groupId&gt;com.hazelcast&lt;/groupId&gt;
     &lt;artifactId&gt;hazelcast-enterprise-tomcat7&lt;/artifactId&gt;
     &lt;version&gt;${project.version}&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
      &lt;groupId&gt;com.hazelcast&lt;/groupId&gt;
      &lt;artifactId&gt;hazelcast-enterprise&lt;/artifactId&gt;
      &lt;version&gt;${project.version}&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
      &lt;groupId&gt;com.hazelcast&lt;/groupId&gt;
      &lt;artifactId&gt;hazelcast-enterprise-all&lt;/artifactId&gt;
      &lt;version&gt;${project.version}&lt;/version&gt;
&lt;/dependency&gt;
</code></pre><h5 id="setting-the-license-key-for-hazelcast-enterprise">Setting the License Key for Hazelcast Enterprise</h5>
<p>To be able to use Hazelcast Enterprise, you need to set license the key in configuration.</p>
<ul>
<li><strong>Declarative Configuration</strong></li>
</ul>
<pre><code class="lang-xml">&lt;hazelcast&gt;
  ...
  &lt;license-key&gt;HAZELCAST_ENTERPRISE_LICENSE_KEY&lt;/license-key&gt;
  ...
&lt;/hazelcast&gt;
</code></pre>
<ul>
<li><strong>Programmatic Configuration</strong></li>
</ul>
<pre><code class="lang-java">Config config = new Config();
config.setLicenseKey( &quot;HAZELCAST_ENTERPRISE_LICENSE_KEY&quot; );
</code></pre>
<ul>
<li><strong>Spring XML Configuration</strong></li>
</ul>
<pre><code class="lang-xml">&lt;hz:config&gt;
  ...
  &lt;hz:license-key&gt;HAZELCAST_ENTERPRISE_LICENSE_KEY&lt;/hz:license-key&gt;
  ...
&lt;/hz:config&gt;
</code></pre>
<ul>
<li><strong>JVM System Property</strong></li>
</ul>
<pre><code class="lang-plain">-Dhazelcast.enterprise.license.key=HAZELCAST_ENTERPRISE_LICENSE_KEY
</code></pre>
<p><br> </br></p>
<h2 id="starting-the-cluster-and-client">Starting the Cluster and Client</h2>
<p>Having <code>hazelcast-</code><em><code>&lt;version&gt;</code></em><code>.jar</code> added to your classpath, it is time to get started. </p>
<p>In this short tutorial, we will:</p>
<ol>
<li>Create a simple Java application using Hazelcast distributed map and queue. </li>
<li>Then, we will run our application twice to have two nodes (JVMs) clustered. </li>
<li>And, connect to our cluster from another Java application by using Hazelcast Native Java Client API.</li>
</ol>
<p>Let&#39;s begin.</p>
<ul>
<li>Following code will start the first node and create and use <code>customers</code> map and queue.</li>
</ul>
<pre><code class="lang-java">import com.hazelcast.core.Hazelcast;
import com.hazelcast.core.HazelcastInstance;

import java.util.Map;
import java.util.Queue;

public class GettingStarted {
  public static void main( String[] args ) {
    HazelcastInstance hazelcastInstance = Hazelcast.newHazelcastInstance();
    Map&lt;Integer, String&gt; customers = hazelcastInstance.getMap( &quot;customers&quot; );
    customers.put( 1, &quot;Joe&quot; );
    customers.put( 2, &quot;Ali&quot; );
    customers.put( 3, &quot;Avi&quot; );

    System.out.println( &quot;Customer with key 1: &quot; + customers.get(1) );
    System.out.println( &quot;Map Size:&quot; + hazelcastInstance.size() );

    Queue&lt;String&gt; queueCustomers = hazelcastInstance.getQueue( &quot;customers&quot; );
    queueCustomers.offer( &quot;Tom&quot; );
    queueCustomers.offer( &quot;Mary&quot; );
    queueCustomers.offer( &quot;Jane&quot; );
    System.out.println( &quot;First customer: &quot; + queueCustomers.poll() );
    System.out.println( &quot;Second customer: &quot;+ queueCustomers.peek() );
    System.out.println( &quot;Queue size: &quot; + queueCustomers.size() );
  }
}
</code></pre>
<ul>
<li>Run this class second time to get the second node started. Have you seen they formed a cluster? You should see something like this:</li>
</ul>
<pre><code>Members [2] {
  Member [127.0.0.1:5701]
  Member [127.0.0.1:5702] this
}
</code></pre><ul>
<li><p>Now, add <code>hazelcast-client-</code><em><code>&lt;version&gt;</code></em><code>.jar</code> to your classpath, too. This is required to be able to use a Hazelcast client. </p>
</li>
<li><p>Following code will start a Hazelcast Client, connect to our two node cluster and print the size of our <code>customers</code> map.</p>
</li>
</ul>
<pre><code class="lang-java">package com.hazelcast.test;

import com.hazelcast.client.config.ClientConfig;
import com.hazelcast.client.HazelcastClient;
import com.hazelcast.core.HazelcastInstance;
import com.hazelcast.core.IMap;

public class GettingStartedClient {
    public static void main( String[] args ) {
        ClientConfig clientConfig = new ClientConfig();
        HazelcastInstance client = HazelcastClient.newHazelcastClient( clientConfig );
        IMap map = client.getMap( &quot;customers&quot; );
        System.out.println( &quot;Map Size:&quot; + map.size() );
    }
}
</code></pre>
<ul>
<li>When you run it, you will see the client properly connecting to the cluster and printing the map size as <strong>3</strong>.</li>
</ul>
<p>Hazelcast also offers a tool, <strong>Management Center</strong>, that enables monitoring your cluster. To be able to use it, deploy the <code>mancenter-</code><em><code>&lt;version&gt;</code></em><code>.war</code> included in the ZIP file to your web server. You can use it to monitor your maps, queues, other distributed data structures and nodes. Please see <a href="#management-center">Management Center</a> for usage explanations.</p>
<p>By default Hazelcast uses Multicast to discover other nodes to form a cluster.  If you are working with other Hazelcast developers on the same network, you may find yourself joining their clusters using the default settings.  Hazelcast provides a way to segregate clusters within the same network when using Multicast. Please see <a href="#how-do-i-create-separate-clusters">How do I create separate clusters</a> for more information.  Alternatively, if you do not wish to use the default Multicast mechanism, you can provide a fixed list of IP addresses that are allowed to join. Please see the section <a href="#network-configuration">Configuring TCP/IP Cluster</a> for more information.</p>
<p><br> </br></p>
<p><strong><em>RELATED INFORMATION</em></strong></p>
<p><em>You can also check the video tutorials <a href="http://hazelcast.org/getting-started/">here</a>.</em></p>
<h2 id="configuring-hazelcast">Configuring Hazelcast</h2>
<p>While Hazelcast is starting up, it checks for the configuration as follows:</p>
<ul>
<li><p>First, it looks for <code>hazelcast.config</code> system property. If it is set, its value is used as the path. It is useful if you want to be able to change your Hazelcast configuration. This is possible because it is not embedded within the application. The <code>config</code> option can be set by the below command:</p>
<p><code>- Dhazelcast.config=</code><em><code>&lt;path to the hazelcast.xml&gt;</code></em>.</p>
<p>The path can be a normal one or a classpath reference with the prefix <code>CLASSPATH</code>.</p>
</li>
<li>If the above system property is not set, Hazelcast then checks whether there is a <code>hazelcast.xml</code> file in the working directory.</li>
<li>If not, then it checks whether <code>hazelcast.xml</code> exists on the classpath.</li>
<li>If none of the above works, Hazelcast loads the default configuration, i.e. <code>hazelcast-default.xml</code> that comes with <code>hazelcast.jar</code>.</li>
</ul>
<p>When you download and unzip <code>hazelcast-&lt;</code><em>version</em><code>&gt;.zip</code> you will see the <code>hazelcast.xml</code> in <code>/bin</code> folder. This is the configuration XML file for Hazelcast, a part of which is shown below.</p>
<p><img src="images/HazelcastXML.jpg" alt=""></p>
<p>For most of the users, default configuration should be fine. If not, you can tailor this XML file according to your needs by adding/removing/modifying properties (Declarative Configuration). Please refer to <a href="#advanced-configuration-properties">Configuration Properties</a> for details.</p>
<p>Besides declarative configuration, you can configure your cluster programmatically (Programmatic Configuration). Just instantiate a <code>Config</code> object and add/remove/modify properties.</p>
<p>You can also use wildcards while configuring Hazelcast. Please refer to the section <a href="#using-wildcard">Using Wildcard</a> for details.</p>
<p><br></br></p>
<p><strong><em>RELATED INFORMATION</em></strong></p>
<p><em>Please refer to <a href="#configuration">Configuration</a> chapter for more information.</em></p>
<h2 id="use-cases">Use Cases</h2>
<p>Some example usages are listed below. Hazelcast can be used:</p>
<ul>
<li>To share server configuration/information to see how a cluster performs,</li>
</ul>
<ul>
<li>To cluster highly changing data with event notifications (e.g. user based events) and to queue and distribute background tasks,</li>
</ul>
<ul>
<li>As a simple Memcache with near cache,</li>
</ul>
<ul>
<li>As a cloud-wide scheduler of certain processes that need to be performed on some nodes,</li>
</ul>
<ul>
<li>To share information (user information, queues, maps, etc.) on the fly with multiple nodes in different installations under OSGI environments,</li>
</ul>
<ul>
<li>To share thousands of keys in a cluster where there is a web service interface on application server and some validation,</li>
</ul>
<ul>
<li>As a distributed topic (publish/subscribe server) to build scalable chat servers for smartphones,</li>
</ul>
<ul>
<li>As a front layer for Cassandra back end,</li>
</ul>
<ul>
<li>To distribute user object states across the cluster, to pass messages between objects and to share system data structures (static initialization state, mirrored objects, object identity generators),</li>
</ul>
<ul>
<li>As a multi-tenancy cache where each tenant has its own map,</li>
</ul>
<ul>
<li>To share datasets (e.g. table-like data structure) to be used by applications,</li>
</ul>
<ul>
<li>To distribute the load and collect status from Amazon EC2 servers where front-end is developed using, for example, Spring framework,</li>
</ul>
<ul>
<li><p>As a real time streamer for performance detection,</p>
</li>
<li><p>As a storage for session data in web applications (enables horizontal scalability of the web application).</p>
</li>
</ul>
<h2 id="resources">Resources</h2>
<ul>
<li>Hazelcast source code can be found at <a href="https://github.com/hazelcast/hazelcast">Github/Hazelcast</a>.</li>
<li>Hazelcast API can be found at <a href="http://www.hazelcast.org/docs/latest/javadoc/">Hazelcast.org/docs/Javadoc</a>.</li>
<li>Code samples can be downloaded from <a href="http://hazelcast.org/download/">Hazelcast.org/download</a>.</li>
<li>More use cases and resources can be found at <a href="http://www.hazelcast.com">Hazelcast.com</a>.</li>
<li>Questions and discussions can be post at <a href="https://groups.google.com/forum/#!forum/hazelcast">Hazelcast mail group</a>.</li>
</ul>
<p><br> </br></p>
<h1 id="distributed-data-structures">Distributed Data Structures</h1>
<p>As mentioned in the <a href="#hazelcast-overview">Overview</a> section, Hazelcast offers distributed implementations of Java interfaces. Below is the full list with links to their sections in this manual.</p>
<ul>
<li><p><strong>Standard utility collections:</strong></p>
<ul>
<li><a href="#map">Map</a>: Distributed implementation of <code>java.util.Map</code>. Operations like reading and writing from/to a Hazelcast map can be performed with the well known methods like get and put.</li>
<li><a href="#queue">Queue</a>: Distributed queue is an implementation of <code>java.util.concurrent.BlockingQueue</code>. You can add an item in one machine and remove it from another one.</li>
<li><a href="#set">Set</a>: Distributed and concurrent implementation of <code>java.util.Set</code>. It does not allow duplicate elements and does not preserve their order.</li>
<li><a href="#list">List</a>: Very similar to Hazelcast List, except that it allows duplicate elements and preserver their order.</li>
<li><a href="#multimap">MultiMap</a>: It is a specialized Hazelcast map, meaning it is distributed, where multiple values under a single key can be stored.</li>
<li><a href="#replicated-map">ReplicatedMap</a>: It does not partition data, i.e. it does not spread data to different cluster members, but replicates the data to all nodes.</li>
</ul>
</li>
<li><strong>Topic</strong>: Distributed mechanism for publishing messages that are delivered to multiple subscribers which is also known as publish/subscribe (pub/sub) messaging model. Please see <a href="#topic">Topic</a> for more information.</li>
<li><strong>Concurrency utilities</strong>:<ul>
<li><a href="#lock">Lock</a>: Distributed implementation of <code>java.util.concurrent.locks.Lock</code>. When you lock using Hazelcast Lock, the critical section that it guards is guaranteed to be executed by only one thread in entire cluster.</li>
<li><a href="#isemaphore">Semaphore</a>: Distributed implementation of <code>java.util.concurrent.Semaphore</code>. When performing concurrent activities semaphores offer permits to control the thread counts.</li>
<li><a href="#iatomiclong">AtomicLong</a>: Distributed implementation of <code>java.util.concurrent.atomic.AtomicLong</code>. Most of AtomicLong&#39;s operations are offered but these operations involve remote calls and hence their performances differ from AtomicLong, due to being distributed.</li>
<li><a href="#iatomicreference">AtomicReference</a>: When you need to deal with a reference in a distributed environment, you can use Hazelcast AtomicReference that is the distributed version of <code>java.util.concurrent.atomic.AtomicReference</code>.</li>
<li><a href="#idgenerator">IdGenerator</a>: Hazelcast IdGenerator is used to generate cluster-wide unique identifiers and ID generation occurs almost at the speed of <code>AtomicLong.incrementAndGet()</code>.</li>
<li><a href="#icountdownlatch">CountdownLatch</a>: Distributed implementation of <code>java.util.concurrent.CountDownLatch</code>. It is a gate keeper for concurrent activities, enabling the threads to wait for other threads to complete their operations.</li>
</ul>
</li>
</ul>
<p>Common Features of all Hazelcast Data Structures:</p>
<ul>
<li>If a member goes down, its backup replica that also holds the same data, will dynamically redistribute the data including the ownership and locks on them to remaining live nodes. As a result, no data will get lost.</li>
<li>There is no single cluster master or something that can cause single point of failure. Every node in the cluster has equal rights and responsibilities. No-one is superior. And no dependency on external &#39;server&#39; or &#39;master&#39; kind of concept.</li>
</ul>
<p>Here is how you can retrieve existing data structure instances (map, queue, set, lock, topic, etc.) and how you can listen for instance events to get notified when an instance is created or destroyed.</p>
<pre><code class="lang-java">import java.util.Collection;
import com.hazelcast.config.Config;
import com.hazelcast.core.*;

public class Sample implements DistributedObjectListener {
  public static void main(String[] args) {
    Sample sample = new Sample();

    Config config = new Config();
    HazelcastInstance hazelcastInstance = Hazelcast.newHazelcastInstance(config);
    hazelcastInstance.addDistributedObjectListener(sample);

    Collection&lt;DistributedObject&gt; distributedObjects = hazelcastInstance.getDistributedObjects();
    for (DistributedObject distributedObject : distributedObjects) {
      System.out.println(distributedObject.getName() + &quot;,&quot; + distributedObject.getId());
    }
  }

  @Override
  public void distributedObjectCreated(DistributedObjectEvent event) {
    DistributedObject instance = event.getDistributedObject();
    System.out.println(&quot;Created &quot; + instance.getName() + &quot;,&quot; + instance.getId());
  }

  @Override
  public void distributedObjectDestroyed(DistributedObjectEvent event) {
    DistributedObject instance = event.getDistributedObject();
    System.out.println(&quot;Destroyed &quot; + instance.getName() + &quot;,&quot; + instance.getId());
  }
}
</code></pre>
<h2 id="map">Map</h2>
<h3 id="map-overview">Map Overview</h3>
<p>Hazelcast Map (<code>IMap</code>) extends the interface <code>java.util.concurrent.ConcurrentMap</code> and hence <code>java.util.Map</code>. In simple terms, it is the distributed implementation of Java map. And operations like reading and writing from/to a Hazelcast map can be performed with the well known methods like get and put.</p>
<h4 id="how-distributed-map-works">How Distributed Map Works</h4>
<p>Hazelcast will partition your map entries and almost evenly distribute onto all Hazelcast members. Each member carries approximately &quot;(1/n <code>*</code> total-data) + backups&quot;, <strong>n</strong> being the number of nodes in the cluster.</p>
<p>Just for exemplary purposes, let&#39;s create a Hazelcast instance (node) and fill a map named <code>Capitals</code> with key-value pairs using the below code.</p>
<pre><code class="lang-java">public class FillMapMember {
  public static void main( String[] args ) { 
    HazelcastInstance hzInstance = Hazelcast.newHazelcastInstance();
    Map&lt;String, String&gt; capitalcities = hzInstance.getMap( &quot;capitals&quot; ); 
    capitalcities.put( &quot;1&quot;, &quot;Tokyo&quot; );
    capitalcities.put( &quot;2&quot;, &quot;Paris” );
    capitalcities.put( &quot;3&quot;, &quot;Washington&quot; );
    capitalcities.put( &quot;4&quot;, &quot;Ankara&quot; );
    capitalcities.put( &quot;5&quot;, &quot;Brussels&quot; );
    capitalcities.put( &quot;6&quot;, &quot;Amsterdam&quot; );
    capitalcities.put( &quot;7&quot;, &quot;New Delhi&quot; );
    capitalcities.put( &quot;8&quot;, &quot;London&quot; );
    capitalcities.put( &quot;9&quot;, &quot;Berlin&quot; );
    capitalcities.put( &quot;10&quot;, &quot;Oslo&quot; );
    capitalcities.put( &quot;11&quot;, &quot;Moscow&quot; );
    ...
    ...
    capitalcities.put( &quot;120&quot;, &quot;Stockholm&quot; )
  }
}
</code></pre>
<p>When you run this code, a node is created with a map whose entries are distributed across the node&#39;s partitions. See the below illustration. This is a single node cluster for now.</p>
<p><img src="images/1Node.jpg" alt=""></p>
<p><img src="images/NoteSmall.jpg" alt="image"> <strong><em>NOTE:</em></strong> <em>Please note that some of the partitions will not contain any data entries since we only have 120 objects and the partition count is 271 by default. This count is configurable and can be changed using the system property <code>hazelcast.partition.count</code>. Please see <a href="#advanced-configuration-properties">Advanced Configuration Properties</a>.</em></p>
<p>Now, let&#39;s create a second node which will result in a cluster with 2 nodes. This is where backups of entries are created, too. Please remember the backup partitions mentioned in <a href="#hazelcast-overview">Hazelcast Overview</a> section. So, run the above code again to create the second node. Below illustration shows two nodes and how the data and its backup is distributed.</p>
<p><img src="images/2Nodes.jpg" alt=""></p>
<p>As you see, when a new member joins the cluster, it takes ownership (responsibility) and load of -some- of the entire data in the cluster. Eventually, it will carry almost &quot;(1/n <code>*</code> total-data) + backups&quot; and reduces the load on others.</p>
<p><code>HazelcastInstance::getMap</code> actually returns an instance of <code>com.hazelcast.core.IMap</code> which extends <code>java.util.concurrent.ConcurrentMap</code> interface. So methods like <code>ConcurrentMap.putIfAbsent(key,value)</code> and <code>ConcurrentMap.replace(key,value)</code> can be used on distributed map as shown in the example below.</p>
<pre><code class="lang-java">import com.hazelcast.core.Hazelcast;
import com.hazelcast.core.HazelcastInstance;
import java.util.concurrent.ConcurrentMap;

HazelcastInstance hazelcastInstance = Hazelcast.newHazelcastInstance();

Customer getCustomer( String id ) {
    ConcurrentMap&lt;String, Customer&gt; customers = hazelcastInstance.getMap( &quot;customers&quot; );
    Customer customer = customers.get( id );
    if (customer == null) {
        customer = new Customer( id );
        customer = customers.putIfAbsent( id, customer );
    }
    return customer;
}               

public boolean updateCustomer( Customer customer ) {
    ConcurrentMap&lt;String, Customer&gt; customers = hazelcastInstance.getMap( &quot;customers&quot; );
    return ( customers.replace( customer.getId(), customer ) != null );            
}

public boolean removeCustomer( Customer customer ) {
    ConcurrentMap&lt;String, Customer&gt; customers = hazelcastInstance.getMap( &quot;customers&quot; );
    return customers.remove( customer.getId(), customer );           
}
</code></pre>
<p>All <code>ConcurrentMap</code> operations such as <code>put</code> and <code>remove</code> might wait if the key is locked by another thread in the local or remote JVM. But, they will eventually return with success. <code>ConcurrentMap</code> operations never throw <code>java.util.ConcurrentModificationException</code>.</p>
<p>Also see:</p>
<ul>
<li><p><a href="#data-affinity">Data Affinity</a>.</p>
</li>
<li><p><a href="#using-wildcard">Map Configuration with wildcards</a>.</p>
</li>
</ul>
<h3 id="map-backups">Map Backups</h3>
<p>Hazelcast will distribute map entries onto multiple JVMs (cluster members). Each JVM holds some portion of the data but you do not want to lose data when a JVM crashes.</p>
<p>Distributed maps have 1 backup by default so that if a member goes down, you do not lose data. Backup operations are synchronous, so when a <code>map.put(key, value)</code> returns, it is guaranteed that the entry is replicated to one other node. For the reads, it is also guaranteed that <code>map.get(key)</code> returns the latest value of the entry. Consistency is strictly enforced.</p>
<h4 id="sync-backup">Sync Backup</h4>
<p>To provide data safety, Hazelcast allows you to specify the number of backup copies you want to have. That way, data on a JVM will be copied onto other JVM(s). It is configured using the <code>backup-count</code> property.</p>
<pre><code class="lang-xml">&lt;hazelcast&gt;
  &lt;map name=&quot;default&quot;&gt;
    &lt;backup-count&gt;1&lt;/backup-count&gt;
  &lt;/map&gt;
&lt;/hazelcast&gt;
</code></pre>
<p>When this count is 1, it means that a map entry will have its backup on another node in the cluster. If it is set as 2, then it will have its backup on two other nodes. It can be set as 0, if you do not want your entries to be backed up, e.g. if performance is more important than backing up. Maximum value for this property is 6.</p>
<p>Hazelcast supports both synchronous and asynchronous backups. By default, backup operations are synchronous (configured with <code>backup-count</code>). In this case, backup operations block operations until backups are successfully copied to backups nodes (or deleted from backup nodes in case of remove) and acknowledgements are received. Therefore, for example, you can be sure that backups are updated before a <code>put</code> operation is completed. Of course, sync backup operations have a blocking cost which may lead to latency issues.</p>
<h4 id="async-backup">Async Backup</h4>
<p>Asynchronous backups, on the other hand, do not block operations. They are fire &amp; forget and do not require acknowledgements (backup operations are performed at some point in time). Async backup is configured using the <code>async-backup-count</code> property.</p>
<pre><code class="lang-xml">&lt;hazelcast&gt;
  &lt;map name=&quot;default&quot;&gt;
    &lt;backup-count&gt;0&lt;/backup-count&gt;
    &lt;async-backup-count&gt;1&lt;/async-backup-count&gt;
  &lt;/map&gt;
&lt;/hazelcast&gt;
</code></pre>
<p><br></br>
<img src="images/NoteSmall.jpg" alt="image"> <strong><em>NOTE:</em></strong> <em>Backups increase memory usage since they are also kept in memory. So for every backup, you  double the original memory consumption.</em></p>
<p><img src="images/NoteSmall.jpg" alt="image"> <strong><em>NOTE:</em></strong> <em>A map can have both sync and aysnc backups at the same time.</em></p>
<h4 id="read-backup-data">Read Backup Data</h4>
<p>By default, Hazelcast will have one sync backup copy. If backup count is more than 1, then each member will carry both owned entries and backup copies of other member(s). So for the <code>map.get(key)</code> call, it is possible that calling member has backup copy of that key but by default, <code>map.get(key)</code> will always read the value from the actual owner of the key for consistency.
It is possible to enable backup reads (read local backup entries) by setting the value of <code>read-backup-data</code> property to <strong>true</strong>. Its default value is <strong>false</strong> for strong consistency. Enabling backup reads can improve the performance. </p>
<pre><code class="lang-xml">&lt;hazelcast&gt;
  &lt;map name=&quot;default&quot;&gt;
    &lt;backup-count&gt;0&lt;/backup-count&gt;
    &lt;async-backup-count&gt;1&lt;/async-backup-count&gt;
    &lt;read-backup-data&gt;true&lt;/read-backup-data&gt;
  &lt;/map&gt;
&lt;/hazelcast&gt;
</code></pre>
<p>This feature is available when there is at least 1 sync or async backup.</p>
<h3 id="eviction">Eviction</h3>
<p>Unless you delete the map entries manually or use an eviction policy, they will remain in the map. Hazelcast supports policy based eviction for distributed maps. Currently supported policies are LRU (Least Recently Used) and LFU (Least Frequently Used). There are also other properties as shown in the below sample declarative configuration. </p>
<pre><code class="lang-xml">&lt;hazelcast&gt;
  &lt;map name=&quot;default&quot;&gt;
    ...
    &lt;time-to-live-seconds&gt;0&lt;/time-to-live-seconds&gt;
    &lt;max-idle-seconds&gt;0&lt;/max-idle-seconds&gt;
    &lt;eviction-policy&gt;LRU&lt;/eviction-policy&gt;
    &lt;max-size policy=&quot;PER_NODE&quot;&gt;5000&lt;/max-size&gt;
    &lt;eviction-percentage&gt;25&lt;/eviction-percentage&gt;
    ...
  &lt;/map&gt;
&lt;/hazelcast&gt;
</code></pre>
<p>Let&#39;s describe each property. </p>
<ul>
<li><code>time-to-live</code>: Maximum time in seconds for each entry to stay in the map. If it is not 0, entries that are older than and not updated for this time are evicted automatically. Valid values are integers between 0 and <code>Integer.MAX VALUE</code>. Default value is 0 and it means infinite. Moreover, if it is not 0, entries are evicted regardless of the set <code>eviction-policy</code>.  </li>
<li><code>max-idle-seconds</code>: Maximum time in seconds for each entry to stay idle in the map. Entries that are idle for more than this time are evicted automatically. An entry is idle if no <code>get</code>, <code>put</code> or <code>containsKey</code> is called. Valid values are integers between 0 and <code>Integer.MAX VALUE</code>. Default value is 0 and it means infinite.</li>
<li><p><code>eviction-policy</code>: Valid values are described below.</p>
<ul>
<li>NONE: Default policy. If set, no items will be evicted and the property <code>max-size</code> will be ignored.  Of course, you still can combine it with <code>time-to-live-seconds</code> and <code>max-idle-seconds</code>.</li>
<li>LRU: Least Recently Used.</li>
<li>LFU: Least Frequently Used.    </li>
</ul>
</li>
<li><p><code>max-size</code>: Maximum size of the map. When maximum size is reached, map is evicted based on the policy defined. Valid values are integers between 0 and <code>Integer.MAX VALUE</code>. Default value is 0. If you want <code>max-size</code> to work, <code>eviction-policy</code> property must be set to a value other than NONE. Its attributes are described below.</p>
<ul>
<li><p><code>PER_NODE</code>: Maximum number of map entries in each JVM. This is the default policy.    </p>
<p> <code>&lt;max-size policy=&quot;PER_NODE&quot;&gt;5000&lt;/max-size&gt;</code></p>
</li>
<li><p><code>PER_PARTITION</code>: Maximum number of map entries within each partition. Storage size depends on the partition count in a JVM. So, this attribute may not be used often. If the cluster is small it will be hosting more partitions and therefore map entries, than that of a larger cluster.</p>
<p> <code>&lt;max-size policy=&quot;PER_PARTITION&quot;&gt;27100&lt;/max-size&gt;</code></p>
</li>
<li><p><code>USED_HEAP_SIZE</code>: Maximum used heap size in megabytes for each JVM.</p>
<p> <code>&lt;max-size policy=&quot;USED_HEAP_SIZE&quot;&gt;4096&lt;/max-size&gt;</code></p>
</li>
<li><p><code>USED_HEAP_PERCENTAGE</code>: Maximum used heap size percentage for each JVM. If, for example, JVM is configured to have 1000 MB and this value is 10, then the map entries will be evicted when used heap size exceeds 100 MB.</p>
<p> <code>&lt;max-size policy=&quot;USED_HEAP_PERCENTAGE&quot;&gt;10&lt;/max-size&gt;</code></p>
</li>
</ul>
</li>
<li><p><code>eviction-percentage</code>: When <code>max-size</code> is reached, specified percentage of the map will be evicted. If 25 is set for example, 25% of the entries will be evicted. Setting this property to a smaller value will cause eviction of small number of map entries. So, if map entries are inserted frequently, smaller percentage values may lead to overheads. Valid values are integers between 0 and 100. Default value is 25.</p>
</li>
</ul>
<h4 id="sample-eviction-configuration">Sample Eviction Configuration</h4>
<pre><code class="lang-xml">&lt;map name=&quot;documents&quot;&gt;
  &lt;max-size policy=&quot;PER_NODE&quot;&gt;10000&lt;/max-size&gt;
  &lt;eviction -policy&gt;LRU&lt;/eviction -policy&gt; 
  &lt;max-idle-seconds&gt;60&lt;/max-idle-seconds&gt;
&lt;/map&gt;
</code></pre>
<p>In the above sample, <code>documents</code> map starts to evict its entries from a member when the map size exceeds 10000 in that member. Then, the entries least recently used will be evicted. And, the entries not used for more than 60 seconds will be evicted as well.</p>
<h4 id="evicting-specific-entries">Evicting Specific Entries</h4>
<p>Above explained eviction policies and configurations apply to all the entries of a map. The entries that meet the specified eviction conditions are evicted.</p>
<p>But, you may particularly want to evict some specific map entries.  In this case, you can use the <code>ttl</code> and <code>timeunit</code> parameters of the method <code>map.put()</code>. A sample code line is given below.</p>
<p><code>myMap.put( &quot;1&quot;, &quot;John&quot;, 50, TimeUnit.SECONDS )</code></p>
<p>So, the map entry with the key &quot;1&quot; will be evicted in 50 seconds after it is put into <code>myMap</code>.</p>
<h4 id="evicting-all-entries">Evicting All Entries</h4>
<p>The method <code>evictAll()</code> is developed for evicting all keys from the map except the locked ones. If a MapStore is defined for the map, <code>deleteAll</code> is not called by <code>evictAll</code>. If you want to call the method <code>deleteAll</code>, use <code>clear()</code>. </p>
<p>A sample is given below.</p>
<pre><code class="lang-java">public class EvictAll {

    public static void main(String[] args) {
        final int numberOfKeysToLock = 4;
        final int numberOfEntriesToAdd = 1000;

        HazelcastInstance node1 = Hazelcast.newHazelcastInstance();
        HazelcastInstance node2 = Hazelcast.newHazelcastInstance();

        IMap&lt;Integer, Integer&gt; map = node1.getMap(EvictAll.class.getCanonicalName());
        for (int i = 0; i &lt; numberOfEntriesToAdd; i++) {
            map.put(i, i);
        }

        for (int i = 0; i &lt; numberOfKeysToLock; i++) {
            map.lock(i);
        }

        // should keep locked keys and evict all others.
        map.evictAll();

        System.out.printf(&quot;# After calling evictAll...\n&quot;);
        System.out.printf(&quot;# Expected map size\t: %d\n&quot;, numberOfKeysToLock);
        System.out.printf(&quot;# Actual map size\t: %d\n&quot;, map.size());

    }
}
</code></pre>
<p><img src="images/NoteSmall.jpg" alt="image"> <strong><em>NOTE:</em></strong> <em>Only EVICT_ALL event is fired for any registered listeners.</em></p>
<h3 id="in-memory-format">In Memory Format</h3>
<p>IMap has <code>in-memory-format</code> configuration option. By default, Hazelcast stores data into memory in binary (serialized) format. But sometimes, it can be efficient to store the entries in their object form, especially in cases of local processing like entry processor and queries. Setting <code>in-memory-format</code> in map&#39;s configuration, you can decide how the data will be stored in memory. There are below options.</p>
<ul>
<li><p><code>BINARY</code> (default): This is the default option. The data will be stored in serialized binary format. You can use this option if you mostly perform regular map operations like put and get.</p>
</li>
<li><p><code>OBJECT</code>: The data will be stored in deserialized form. This configuration is good for maps where entry processing and queries form the majority of all operations and the objects are complex ones, so serialization cost is respectively high. By storing objects, entry processing will not contain the deserialization cost.</p>
</li>
</ul>
<p>Regular operations like <code>get</code> rely on the object instance. When OBJECT format is used and, for example, when a <code>get</code> is performed, the map does not return the stored instance, but creates a clone. So, this whole <code>get</code> operation includes a serialization first (on the node owning the instance) and then deserialization (on the node calling the instance). But, when BINARY format is used, only a deserialization is required and this is faster.</p>
<p>Similarly, <code>put</code> operation is faster when BINARY format is used. If it was OBJECT, map would create a clone of the instance. So, there would first a serialization and then deserialization. Again, when BINARY is used, only a deserialization is needed.</p>
<p><img src="images/NoteSmall.jpg" alt="image"> <strong><em>NOTE:</em></strong> <em>If a value is stored in <code>OBJECT</code> format, a change on a returned value does not effect the stored instance. In this case, the returned instance is not the actual one but a clone. Therefore, changes made on an object after it is returned will not reflect on the actual stored data. Similarly, when a value is written to a map and the value is stored in <code>OBJECT</code> format, it will be a copy of the put value. So changes made on the object after it is stored, will not reflect on the actual stored data.</em></p>
<h3 id="map-persistence">Map Persistence</h3>
<p>Hazelcast allows you to load and store the distributed map entries from/to a persistent data store such as a relational database. For these, you can use Hazelcast&#39;s <code>MapStore</code> and <code>MapLoader</code> interfaces.</p>
<p>When you provide a <code>MapLoader</code> implementation and request an entry (<code>IMap.get()</code>) that does not exist in the memory, <code>MapLoader</code>&#39;s <code>load</code> or <code>loadAll</code> methods will load that entry from the data store. This loaded entry is placed into the map and will stay there until it is removed or evicted.</p>
<p>When a <code>MapStore</code> implementation is provided, an entry is put also into a user defined data store. </p>
<p><img src="images/NoteSmall.jpg" alt="image"> <strong><em>NOTE:</em></strong> <em>Data store needs to be a centralized system that is
accessible from all Hazelcast Nodes. Persisting to local file system is not supported.</em></p>
<p>Please see the below example.</p>
<pre><code class="lang-java">public class PersonMapStore implements MapStore&lt;Long, Person&gt; {
    private final Connection con;

    public PersonMapStore() {
        try {
            con = DriverManager.getConnection(&quot;jdbc:hsqldb:mydatabase&quot;, &quot;SA&quot;, &quot;&quot;);
            con.createStatement().executeUpdate(
                    &quot;create table if not exists person (id bigint, name varchar(45))&quot;);
        } catch (SQLException e) {
            throw new RuntimeException(e);
        }
    }

    public synchronized void delete(Long key) {
        System.out.println(&quot;Delete:&quot; + key);
        try {
            con.createStatement().executeUpdate(
                    format(&quot;delete from person where id = %s&quot;, key));
        } catch (SQLException e) {
            throw new RuntimeException(e);
        }
    }

    public synchronized void store(Long key, Person value) {
        try {
            con.createStatement().executeUpdate(
                    format(&quot;insert into person values(%s,&#39;%s&#39;)&quot;, key, value.name));
        } catch (SQLException e) {
            throw new RuntimeException(e);
        }
    }

    public synchronized void storeAll(Map&lt;Long, Person&gt; map) {
        for (Map.Entry&lt;Long, Person&gt; entry : map.entrySet())
            store(entry.getKey(), entry.getValue());
    }

    public synchronized void deleteAll(Collection&lt;Long&gt; keys) {
        for (Long key : keys) delete(key);
    }

    public synchronized Person load(Long key) {
        try {
            ResultSet resultSet = con.createStatement().executeQuery(
                    format(&quot;select name from person where id =%s&quot;, key));
            try {
                if (!resultSet.next()) return null;
                String name = resultSet.getString(1);
                return new Person(name);
            } finally {
                resultSet.close();
            }
        } catch (SQLException e) {
            throw new RuntimeException(e);
        }
    }

    public synchronized Map&lt;Long, Person&gt; loadAll(Collection&lt;Long&gt; keys) {
        Map&lt;Long, Person&gt; result = new HashMap&lt;Long, Person&gt;();
        for (Long key : keys) result.put(key, load(key));
        return result;
    }

    public Set&lt;Long&gt; loadAllKeys() {
        return null;
    }
}
</code></pre>
<p><img src="images/NoteSmall.jpg" alt="image"> <strong><em>NOTE:</em></strong> <em>Loading process is performed on a thread different than the partition threads using ExecutorService.</em></p>
<p><br></br>
<strong><em>RELATED INFORMATION</em></strong></p>
<p><em>For more MapStore/MapLoader code samples please see <a href="https://github.com/hazelcast/hazelcast-code-samples/tree/master/distributed-map/mapstore/src/main/java">here</a>.</em>
<br></br></p>
<p>Hazelcast supports read-through, write-through and write-behind persistence modes which are explained in below subsections.</p>
<h4 id="read-through">Read-Through</h4>
<p>If an entry does not exist in the memory when an application asks, Hazelcast asks your loader implementation to load that entry from the data store.  If the entry exists there, the loader implementation gets it, hands it to Hazelcast, and Hazelcast puts it into the memory. This is read-through persistence mode.</p>
<h4 id="write-through">Write-Through</h4>
<p><code>MapStore</code> can be configured as write-through by setting the <code>write-delay-seconds</code> property to <strong>0</strong>. This means the entries will be put to the data store synchronously.</p>
<p>In this mode, when the <code>map.put(key,value)</code> call returns, you can be sure that</p>
<ul>
<li><p><code>MapStore.store(key,value)</code> is successfully called so the entry is persisted.</p>
</li>
<li><p>In-Memory entry is updated</p>
</li>
<li><p>In-Memory backup copies are successfully created on other JVMs (if <code>backup-count</code> is greater than 0)</p>
</li>
</ul>
<p>Same behavior goes for the <code>map.remove(key)</code>, only difference is that  <code>MapStore.delete(key)</code> is called when it will be deleted.</p>
<p>If <code>MapStore</code> throws an exception, then the exception will be propagated back to the original <code>put</code> or <code>remove</code> call in the form of <code>RuntimeException</code>. </p>
<h4 id="write-behind">Write-Behind</h4>
<p><code>MapStore</code> can be configured as write-behind by setting the <code>write-delay-seconds</code> property to a value bigger than <strong>0</strong>. This means the modified entries will be put to the data store asynchronously after a configured delay. </p>
<p><img src="images/NoteSmall.jpg" alt="image"> <strong><em>NOTE:</em></strong> <em>In write-behind mode, Hazelcast coalesces updates on a specific key, i.e. applies only the last update on it.</em> </p>
<p>In this mode, when the <code>map.put(key,value)</code> call returns, you can be sure that</p>
<ul>
<li><p>In-Memory entry is updated</p>
</li>
<li><p>In-Memory backup copies are successfully created on other JVMs (if <code>backup-count</code> is greater than 0)</p>
</li>
<li><p>The entry is marked as dirty so that after <code>write-delay-seconds</code>, it can be persisted with <code>MapStore.store(key,value)</code> call.</p>
</li>
</ul>
<p>Same behavior goes for the <code>map.remove(key)</code>, only difference is that  <code>MapStore.delete(key)</code> is called when it will be deleted.</p>
<p>If <code>MapStore</code> throws an exception, then Hazelcast retries to store the entry. If it still cannot be stored, a log message is printed and the entry is re-queued. </p>
<p>For batch write operations, which are only allowed in write-behind mode, Hazelcast will call <code>MapStore.storeAll(map)</code>, and <code>MapStore.deleteAll(collection)</code> to do all writes in a single call.
<br></br></p>
<p><img src="images/NoteSmall.jpg" alt="image"> <strong><em>NOTE:</em></strong> <em>If a map entry is marked as dirty, i.e. it is waiting to be persisted to the <code>MapStore</code> in a write-behind scenario, the eviction process forces the entry to be stored. By this way, you will have control on the number of entries waiting to be stored, so that a possible OutOfMemory exception can be prevented.</em>
<br></br></p>
<p><img src="images/NoteSmall.jpg" alt="image"> <strong><em>NOTE:</em></strong> <em>MapStore or MapLoader implementations should not use Hazelcast Map/Queue/MultiMap/List/Set operations. Your implementation should only work with your data store. Otherwise, you may get into deadlock situations.</em></p>
<p>Here is a sample configuration:</p>
<pre><code class="lang-xml">&lt;hazelcast&gt;
  ...
  &lt;map name=&quot;default&quot;&gt;
    ...
    &lt;map-store enabled=&quot;true&quot;&gt;
      &lt;!--
        Name of the class implementing MapLoader and/or MapStore.
        The class should implement at least of these interfaces and
        contain no-argument constructor. Note that the inner classes are not supported.
      --&gt;
      &lt;class-name&gt;com.hazelcast.examples.DummyStore&lt;/class-name&gt;
      &lt;!--
        Number of seconds to delay to call the MapStore.store(key, value).
        If the value is zero then it is write-through so MapStore.store(key, value)
        will be called as soon as the entry is updated.
        Otherwise it is write-behind so updates will be stored after write-delay-seconds
        value by calling Hazelcast.storeAll(map). Default value is 0.
      --&gt;
      &lt;write-delay-seconds&gt;60&lt;/write-delay-seconds&gt;
      &lt;!--
        Used to create batch chunks when writing map store.
        In default mode all entries will be tried to persist in one go.
        To create batch chunks, minimum meaningful value for write-batch-size
        is 2. For values smaller than 2, it works as in default mode.
      --&gt;
      &lt;write-batch-size&gt;1000&lt;/write-batch-size&gt;
    &lt;/map-store&gt;
  &lt;/map&gt;
&lt;/hazelcast&gt;
</code></pre>
<h4 id="mapstorefactory-and-maploaderlifecyclesupport-interfaces">MapStoreFactory and MapLoaderLifecycleSupport Interfaces</h4>
<p>As you know, a configuration can be applied to more than one map using wildcards (Please see <a href="#using-wildcard">Using Wildcard</a>), meaning the configuration is shared among the maps. But, <code>MapStore</code> does not know which entries to be stored when there is one configuration applied to multiple maps. To overcome this, Hazelcast provides <code>MapStoreFactory</code> interface.</p>
<p>Using this factory, <code>MapStore</code>s for each map can be created, when a wildcard configuration is used. A sample code is given below.</p>
<pre><code class="lang-java">Config config = new Config();
MapConfig mapConfig = config.getMapConfig( &quot;*&quot; );
MapStoreConfig mapStoreConfig = mapConfig.getMapStoreConfig();
mapStoreConfig.setFactoryImplementation( new MapStoreFactory&lt;Object, Object&gt;() {
  @Override
  public MapLoader&lt;Object, Object&gt; newMapStore( String mapName, Properties properties ) {
    return null;
  }
});
</code></pre>
<p>Moreover, if the configuration implements <code>MapLoaderLifecycleSupport</code> interface, then the user will have the control to initialize the <code>MapLoader</code> implementation with the given map name, configuration properties and the Hazelcast instance. See the below code portion.</p>
<pre><code class="lang-java">public interface MapLoaderLifecycleSupport {

  /**
   * Initializes this MapLoader implementation. Hazelcast will call
   * this method when the map is first used on the
   * HazelcastInstance. Implementation can
   * initialize required resources for the implementing
   * mapLoader such as reading a config file and/or creating
   * database connection.
   */
  void init( HazelcastInstance hazelcastInstance, Properties properties, String mapName );

  /**
   * Hazelcast will call this method before shutting down.
   * This method can be overridden to cleanup the resources
   * held by this map loader implementation, such as closing the
   * database connections etc.
   */
  void destroy();
}
</code></pre>
<h4 id="initialization-on-startup">Initialization on startup</h4>
<p><code>MapLoader.loadAllKeys</code> API is used for pre-populating the in-memory map when the map is first touched/used. If <code>MapLoader.loadAllKeys</code> returns NULL then nothing will be loaded. Your <code>MapLoader.loadAllKeys</code> implementation can return all or some of the keys. You may select and return only the <code>hot</code> keys, for instance. Also note that this is the fastest way of pre-populating the map as Hazelcast will optimize the loading process by having each node loading owned portion of the entries.</p>
<p>Moreover, there is InitialLoadMode configuration parameter in the class <a href="https://github.com/hazelcast/hazelcast/blob/5f4f6a876e572f91431ad22f01ad5af9f5837f72/hazelcast/src/main/java/com/hazelcast/config/MapStoreConfig.java"><code>MapStoreConfig</code></a> class. This parameter has two values: LAZY and EAGER. If InitialLoadMode is set as LAZY, data is not loaded during the map creation. If it is set as EAGER, whole data is loaded while the map is being created and everything becomes ready to use. Also, if you add indices to your map by <a href="https://github.com/hazelcast/hazelcast/blob/da5cceee74e471e33f65f43f31d891c9741e31e3/hazelcast/src/main/java/com/hazelcast/config/MapIndexConfig.java"><code>MapIndexConfig</code></a> class or <a href="#indexing"><code>addIndex</code></a> method, then InitialLoadMode is overridden and MapStoreConfig behaves as if EAGER mode is on.</p>
<p>Here is MapLoader initialization flow:</p>
<ol>
<li>When <code>getMap()</code> is first called from any node, initialization will start depending on the the value of InitialLoadMode. If it is set as EAGER, initialization starts.  If it is set as LAZY, initialization actually does not start but data is loaded at each time a partition loading is completed.</li>
<li>Hazelcast will call <code>MapLoader.loadAllKeys()</code> to get all your keys on each node</li>
<li>Each node will figure out the list of keys it owns</li>
<li>Each node will load all its owned keys by calling <code>MapLoader.loadAll(keys)</code></li>
<li>Each node puts its owned entries into the map by calling <code>IMap.putTransient(key,value)</code></li>
</ol>
<p><img src="images/NoteSmall.jpg" alt="image"> <strong><em>NOTE:</em></strong> <em>If the load mode is LAZY and when <code>clear()</code> method is called (which triggers <code>MapStore.deleteAll()</code>), Hazelcast will remove <strong>ONLY</strong> the loaded entries from your map and datastore. Since the whole data is not loaded for this case (LAZY mode), please note that there may be still entries in your datastore.</em></p>
<h4 id="forcing-all-keys-to-be-loaded">Forcing All Keys To Be Loaded</h4>
<p>The method <code>loadAll</code> is developed to load some or all keys into a data store in order to optimize the multiple load operations. The method has two signatures (i.e. same method can take two different parameter lists). One loads the given keys and the other loads all keys. Please see the sample code below.</p>
<pre><code class="lang-java">public class LoadAll {

    public static void main(String[] args) {
        final int numberOfEntriesToAdd = 1000;
        final String mapName = LoadAll.class.getCanonicalName();
        final Config config = createNewConfig(mapName);
        final HazelcastInstance node = Hazelcast.newHazelcastInstance(config);
        final IMap&lt;Integer, Integer&gt; map = node.getMap(mapName);

        populateMap(map, numberOfEntriesToAdd);
        System.out.printf(&quot;# Map store has %d elements\n&quot;, numberOfEntriesToAdd);

        map.evictAll();
        System.out.printf(&quot;# After evictAll map size\t: %d\n&quot;, map.size());

        map.loadAll(true);
        System.out.printf(&quot;# After loadAll map size\t: %d\n&quot;, map.size());
    }
}
</code></pre>
<h4 id="post-processing-map-store">Post Processing Map Store</h4>
<p>In some scenarios, you may need to modify the object after storing it into the map store.
For example, you can get ID or version auto generated by your database and you need to modify your object stored in distributed map, not to break the sync between database and data grid. You can do that by implementing <code>PostProcessingMapStore</code> interface;
so the modified object will be put to the distributed map. That will cause an extra step of <code>Serialization</code>, so use it just when needed (This explanation is only valid when using <code>write-through</code> map store configuration).</p>
<p>Here is an example of post processing map store:</p>
<pre><code class="lang-java">class ProcessingStore extends MapStore&lt;Integer, Employee&gt; implements PostProcessingMapStore {
  @Override
  public void store( Integer key, Employee employee ) {
    EmployeeId id = saveEmployee();
    employee.setId( id.getId() );
  }
}
</code></pre>
<h3 id="near-cache">Near Cache</h3>
<p>Map entries in Hazelcast are partitioned across the cluster. Imagine that you are reading key <code>k</code> so many times and <code>k</code> is owned by another member in your cluster. Each <code>map.get(k)</code> will be a remote operation, meaning lots of network trips. If you have a map that is read-mostly, then you should consider creating a Near Cache for the map so that reads can be much faster and consume less network traffic. All these benefits do not come free. When using near cache, you should consider the following issues:</p>
<ul>
<li><p>JVM will have to hold extra cached data so it will increase the memory consumption.</p>
</li>
<li><p>If invalidation is turned on and entries are updated frequently, then invalidations will be costly.</p>
</li>
<li><p>Near cache breaks the strong consistency guarantees; you might be reading stale data.</p>
</li>
</ul>
<p>Near cache is highly recommended for the maps that are read-mostly. Here is a near cache configuration for a map:</p>
<pre><code class="lang-xml">&lt;hazelcast&gt;
  ...
  &lt;map name=&quot;my-read-mostly-map&quot;&gt;
    ...
    &lt;near-cache&gt;
      &lt;!--
        Maximum size of the near cache. When max size is reached,
        cache is evicted based on the policy defined.
        Any integer between 0 and Integer.MAX_VALUE. 0 means
        Integer.MAX_VALUE. Default is 0.
      --&gt;
      &lt;max-size&gt;5000&lt;/max-size&gt;

      &lt;!--
        Maximum number of seconds for each entry to stay in the near cache. Entries that are
        older than &lt;time-to-live-seconds&gt; will get automatically evicted from the near cache.
        Any integer between 0 and Integer.MAX_VALUE. 0 means infinite. Default is 0.
      --&gt;
      &lt;time-to-live-seconds&gt;0&lt;/time-to-live-seconds&gt;

      &lt;!--
        Maximum number of seconds each entry can stay in the near cache as untouched (not-read).
        Entries that are not read (touched) more than &lt;max-idle-seconds&gt; value will get removed
        from the near cache.
        Any integer between 0 and Integer.MAX_VALUE. 0 means
        Integer.MAX_VALUE. Default is 0.
      --&gt;
      &lt;max-idle-seconds&gt;60&lt;/max-idle-seconds&gt;

      &lt;!--
        Valid values are:
        NONE (no extra eviction, &lt;time-to-live-seconds&gt; may still apply),
        LRU  (Least Recently Used),
        LFU  (Least Frequently Used).
        NONE is the default.
        Regardless of the eviction policy used, &lt;time-to-live-seconds&gt; will still apply.
      --&gt;
      &lt;eviction-policy&gt;LRU&lt;/eviction-policy&gt;

      &lt;!--
        Should the cached entries get evicted if the entries are changed (updated or removed).
        true of false. Default is true.
      --&gt;
      &lt;invalidate-on-change&gt;true&lt;/invalidate-on-change&gt;

      &lt;!--
        You may want also local entries to be cached.
        This is useful when in memory format for near cache is different than the map&#39;s one.
        By default it is disabled.
      --&gt;
      &lt;cache-local-entries&gt;false&lt;/cache-local-entries&gt;
    &lt;/near-cache&gt;
  &lt;/map&gt;
&lt;/hazelcast&gt;
</code></pre>
<p><img src="images/NoteSmall.jpg" alt="image"> <strong><em>NOTE:</em></strong> <em>Programmatically, near cache configuration is done by using the class <a href="https://github.com/hazelcast/hazelcast/blob/607aa5484958af706ee18a1eb15d89afd12ee7af/hazelcast/src/main/java/com/hazelcast/config/NearCacheConfig.java">NearCacheConfig</a>. And this class is used both in nodes and clients. To create a near cache in a client (native Java client), use the method <code>addNearCacheConfig</code> in the class <code>ClientConfig</code> (please see <a href="#java-client">Java Client</a> section). Please note that near cache configuration is specific to the node or client itself, a map in a node may not have near cache configured while the same map in a client may have.</em></p>
<h3 id="map-locks">Map Locks</h3>
<p>Hazelcast Distributed Map (IMap) is thread-safe and meets your thread safety requirements. When these requirements increase or you want to have more control on the concurrency, below features and solutions provided by Hazelcast can be considered.</p>
<p>Let&#39;s work on a sample case as shown below.</p>
<pre><code class="lang-java">public class RacyUpdateMember {
    public static void main( String[] args ) throws Exception {
        HazelcastInstance hz = Hazelcast.newHazelcastInstance();
        IMap&lt;String, Value&gt; map = hz.getMap( &quot;map&quot; );
        String key = &quot;1&quot;;
        map.put( key, new Value() );
        System.out.println( &quot;Starting&quot; );
        for ( int k = 0; k &lt; 1000; k++ ) {
            if ( k % 100 == 0 ) System.out.println( &quot;At: &quot; + k );
            Value value = map.get( key );
            Thread.sleep( 10 );
            value.amount++;
            map.put( key, value );
        }
        System.out.println( &quot;Finished! Result = &quot; + map.get(key).amount );
    }

    static class Value implements Serializable {
        public int amount;
    }
}
</code></pre>
<p>If the above code is run by more than one cluster members simultaneously, there will be likely a race condition.</p>
<h4 id="pessimistic-locking">Pessimistic Locking</h4>
<p>One usual way to solve this race issue is using the lock mechanism provided by Hazelcast distributed map, i.e. <code>map.lock</code> and <code>map.unlock</code> methods. You simply lock the entry until you finished with it. See the below sample code.</p>
<pre><code class="lang-java">public class PessimisticUpdateMember {
    public static void main( String[] args ) throws Exception {
        HazelcastInstance hz = Hazelcast.newHazelcastInstance();
        IMap&lt;String, Value&gt; map = hz.getMap( &quot;map&quot; );
        String key = &quot;1&quot;;
        map.put( key, new Value() );
        System.out.println( &quot;Starting&quot; );
        for ( int k = 0; k &lt; 1000; k++ ) {
            map.lock( key );
            try {
                Value value = map.get( key );
                Thread.sleep( 10 );
                value.amount++;
                map.put( key, value );
            } finally {
                map.unlock( key );
            }
        }
        System.out.println( &quot;Finished! Result = &quot; + map.get( key ).amount );
    }

    static class Value implements Serializable {
        public int amount;
    }
}
</code></pre>
<p>The IMap lock will automatically be collected by the garbage collector when the map entry is removed.</p>
<p>The IMap lock is reentrant, but it does not support fairness.</p>
<p>Another way can be acquiring a predictable <code>Lock</code> object from Hazelcast. By this way, every value in the map can be given a lock or you can create a stripe of locks.</p>
<h4 id="optimistic-locking">Optimistic Locking</h4>
<p>Hazelcast way of optimistic locking is to use <code>map.replace</code> method. See the below sample code. </p>
<pre><code class="lang-java">public class OptimisticMember {
    public static void main( String[] args ) throws Exception {
        HazelcastInstance hz = Hazelcast.newHazelcastInstance();
        IMap&lt;String, Value&gt; map = hz.getMap( &quot;map&quot; );
        String key = &quot;1&quot;;
        map.put( key, new Value() );
        System.out.println( &quot;Starting&quot; );
        for ( int k = 0; k &lt; 1000; k++ ) {
            if ( k % 10 == 0 ) System.out.println( &quot;At: &quot; + k );
            for (; ; ) {
                Value oldValue = map.get( key );
                Value newValue = new Value( oldValue );
                Thread.sleep( 10 );
                newValue.amount++;
                if ( map.replace( key, oldValue, newValue ) )
                    break;
            }
        }
        System.out.println( &quot;Finished! Result = &quot; + map.get( key ).amount );
    }

    static class Value implements Serializable {
        public int amount;

        public Value() {
        }

        public Value( Value that ) {
            this.amount = that.amount;
        }

        public boolean equals( Object o ) {
            if ( o == this ) return true;
            if ( !( o instanceof Value ) ) return false;
            Value that = ( Value ) o;
            return that.amount == this.amount;
        }
    }
}
</code></pre>
<p><img src="images/NoteSmall.jpg" alt="image"> <strong><em>NOTE:</em></strong> <em>Above sample code is intentionally broken.</em></p>
<h4 id="pessimistic-vs-optimistic-locking">Pessimistic vs. Optimistic Locking</h4>
<p>Depending on the locking requirements, one locking strategy can be picked.</p>
<p>Optimistic locking is better for mostly read only systems and it brings a performance boost over pessimistic locking.</p>
<p>Pessimistic locking is good if there are lots of updates on the same key and it is more robust than optimistic one from the perspective of data consistency.
In Hazelcast, use <code>IExecutorService</code> for submitting a task to a key owner or to a member, or members. This is the recommended way of task executions which uses pessimistic or optimistic locking techniques. By following this manner, there will be less network hops and less data over wire and also tasks will be executed very near to data. Please refer to <a href="#data-affinity">Data Affinity</a>.</p>
<h4 id="aba-problem">ABA Problem</h4>
<p>ABA problem occurs in environments when a shared resource is open to change by multiple threads. So, even one thread sees the same value for a particular key in consecutive reads, it does not mean nothing has changed between the reads. Because one another thread may come and change the value, do another work and change the value back, but the first thread can think that nothing has changed.</p>
<p>To prevent these kind of problems, one possible solution is to use a version number and to check it before any write to be sure that nothing has changed between consecutive reads. Although all the other fields will be equal, the version field will prevent objects from being seen as equal. This is called the optimistic locking strategy and it is used in environments which do not expect intensive concurrent changes on a specific key.</p>
<p>In Hazelcast, you can apply optimistic locking strategy by using <code>replace</code> method of map. This method compares values in object or data forms depending on the in memory format configuration. If the values are equal, it replaces the old value with the new one. If you want to use your defined <code>equals</code> method, in memory format should be <code>Object</code>. Otherwise, Hazelcast serializes objects to binary forms and compares them.  </p>
<h3 id="entry-statistics">Entry Statistics</h3>
<p>Hazelcast keeps extra information about each map entry such as creation time, last update time, last access time, number of hits, version, and this information is exposed to the developer via <code>IMap.getEntryView(key)</code> call. Here is an example:</p>
<pre><code class="lang-java">import com.hazelcast.core.Hazelcast;
import com.hazelcast.core.EntryView;

HazelcastInstance hz = Hazelcast.newHazelcastInstance();
EntryView entry = hz.getMap( &quot;quotes&quot; ).getEntryView( &quot;1&quot; );
System.out.println ( &quot;size in memory  : &quot; + entry.getCost() );
System.out.println ( &quot;creationTime    : &quot; + entry.getCreationTime() );
System.out.println ( &quot;expirationTime  : &quot; + entry.getExpirationTime() );
System.out.println ( &quot;number of hits  : &quot; + entry.getHits() );
System.out.println ( &quot;lastAccessedTime: &quot; + entry.getLastAccessTime() );
System.out.println ( &quot;lastUpdateTime  : &quot; + entry.getLastUpdateTime() );
System.out.println ( &quot;version         : &quot; + entry.getVersion() );
System.out.println ( &quot;key             : &quot; + entry.getKey() );
System.out.println ( &quot;value           : &quot; + entry.getValue() );
</code></pre>
<h3 id="entry-listener">Entry Listener</h3>
<p>Map entry events can be listened. Hazelcast distributed map offers the method <code>addEntryListener</code> to add an entry listener to the map and listen to the entry events. </p>
<p>Let&#39;s take a look at the below sample code.</p>
<pre><code class="lang-java">public class Listen {

  public static void main( String[] args ) {
    HazelcastInstance hz = Hazelcast.newHazelcastInstance();
    IMap&lt;String, String&gt; map = hz.getMap( &quot;somemap&quot; );
    map.addEntryListener( new MyEntryListener(), true );
     System.out.println( &quot;EntryListener registered&quot; );
  }

  static class MyEntryListener implements EntryListener&lt;String, String&gt; {
    @Override
    public void entryAdded( EntryEvent&lt;String, String&gt; event ) {
      System.out.println( &quot;Entry Added:&quot; + event );
    }

    @Override
    public void entryRemoved( EntryEvent&lt;String, String&gt; event ) {
      System.out.println( &quot;Entry Removed:&quot; + event );
    }

    @Override
    public void entryUpdated( EntryEvent&lt;String, String&gt; event ) {
      System.out.println( &quot;Entry Updated:&quot; + event );
    }

    @Override
    public void entryEvicted( EntryEvent&lt;String, String&gt; event ) {
      System.out.println( &quot;Entry Evicted:&quot; + event );
    }

    @Override
    public void mapEvicted( MapEvent event ) {
      System.out.println( &quot;Map Evicted:&quot; + event );
    }

    @Override
    public void mapCleared( MapEvent event ) {
      System.out.println( &quot;Map Cleared:&quot; + event );
    }

  }
}
</code></pre>
<p>And, now let&#39;s perform some modifications on the map entries using the below sample code.</p>
<pre><code class="lang-java">public class Modify {

  public static void main( String[] args ) {
    HazelcastInstance hz = Hazelcast.newHazelcastInstance();
    IMap&lt;String, String&gt; map = hz.getMap( &quot;somemap&quot;);
    String key = &quot;&quot; + System.nanoTime();
    String value = &quot;1&quot;;
    map.put( key, value );
    map.put( key, &quot;2&quot; );
    map.delete( key );
  }
}
</code></pre>
<p>Now, let&#39;s first execute the class <code>Listen</code> and then execute <code>Modify</code>. Check out the below output produced by <code>Listen</code>. </p>
<pre><code>entryAdded:EntryEvent {Address[192.168.1.100]:5702} key=251359212222282,
    oldValue=null, value=1, event=ADDED, by Member [192.168.1.100]:5702

entryUpdated:EntryEvent {Address[192.168.1.100]:5702} key=251359212222282,
    oldValue=1, value=2, event=UPDATED, by Member [192.168.1.100]:5702

entryRemoved:EntryEvent {Address[192.168.1.100]:5702} key=251359212222282,
    oldValue=2, value=2, event=REMOVED, by Member [192.168.1.100]:5702
</code></pre><p>Entry Listener runs on event threads which are also used by other listeners (e.g. collection listeners, pub/sub message listeners, etc.). This means entry listeners can access to other partitions. So, consideration should be given when running long tasks since listening to those tasks may cause other event listeners to starve.</p>
<h3 id="interceptors">Interceptors</h3>
<p>You can add intercept operations and then execute your own business logic synchronously blocking the operations. You can change the returned value from a <code>get</code> operation, change the value to be <code>put</code> or <code>cancel</code> operations by throwing an exception.</p>
<p>Interceptors are different from listeners. With listeners, you take an action after the operation has been completed. Interceptor actions are synchronous and you can alter the behavior of operation, change the values, or totally cancel it.</p>
<p>Map interceptors are chained, so adding the same interceptor multiple times to the same map can result in duplicate effects. This can easily happen when the interceptor is added to the map at node initialization, so that each node adds the same interceptor. When adding the interceptor in this way, be sure that the <code>hashCode()</code> method is implemented to return the same value for every instance of the interceptor. It is not strictly necessary, but it is a good idea to also implement <code>equals()</code> as this will ensure that the map interceptor can be removed reliably.</p>
<p>IMap API has two methods for adding and removing an interceptor to the map,<code>addInterceptor</code> and <code>removeInterceptor</code>:</p>
<pre><code class="lang-java">/**
 * Adds an interceptor for this map. Added interceptor will intercept operations
 * and execute user defined methods and will cancel operations if user defined method throw exception.
 * 
 *
 * @param interceptor map interceptor
 * @return id of registered interceptor
 */
String addInterceptor( MapInterceptor interceptor );

/**
 * Removes the given interceptor for this map. So it will not intercept operations anymore.
 * 
 *
 * @param id registration id of map interceptor
 */
void removeInterceptor( String id );
</code></pre>
<p>Here is the <code>MapInterceptor</code> interface:</p>
<pre><code class="lang-java">public interface MapInterceptor extends Serializable {

  /**
   * Intercept the get operation before it returns a value.
   * Return another object to change the return value of get(..)
   * Returning null will cause the get(..) operation to return the original value,
   * namely return null if you do not want to change anything.
   * 
   *
   * @param value the original value to be returned as the result of get(..) operation
   * @return the new value that will be returned by get(..) operation
   */
  Object interceptGet( Object value );

  /**
   * Called after get(..) operation is completed.
   * 
   *
   * @param value the value returned as the result of get(..) operation
   */
  void afterGet( Object value );

  /**
   * Intercept put operation before modifying map data.
   * Return the object to be put into the map.
   * Returning null will cause the put(..) operation to operate as expected,
   * namely no interception. Throwing an exception will cancel the put operation.
   * 
   *
   * @param oldValue the value currently in map
   * @param newValue the new value to be put
   * @return new value after intercept operation
   */
  Object interceptPut( Object oldValue, Object newValue );

  /**
   * Called after put(..) operation is completed.
   * 
   *
   * @param value the value returned as the result of put(..) operation
   */
  void afterPut( Object value );

  /**
   * Intercept remove operation before removing the data.
   * Return the object to be returned as the result of remove operation.
   * Throwing an exception will cancel the remove operation.
   * 
   *
   * @param removedValue the existing value to be removed
   * @return the value to be returned as the result of remove operation
   */
  Object interceptRemove( Object removedValue );

  /**
   * Called after remove(..) operation is completed.
   * 
   *
   * @param value the value returned as the result of remove(..) operation
   */
  void afterRemove( Object value );
}
</code></pre>
<p><strong>Example Usage:</strong></p>
<pre><code class="lang-java">public class InterceptorTest {

  @Test
  public void testMapInterceptor() throws InterruptedException {
    HazelcastInstance hazelcastInstance1 = Hazelcast.newHazelcastInstance();
    HazelcastInstance hazelcastInstance2 = Hazelcast.newHazelcastInstance();
    IMap&lt;Object, Object&gt; map = hazelcastInstance1.getMap( &quot;testMapInterceptor&quot; );
    SimpleInterceptor interceptor = new SimpleInterceptor();
    map.addInterceptor( interceptor );
    map.put( 1, &quot;New York&quot; );
    map.put( 2, &quot;Istanbul&quot; );
    map.put( 3, &quot;Tokyo&quot; );
    map.put( 4, &quot;London&quot; );
    map.put( 5, &quot;Paris&quot; );
    map.put( 6, &quot;Cairo&quot; );
    map.put( 7, &quot;Hong Kong&quot; );

    try {
      map.remove( 1 );
    } catch ( Exception ignore ) {
    }
    try {
      map.remove( 2 );
    } catch ( Exception ignore ) {
    }

    assertEquals( map.size(), 6) ;

    assertEquals( map.get( 1 ), null );
    assertEquals( map.get( 2 ), &quot;ISTANBUL:&quot; );
    assertEquals( map.get( 3 ), &quot;TOKYO:&quot; );
    assertEquals( map.get( 4 ), &quot;LONDON:&quot; );
    assertEquals( map.get( 5 ), &quot;PARIS:&quot; );
    assertEquals( map.get( 6 ), &quot;CAIRO:&quot; );
    assertEquals( map.get( 7 ), &quot;HONG KONG:&quot; );

    map.removeInterceptor( interceptor );
    map.put( 8, &quot;Moscow&quot; );

    assertEquals( map.get( 8 ), &quot;Moscow&quot; );
    assertEquals( map.get( 1 ), null );
    assertEquals( map.get( 2 ), &quot;ISTANBUL&quot; );
    assertEquals( map.get( 3 ), &quot;TOKYO&quot; );
    assertEquals( map.get( 4 ), &quot;LONDON&quot; );
    assertEquals( map.get( 5 ), &quot;PARIS&quot; );
    assertEquals( map.get( 6 ), &quot;CAIRO&quot; );
    assertEquals( map.get( 7 ), &quot;HONG KONG&quot; );
  }

  static class SimpleInterceptor implements MapInterceptor, Serializable {

    @Override
    public Object interceptGet( Object value ) {
      if (value == null)
        return null;
      return value + &quot;:&quot;;
    }

    @Override
    public void afterGet( Object value ) {
    }

    @Override
    public Object interceptPut( Object oldValue, Object newValue ) {
      return newValue.toString().toUpperCase();
    }

    @Override
    public void afterPut( Object value ) {
    }

    @Override
    public Object interceptRemove( Object removedValue ) {
      if(removedValue.equals( &quot;ISTANBUL&quot; ))
        throw new RuntimeException( &quot;you can not remove this&quot; );
      return removedValue;
    }

    @Override
    public void afterRemove( Object value ) {
      // do something
    }
  }
}
</code></pre>
<h2 id="queue">Queue</h2>
<h3 id="queue-overview">Queue Overview</h3>
<p>Hazelcast distributed queue is an implementation of <code>java.util.concurrent.BlockingQueue</code>. Being distributed, it enables all cluster members to interact with it. Meaning that, you can add an item in one machine and remove it from another one.</p>
<pre><code class="lang-java">import com.hazelcast.core.Hazelcast;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.TimeUnit;

HazelcastInstance hazelcastInstance = Hazelcast.newHazelcastInstance();
BlockingQueue&lt;MyTask&gt; queue = hazelcastInstance.getQueue( &quot;tasks&quot; );
queue.put( new MyTask() );
MyTask task = queue.take();

boolean offered = queue.offer( new MyTask(), 10, TimeUnit.SECONDS );
task = queue.poll( 5, TimeUnit.SECONDS );
if ( task != null ) {
  //process task
}
</code></pre>
<p>FIFO ordering will apply to all queue operations cluster wide. User objects (such as <code>MyTask</code> in the example above), that are (en/de)queued have to be <code>Serializable</code>.</p>
<p>There is no batching while iterating over Queue. All items will be copied to local and iteration will occur locally.</p>
<h3 id="sample-queue-code">Sample Queue Code</h3>
<p>Below sample codes illustrate a producer and consumer connected by a distributed queue.</p>
<p>Let&#39;s put one integer at each second on a queue, 100 integers in total.</p>
<pre><code class="lang-java">import com.hazelcast.core.Hazelcast;
import com.hazelcast.core.HazelcastInstance;
import com.hazelcast.core.IQueue;

public class ProducerMember {
  public static void main( String[] args ) throws Exception {
    HazelcastInstance hz = Hazelcast.newHazelcastInstance();
    IQueue&lt;Integer&gt; queue = hz.getQueue( &quot;queue&quot; );
    for ( int k = 1; k &lt; 100; k++ ) {
      queue.put( k );
      System.out.println( &quot;Producing: &quot; + k );
      Thread.sleep(1000);
    }
    queue.put( -1 );
    System.out.println( &quot;Producer Finished!&quot; );
  }
}
</code></pre>
<p><code>Producer</code> puts a <strong>-1</strong> on the queue to show that <code>put</code>&#39;s are finished. Now, let&#39;s create a <code>Consumer</code> class that take a message from this queue, as shown below.</p>
<pre><code class="lang-java">import com.hazelcast.core.Hazelcast;
import com.hazelcast.core.HazelcastInstance;
import com.hazelcast.core.IQueue;

public class ConsumerMember {
  public static void main( String[] args ) throws Exception {
    HazelcastInstance hz = Hazelcast.newHazelcastInstance();
    IQueue&lt;Integer&gt; queue = hz.getQueue( &quot;queue&quot; );
    while ( true ) {
      int item = queue.take();
      System.out.println( &quot;Consumed: &quot; + item );
      if ( item == -1 ) {
        queue.put( -1 );
        break;
      }
      Thread.sleep( 5000 );
    }
    System.out.println( &quot;Consumer Finished!&quot; );
  }
}
</code></pre>
<p>As seen in the above sample code, <code>Consumer</code> waits 5 seconds before it consumes the next message. It stops once it receives <strong>-1</strong>. Also note that, <code>Consumer</code> puts <strong>-1</strong> back on the queue before the loop is ended. </p>
<p>When you start first the <code>Producer</code> and then the <code>Consumer</code>, items produced on the queue will be consumed from that same queue.</p>
<p>From the above codes, you can see that item production is done at every second, and the consumption is performed at every 5 seconds. So, it can be realized that the consumer keeps growing. To balance the produce/consume operation, let&#39;s start another consumer. By this way, consumption is distributed to these two consumers, see the sample outputs below. </p>
<p>Once the second consumer is started after a while, first consumer output:</p>
<pre><code class="lang-plain">...
Consumed 13 
Consumed 15
Consumer 17
...
</code></pre>
<p>Second consumer output:</p>
<pre><code class="lang-plain">...
Consumed 14 
Consumed 16
Consumer 18
...
</code></pre>
<p>In the case of a lot of producers and consumers for the queue, using a list of queues may solve the queue bottlenecks. Of course, in this case, you should be aware that ordering of messages being sent to different queues is not guaranteed. But, since in most cases strict ordering is not important, list of queues would be a good solution.</p>
<p><img src="images/NoteSmall.jpg" alt="image"> <strong><em>NOTE:</em></strong> <em>The items are taken from the queue in the same order they were put. However, if there are more than one consumers, this ordering is not guaranteed.</em></p>
<h3 id="bounded-queue">Bounded Queue</h3>
<p>A bounded queue is a queue with a limited capacity. When the bounded queue is full, no more items can be put into the queue until some items are taken out.</p>
<p>A Hazelcast distributed queue can be turned into a bounded queue by setting the capacity limit using the <code>max-size</code> property.</p>
<p>Queue capacity can be set using the <code>max-size</code> property in the configuration, as shown below. <code>max-size</code> specifies the maximum size of the queue. Once the queue size reaches this value, <code>put</code> operations will be blocked until the queue size goes below <code>max-size</code>, that happens when a consumer removes items from the queue.</p>
<p>Let&#39;s set <strong>10</strong> as the maximum size of our sample queue in the Sample Queue Code.</p>
<pre><code class="lang-xml">&lt;hazelcast&gt;
  ...
  &lt;queue name=&quot;queue&quot;&gt;
    &lt;max-size&gt;10&lt;/max-size&gt;
  &lt;/queue&gt;
  ...
&lt;/hazelcast&gt;
</code></pre>
<p>When the producer is started, 10 items are put into the queue and then the queue will not allow more <code>put</code> operations. When the consumer is started, it will remove items from the queue. This means that the producer can <code>put</code> more items into the queue until there are 10 items in the queue again, at which point <code>put</code> operation again become blocked.</p>
<p>But in this sample code, the producer is 5 times faster than the consumer. It will effectively always be waiting for the consumer to remove items before it can put more on the queue. For this sample code, if maximum throughput was the goal, it would be a good option to start multiple consumers to prevent the queue from filling up.</p>
<h3 id="queue-persistence">Queue Persistence</h3>
<p>Hazelcast allows you to load and store the distributed queue entries from/to a persistent datastore using the interface <code>QueueStore</code>. If queue store is enabled, each entry added to queue will also be stored at the configured queue store. When the number of items in queue exceeds the memory limit, items will only persisted to queue store, they will not be stored in queue memory. </p>
<p><code>QueueStore</code> interface enables you store, load and delete entries with its methods like <code>store</code>, <code>storeAll</code>, <code>load</code> and <code>delete</code>. Below sample class includes all the <code>QueueStore</code> methods.</p>
<pre><code class="lang-java">public class TheQueueStore implements QueueStore&lt;Item&gt; {
    @Override
    public void delete(Long key) {
        System.out.println(&quot;delete&quot;);
    }

    @Override
    public void store(Long key, Item value) {
        System.out.println(&quot;store&quot;);
    }

    @Override
    public void storeAll(Map&lt;Long, Item&gt; map) {
        System.out.println(&quot;store all&quot;);
    }

    @Override
    public void deleteAll(Collection&lt;Long&gt; keys) {
        System.out.println(&quot;deleteAll&quot;);
    }

    @Override
    public Item load(Long key) {
        System.out.println(&quot;load&quot;);
        return null;
    }

    @Override
    public Map&lt;Long, Item&gt; loadAll(Collection&lt;Long&gt; keys) {
        System.out.println(&quot;loadAll&quot;);
        return null;
    }

    @Override
    public Set&lt;Long&gt; loadAllKeys() {
        System.out.println(&quot;loadAllKeys&quot;);
        return null;
    }
</code></pre>
<p>As you can guess, <code>Item</code> must be serializable. And below is a sample queue store configuration.</p>
<pre><code class="lang-xml">&lt;queue-store&gt;
  &lt;class-name&gt;com.hazelcast.QueueStoreImpl&lt;/class-name&gt;
  &lt;properties&gt;
    &lt;property name=&quot;binary&quot;&gt;false&lt;/property&gt;
    &lt;property name=&quot;memory-limit&quot;&gt;10000&lt;/property&gt;
    &lt;property name=&quot;bulk-load&quot;&gt;500&lt;/property&gt;
  &lt;/properties&gt;
&lt;/queue-store&gt;
</code></pre>
<p>Let&#39;s explain the properties.</p>
<ul>
<li><p><strong>Binary</strong>:
By default, Hazelcast stores queue items in serialized form in memory and before inserting into datastore, deserializes them. But if you will not reach the queue store from an external application, you can prefer the items to be inserted in binary form. So you get rid of de-serialization step which is a performance optimization. Binary feature is disabled by default.</p>
</li>
<li><p><strong>Memory Limit</strong>:
This is the number of items after which Hazelcast will just store items to datastore. For example, if memory limit is 1000, then 1001st item will be just put into datastore. This feature is useful when you want to avoid out-of-memory conditions. Default number for memory limit is 1000. If you want to always use memory, you can set it to <code>Integer.MAX_VALUE</code>.</p>
</li>
<li><p><strong>Bulk Load</strong>:
At initialization of queue, items are loaded from QueueStore in bulks. Bulk load is the size of these bulks. By default it is 250.</p>
</li>
</ul>
<h2 id="multimap">MultiMap</h2>
<p><code>MultiMap</code> is a specialized map where you can store multiple values under a single key. Just like any other distributed data structure implementation in Hazelcast, <code>MultiMap</code> is distributed and thread-safe.</p>
<p><code>MultiMap</code> is not an implementation of <code>java.util.Map</code> due to the difference in method signatures. It supports most features of <code>IMap</code> except for indexing, predicates and MapLoader/MapStore. Yet, like map, entries are almost evenly distributed onto all cluster members and when a new member joins to the cluster, the same ownership logic used in distributed map applies.</p>
<h3 id="sample-multimap-code">Sample MultiMap Code</h3>
<p>Let&#39;s write a code that puts data into a MultiMap.</p>
<pre><code class="lang-java">public class PutMember {
  public static void main( String[] args ) {
    HazelcastInstance hazelcastInstance = Hazelcast.newHazelcastInstance();
    MultiMap &lt;String , String &gt; map = hazelcastInstance.getMultiMap( &quot;map&quot; );

    map.put( &quot;a&quot;, &quot;1&quot; );
    map.put( &quot;a&quot;, &quot;2&quot; );
    map.put( &quot;b&quot;, &quot;3&quot; ); 
    System.out.println( &quot;PutMember:Done&quot; );
  }
}
</code></pre>
<p>And, now let&#39;s print the entries in this MultiMap.</p>
<pre><code class="lang-java">public class PrintMember {
  public static void main( String[] args ) { 
    HazelcastInstance hazelcastInstance = Hazelcast.newHazelcastInstance();
    MultiMap &lt;String, String &gt; map = hazelcastInstance.getMultiMap( &quot;map&quot; );
    for ( String key : map.keySet() ){
      Collection &lt;String &gt; values = map.get( key );
      System.out.println( &quot;%s -&gt; %s\n&quot;,key, values );
    }
  }
}
</code></pre>
<p>After you run the first code, run the <code>PrintMember</code>. You will see the key <strong><code>a</code></strong> has two values, as shown below.</p>
<p><code>b -&gt; [3]</code></p>
<p><code>a -&gt; [2, 1]</code></p>
<h3 id="multimap-configuration">MultiMap Configuration</h3>
<p>When using MultiMap, the collection type of values can be either a <strong>Set</strong> or a <strong>List</strong>. This is configured with <code>valueCollectionType</code> parameter. If you choose <code>Set</code>, duplicate and null values are not allowed in your collection and ordering is irrelevant. If you choose <code>List</code>, ordering is relevant and your collection can include duplicate and null values.</p>
<p>You can also enable statistics for your MultiMap using the <code>statisticsEnabled</code> parameter. If enabled, statistics can be retrieved with <code>getLocalMultiMapStats()</code> method.
<br></br></p>
<p><strong><em>RELATED INFORMATION</em></strong></p>
<p><em>Please refer to <a href="https://github.com/hazelcast/hazelcast/blob/b20df7b1677e00431ceddb7e90a0e3615a3e9914/hazelcast/src/main/java/com/hazelcast/config/MultiMapConfig.java">MultiMapConfig.java</a> for more information on configuration options.</em></p>
<h2 id="set">Set</h2>
<p>Hazelcast Set is distributed and concurrent implementation of <code>java.util.Set</code>.</p>
<ul>
<li>Hazelcast Set does not allow duplicate elements.</li>
<li>Hazelcast Set does not preserve the order of elements.</li>
<li>Hazelcast Set is non-partitioned data structure which means all the data that belongs to a Set will live on one single partition in that node.</li>
<li>Hazelcast Set cannot be scaled beyond the capacity of a single machine. Since the whole Set lives on a single partition, storing large amount of data on a single Set may result in causing memory pressures. Therefore, it is advisable to use multiple sets to store large amount of data; this way all the sets will be spread across the cluster, hence sharing the load.</li>
<li>Backup of Hazelcast Set is stored on partition of another node in the cluster so that data is not lost in the event of primary node failure.</li>
<li>There is no batching while iterating over Set. All items will be copied to local and iteration will occur locally.</li>
<li>Equals method implementation of Hazelcast Set uses serialized byte version of objects compared to <code>java.util.HashSet</code>.</li>
</ul>
<h3 id="sample-set-code">Sample Set Code</h3>
<pre><code class="lang-java">import com.hazelcast.core.Hazelcast;
import java.util.Set;
import java.util.Iterator;

HazelcastInstance hazelcastInstance = Hazelcast.newHazelcastInstance();

Set&lt;Price&gt; set = hazelcastInstance.getSet( &quot;IBM-Quote-History&quot; );
set.add( new Price( 10, time1 ) );
set.add( new Price( 11, time2 ) );
set.add( new Price( 12, time3 ) );
set.add( new Price( 11, time4 ) );
//....
Iterator&lt;Price&gt; iterator = set.iterator();
while ( iterator.hasNext() ) { 
  Price price = iterator.next(); 
  //analyze
}
</code></pre>
<h3 id="event-registration-and-configuration-for-set">Event Registration and Configuration for Set</h3>
<p>Hazelcast Set uses ItemListener to listen to events which occur when items are added and removed.</p>
<pre><code class="lang-java">import java.util.Queue;
import java.util.Map; 
import java.util.Set; 
import com.hazelcast.core.Hazelcast;
import com.hazelcast.core.ItemListener;
import com.hazelcast.core.EntryListener;
import com.hazelcast.core.EntryEvent; 

public class Sample implements ItemListener {

  public static void main( String[] args ) { 
    Sample sample = new Sample();
    HazelcastInstance hazelcastInstance = Hazelcast.newHazelcastInstance();
    ISet&lt;Price&gt; set = hazelcastInstance.getSet( &quot;default&quot; );
    set.addItemListener( sample, true ); 

    Price price = new Price( 10, time1 )
    set.add( price );
    set.remove( price );
  } 

  public void itemAdded( Object item ) {
    System.out.println( &quot;Item added = &quot; + item );
  }

  public void itemRemoved( Object item ) {
    System.out.println( &quot;Item removed = &quot; + item );
  }     
}
</code></pre>
<p><img src="images/NoteSmall.jpg" alt="image"> <strong><em>NOTE:</em></strong> <em>To learn more about the configuration of listeners please refer to <a href="#listener-configurations">Listener Configurations</a>.</em></p>
<h2 id="list">List</h2>
<p>Hazelcast List is very similar to Hazelcast Set but it allows duplicate elements.</p>
<ul>
<li>Besides allowing duplicate elements, Hazelcast List preserves the order of elements.</li>
<li>Hazelcast List is non-partitioned data structure where values and each backup is represented by its own single partition.</li>
<li>Hazelcast List cannot be scaled beyond the capacity of a single machine.</li>
<li>There is no batching while iterating over List. All items will be copied to local and iteration will occur locally.</li>
</ul>
<h3 id="sample-list-code">Sample List Code</h3>
<pre><code class="lang-java">import com.hazelcast.core.Hazelcast;
import java.util.List;
import java.util.Iterator;

HazelcastInstance hz = Hazelcast.newHazelcastInstance();

List&lt;Price&gt; list = hz.getList( &quot;IBM-Quote-Frequency&quot; );
list.add( new Price( 10 ) );
list.add( new Price( 11 ) );
list.add( new Price( 12 ) );
list.add( new Price( 11 ) );
list.add( new Price( 12 ) );

//....
Iterator&lt;Price&gt; iterator = list.iterator();
while ( iterator.hasNext() ) { 
  Price price = iterator.next(); 
  //analyze
}
</code></pre>
<h3 id="event-registration-and-configuration-for-list">Event Registration and Configuration for List</h3>
<p>Hazelcast List uses <code>ItemListener</code> to listen to events which occur when items are added and removed.</p>
<pre><code class="lang-java">import java.util.Queue;
import java.util.Map; 
import java.util.Set; 
import com.hazelcast.core.Hazelcast;
import com.hazelcast.core.ItemListener;
import com.hazelcast.core.EntryListener;
import com.hazelcast.core.EntryEvent; 

public class Sample implements ItemListener{

  public static void main( String[] args ) { 
    Sample sample = new Sample();
    HazelcastInstance hazelcastInstance = Hazelcast.newHazelcastInstance();
    IList&lt;Price&gt; list = hazelcastInstance.getList( &quot;default&quot; );
    list.addItemListener( sample, true ); 

    Price price = new Price( 10, time1 )
    list.add( price );
    list.remove( price );
  } 

  public void itemAdded( Object item ) {
    System.out.println( &quot;Item added = &quot; + item );
  }

  public void itemRemoved( Object item ) {
    System.out.println( &quot;Item removed = &quot; + item );
  }     
}
</code></pre>
<p><img src="images/NoteSmall.jpg" alt="image"> <strong><em>NOTE:</em></strong> <em>To learn more about the configuration of listeners please refer to <a href="#listener-configurations">Listener Configurations</a>.</em></p>
<h2 id="topic">Topic</h2>
<p>Hazelcast provides distribution mechanism for publishing messages that are delivered to multiple subscribers which is also known as publish/subscribe (pub/sub) messaging model. Publishing and subscribing operations are cluster wide. When a member subscribes for a topic, it is actually registering for messages published by any member in the cluster, including the new members joined after you add the listener.</p>
<p><img src="images/NoteSmall.jpg" alt="image"> <strong><em>NOTE:</em></strong> <em>Publish operation is async. It does not wait for operations to run in remote nodes, it works as fire and forget.</em></p>
<h3 id="sample-topic-code">Sample Topic Code</h3>
<pre><code class="lang-java">import com.hazelcast.core.Topic;
import com.hazelcast.core.Hazelcast;
import com.hazelcast.core.MessageListener;

public class Sample implements MessageListener&lt;MyEvent&gt; {

  public static void main( String[] args ) {
    Sample sample = new Sample();
    HazelcastInstance hazelcastInstance = Hazelcast.newHazelcastInstance();
    ITopic topic = hazelcastInstance.getTopic( &quot;default&quot; );
    topic.addMessageListener( sample );
    topic.publish( new MyEvent() );
  }

  public void onMessage( Message&lt;MyEvent&gt; message ) {
    MyEvent myEvent = message.getMessageObject();
    System.out.println( &quot;Message received = &quot; + myEvent.toString() );
    if ( myEvent.isHeavyweight() ) {
      messageExecutor.execute( new Runnable() {
          public void run() {
            doHeavyweightStuff( myEvent );
          }
      } );
    }
  }

  // ...

  private final Executor messageExecutor = Executors.newSingleThreadExecutor();
}
</code></pre>
<h3 id="statistics">Statistics</h3>
<p>Topic has two statistic variables that can be queried. These values are incremental and local to the member.</p>
<pre><code class="lang-java">HazelcastInstance hazelcastInstance = Hazelcast.newHazelcastInstance();
ITopic&lt;Object&gt; myTopic = hazelcastInstance.getTopic( &quot;myTopicName&quot; );

myTopic.getLocalTopicStats().getPublishOperationCount();
myTopic.getLocalTopicStats().getReceiveOperationCount();
</code></pre>
<p><code>getPublishOperationCount</code> and <code>getReceiveOperationCount</code> returns total number of publishes and received messages since the start of this node, respectively. Please note that, these values are not backed up and if the node goes down, they will be lost.</p>
<p>This feature can be disabled with topic configuration. Please see <a href="#topic-configuration">Topic Configuration</a>.</p>
<p><img src="images/NoteSmall.jpg" alt="image"> <strong><em>NOTE:</em></strong> <em>These statistics values can be also viewed in Management Center. Please see <a href="#topics">Topics</a></em>.</p>
<h3 id="internals">Internals</h3>
<p>Each node has the list of all registrations in the cluster. When a new node is registered for a topic, it will send a registration message to all members in the cluster. Also, when a new node joins the cluster, it will receive all registrations made so far in the cluster.</p>
<p>The behavior of topic varies depending on the value of configuration parameter <code>globalOrderEnabled</code>.</p>
<ul>
<li>If <code>globalOrderEnabled</code> is disabled:</li>
</ul>
<p>Messages are ordered, i.e. listeners (subscribers) will process the messages in the order they are actually published. If cluster member M publishes messages <em>m1, m2, m3,...,mn</em> to a topic T, then Hazelcast makes sure that all of the subscribers of topic <strong>T</strong> will receive and process <em>m1, m2, m3,...,mn</em> in the given order.</p>
<p>Here is how it works. Let&#39;s say that we have three nodes (node1, node2 and node3) and that <em>node1</em> and <em>node2</em> are registered to a topic named <code>news</code>. Notice that, all three nodes know that <em>node1</em> and <em>node2</em> registered to <code>news</code>.</p>
<p>In this example, <em>node1</em> publishes two messages: <code>a1</code> and <code>a2</code>. And, <em>node3</em> publishes two messages: <code>c1</code> and <code>c2</code>. When <em>node1</em> and <em>node3</em> publishes a message, they will check their local list for registered nodes. They discover that <em>node1</em> and <em>node2</em> are in the list. Then, it fires messages to those nodes. One of the possible order of messages received can be following.</p>
<p>Node1 -&gt; c1, b1, a2, c2</p>
<p>Node2 -&gt; c1, c2, a1, a2</p>
<ul>
<li>If <code>globalOrderEnabled</code> is enabled:</li>
</ul>
<p>When enabled, it guarantees that all nodes listening the same topic will get messages in the same order.</p>
<p>Here is how it works. Let&#39;s say that again we have three nodes (node1, node2 and node3) and that <em>node1</em> and <em>node2</em> are registered to a topic named <code>news</code>. Notice that all three nodes know that <em>node1</em> and <em>node2</em> registered to <code>news</code>.</p>
<p>In this example, <em>node1</em> publishes two messages: <code>a1</code> and <code>a2</code>. And, <em>node3</em> publishes two messages: <code>c1</code> and <code>c2</code>. When a node publishes messages over topic <code>news</code>, it first calculates which partition <code>news</code> ID corresponds to. Then, send an operation to owner of the partition for that node to publish messages. Let&#39;s assume that <code>news</code> corresponds to a partition that <em>node2</em> owns. Then, <em>node1</em> and <em>node3</em> first sends all messages to <em>node2</em>. Assume that the messages are published in the following order.</p>
<p>Node1 -&gt; a1, c1, a2, c2</p>
<p>Then, <em>node2</em> publishes these messages by looking at registrations in its local list. It sends these messages to <em>node1</em> and <em>node2</em> (it will make a local dispatch for itself).</p>
<p>Node1 -&gt; a1, c1, a2, c2</p>
<p>Node2 -&gt; a1, c1, a2, c2</p>
<p>This way we guarantee that all nodes will see the events in same order.</p>
<p>In both cases, there is a <code>StripedExecutor</code> in EventService responsible for dispatching the received message. For all events in Hazelcast, the order that events are generated and the order they are published to the user are guaranteed to be the same via this <code>StripedExecutor</code>.</p>
<p>In <code>StripedExecutor</code>, there are as much threads specified in the property  <code>hazelcast.event.thread.count</code> (default is 5). For a specific event source (for topic, for a particular topic name), <em>hash of that source&#39;s name % 5</em> gives the ID of responsible thread. Note that, there can be another event source (entry listener of a map, item listener of a collection, etc.) corresponding to the same thread. In order not to make other messages to block, heavy process should not be done in this thread. If there is a time consuming work needs to be done, the work should be handed over to another thread. Please see <a href="#sample-topic-code">Sample Topic Code</a>.</p>
<h3 id="topic-configuration">Topic Configuration</h3>
<p><strong>Declarative Configuration:</strong></p>
<pre><code class="lang-xml">&lt;hazelcast&gt;
  ...
  &lt;topic name=&quot;yourTopicName&quot;&gt;
    &lt;global-ordering-enabled&gt;true&lt;/global-ordering-enabled&gt;
    &lt;statistics-enabled&gt;true&lt;/statistics-enabled&gt;
    &lt;message-listeners&gt;
      &lt;message-listener&gt;MessageListenerImpl&lt;/message-listener&gt;
    &lt;/message-listeners&gt;
  &lt;/topic&gt;
  ...
&lt;/hazelcast&gt;
</code></pre>
<p><strong>Programmatic Configuration:</strong></p>
<pre><code class="lang-java">TopicConfig topicConfig = new TopicConfig();
topicConfig.setGlobalOrderingEnabled( true );
topicConfig.setStatisticsEnabled( true );
topicConfig.setName( &quot;yourTopicName&quot; );
MessageListener&lt;String&gt; implementation = new MessageListener&lt;String&gt;() {
  @Override
  public void onMessage( Message&lt;String&gt; message ) {
    // process the message
  }
};
topicConfig.addMessageListenerConfig( new ListenerConfig( implementation ) );
HazelcastInstance instance = Hazelcast.newHazelcastInstance()
</code></pre>
<p>Default values are</p>
<ul>
<li><p>Global ordering is <strong>false</strong>, meaning there is no global order guarantee by default.</p>
</li>
<li><p>Statistics are <strong>true</strong>, meaning statistics are calculated by default.</p>
</li>
</ul>
<p>Topic related but not topic specific configuration parameters</p>
<ul>
<li><code>hazelcast.event.queue.capacity</code>: default value is 1,000,000</li>
<li><code>hazelcast.event.queue.timeout.millis</code>: default value is 250</li>
<li><code>hazelcast.event.thread.count</code>: default value is 5</li>
</ul>
<p><br></br>
<strong><em>RELATED INFORMATION</em></strong> </p>
<p><em>For description of these parameters, please see <a href="#global-event-configuration">Global Event Configuration</a></em></p>
<h2 id="lock">Lock</h2>
<p>ILock is the distributed implementation of <code>java.util.concurrent.locks.Lock</code>. Meaning if you lock on an ILock, the critical
section that it guards is guaranteed to be executed by only one thread in entire cluster. Even though locks are great for synchronization, they can lead to problems if not used properly. And also please note that Hazelcast Lock does not support fairness.</p>
<p>A few warnings when using locks:</p>
<ul>
<li>Always use lock with <em>try</em>-<em>catch</em> blocks. It will ensure that lock will be released if an exception is thrown from
the code in critical section. Also note that lock method is outside <em>try</em>-<em>catch</em> block, because we do not want to unlock
if lock operation itself fails.</li>
</ul>
<pre><code class="lang-java">import com.hazelcast.core.Hazelcast;
import java.util.concurrent.locks.Lock;

HazelcastInstance hazelcastInstance = Hazelcast.newHazelcastInstance();
Lock lock = hazelcastInstance.getLock( &quot;myLock&quot; );
lock.lock();
try {
  // do something here
} finally {
  lock.unlock();
}
</code></pre>
<ul>
<li>If a lock is not released in the cluster, another thread that is trying to get the
lock can wait forever. To avoid this, <code>tryLock</code> with a timeout value can be used. One can
set a high value (normally should not take that long) for <code>tryLock</code>. Return value of <code>tryLock</code> can be checked as follows:</li>
</ul>
<pre><code class="lang-java">if ( lock.tryLock ( 10, TimeUnit.SECONDS ) ) {
  try {  
    // do some stuff here..  
  } finally {  
    lock.unlock();  
  }   
} else {
  // warning
}
</code></pre>
<ul>
<li><p>Another method to avoid ending up with indefinitely waiting threads is using lock with lease time. This will cause
lock to be released in the given time. Lock can be unlocked before time expires safely. Note that the unlock operation can
throw <code>IllegalMonitorStateException</code> if lock is released because of lease time expiration. If it is the case, it means
that critical section guarantee is broken.</p>
<p>  Please see the below example.</p>
</li>
</ul>
<pre><code class="lang-java">lock.lock( 5, TimeUnit.SECONDS )
try {
  // do some stuff here..
} finally {
  try {
    lock.unlock();
  } catch ( IllegalMonitorStateException ex ){
    // WARNING Critical section guarantee can be broken
  }
}
</code></pre>
<ul>
<li>Locks are fail-safe. If a member holds a lock and some other members go down, cluster will keep your locks safe and available.
Moreover, when a member leaves the cluster, all the locks acquired by this dead member will be removed so that these
locks can be available for live members immediately.</li>
</ul>
<ul>
<li><p>Locks are re-entrant, meaning same thread can lock multiple times on the same lock. Note that for other threads to be
able to require this lock, owner of the lock should call unlock as many times as it called lock.</p>
</li>
<li><p>In split-brain scenario, cluster behaves as if there are two different clusters. Since two separate clusters are not aware of each other,
two nodes from different clusters can acquire the same lock.
For more information on places where split brain can be handled, please see <a href="#how-is-split-brain-syndrome-handled">Split Brain</a>.</p>
</li>
<li><p>Locks are not automatically removed. If a lock is not used anymore, Hazelcast will not automatically garbage collect the lock and
this can lead to an OutOfMemoryError. So if you create locks on the fly, make sure they are destroyed.</p>
</li>
<li><p>Hazelcast IMap also provides a locking support on the entry level using the method <code>IMap.lock(key)</code>. Although the same infrastructure 
is being used, <code>IMap.lock(key)</code> is not an ILock and it is not possible to expose it directly.</p>
</li>
</ul>
<h3 id="icondition">ICondition</h3>
<p>ICondition is the distributed implementation of <code>notify</code>, <code>notifyAll</code> and <code>wait</code> operations on Java object . It can be used to synchronize
threads  across the cluster. More specifically, it is used when a thread&#39;s work  depends on another thread&#39;s output. A good example
can be producer/consumer methodology. </p>
<p>Please see the below code snippets for a sample producer/consumer implementation.</p>
<p><strong>Producer thread:</strong></p>
<pre><code class="lang-java">HazelcastInstance hazelcastInstance = Hazelcast.newHazelcastInstance();
Lock lock = hazelcastInstance.getLock( &quot;myLockId&quot; );
ICondition condition = lock.newCondition( &quot;myConditionId&quot; );

lock.lock();
try {
  while ( !shouldProduce() ) {
    condition.await(); // frees the lock and waits for signal
                       // when it wakes up it re-acquires the lock
                       // if available or waits for it to become
                       // available
  }
  produce();
  condition.signalAll();
} finally {
  lock.unlock();
}
</code></pre>
<p><strong>Consumer thread:</strong></p>
<pre><code class="lang-java">HazelcastInstance hazelcastInstance = Hazelcast.newHazelcastInstance();
Lock lock = hazelcastInstance.getLock( &quot;myLockId&quot; );
ICondition condition = lock.newCondition( &quot;myConditionId&quot; );

lock.lock();
try {
  while ( !canConsume() ) {
    condition.await(); // frees the lock and waits for signal
                       // when it wakes up it re-acquires the lock if 
                       // available or waits for it to become
                       // available
  }
  consume();
  condition.signalAll();
} finally {
  lock.unlock();
}
</code></pre>
<h2 id="iatomiclong">IAtomicLong</h2>
<p>Hazelcast IAtomicLong is the distributed implementation of <code>java.util.concurrent.atomic.AtomicLong</code>. It offers most of AtomicLong&#39;s operations such as <code>get</code>, <code>set</code>, <code>getAndSet</code>, <code>compareAndSet</code> and <code>incrementAndGet</code>. Since IAtomicLong is a distributed implementation, these operations involve remote calls and hence their performances differ from AtomicLong.</p>
<p>Below sample code creates an instance, increments it by a million and prints the count.</p>
<pre><code class="lang-java">public class Member {
  public static void main( String[] args ) {
    HazelcastInstance hazelcastInstance = Hazelcast.newHazelcastInstance();     
    IAtomicLong counter = hazelcastInstance.getAtomicLong( &quot;counter&quot; );
    for ( int k = 0; k &lt; 1000 * 1000; k++ ) {
      if ( k % 500000 == 0 ) {
        System.out.println( &quot;At: &quot; + k );
      }
      counter.incrementAndGet();
    }
    System.out.printf( &quot;Count is %s\n&quot;, counter.get() );
  }
}
</code></pre>
<p>When you start other instances with the code above, you will see the count as <em>member count</em> times <em>a million</em>.</p>
<p>You can send functions to an IAtomicLong. <code>Function</code> is a Hazelcast owned, single method interface. Below sample <code>Function</code> implementation doubles the original value.</p>
<pre><code class="lang-java">private static class Add2Function implements Function &lt;Long, Long&gt; { 
  @Override
  public Long apply( Long input ) { 
    return input + 2;
  }
}
</code></pre>
<p>Below methods can be used to execute functions on IAtomicLong.</p>
<ul>
<li><code>apply</code>: It applies the function to the value in IAtomicLong without changing the actual value and returning the result.</li>
<li><code>alter</code>: It alters the value stored in the IAtomicLong by applying the function. It will not send back a result.</li>
<li><code>alterAndGet</code>: It alters the value stored in the IAtomicLong by applying the function, storing the result in the IAtomicLong and returning the result.</li>
<li><code>getAndAlter</code>: It alters the value stored in the IAtomicLong by applying the function and returning the original value.</li>
</ul>
<p>Below sample code includes these methods.</p>
<pre><code class="lang-java">public class Member {
  public static void main( String[] args ) {
    HazelcastInstance hazelcastInstance = Hazelcast.newHazelcastInstance();         
    IAtomicLong atomicLong = hazelcastInstance.getAtomicLong( &quot;counter&quot; );

    atomicLong.set( 1 );
    long result = atomicLong.apply( new Add2Function() );         
    System.out.println( &quot;apply.result: &quot; + result);         
    System.out.println( &quot;apply.value: &quot; + atomicLong.get() );

    atomicLong.set( 1 );
    atomicLong.alter( new Add2Function() );             
    System.out.println( &quot;alter.value: &quot; + atomicLong.get() );

    atomicLong.set( 1 );
    result = atomicLong.alterAndGet( new Add2Function() );         
    System.out.println( &quot;alterAndGet.result: &quot; + result );         
    System.out.println( &quot;alterAndGet.value: &quot; + atomicLong.get() );

    atomicLong.set( 1 );
    result = atomicLong.getAndAlter( new Add2Function() );         
    System.out.println( &quot;getAndAlter.result: &quot; + result );         
    System.out.println( &quot;getAndAlter.value: &quot; + atomicLong.get() );
  }
}
</code></pre>
<p>The reason for using a function instead of a simple code line like <code>atomicLong.set(atomicLong.get() + 2));</code> is that, read and write operations of IAtomicLong are not atomic. Since it is a distributed implementation, those operations can be remote ones, which may lead to race problems. By using functions, the data is not pulled into the code, but the code is sent to the data. And this makes it more scalable.</p>
<p><img src="images/NoteSmall.jpg" alt="image"> <strong><em>NOTE:</em></strong> <em>IAtomicLong has 1 synchronous backup and no asynchronous backups. Its backup count is not configurable.</em></p>
<h2 id="isemaphore">ISemaphore</h2>
<p>Hazelcast ISemaphore is the distributed implementation of <code>java.util.concurrent.Semaphore</code>. As you may know, semaphores offer <strong>permit</strong>s to control the thread counts in the case of performing concurrent activities. To execute a concurrent activity, a thread grants a permit or waits until a permit becomes available. When the execution is completed, permit is released.</p>
<p><img src="images/NoteSmall.jpg" alt="image"> <strong><em>NOTE:</em></strong> <em>Semaphore with a single permit may be considered as a lock. But, unlike the locks, when semaphores are used any thread can release the permit and also semaphores can have multiple permits.</em></p>
<p><img src="images/NoteSmall.jpg" alt="image"> <strong><em>NOTE:</em></strong> <em>Hazelcast Semaphore does not support fairness.</em></p>
<p>When a permit is acquired on ISemaphore:</p>
<ul>
<li>if there are permits, number of permits in the semaphore is decreased by one and calling thread performs its activity. If there is contention, the longest waiting thread will acquire the permit before all other threads.</li>
<li>if no permits are available, calling thread blocks until a permit comes available. And when a timeout happens during this block, thread is interrupted. In the case where the semaphore
is destroyed, an <code>InstanceDestroyedException</code> is thrown.</li>
</ul>
<p>Below sample code uses an IAtomicLong resource for 1000 times, increments the resource when a thread starts to use it and decrements it when the thread completes.</p>
<pre><code class="lang-java">public class SemaphoreMember {
  public static void main( String[] args ) throws Exception{
    HazelcastInstance hazelcastInstance = Hazelcast.newHazelcastInstance(); 
    ISemaphore semaphore = hazelcastInstance.getSemaphore( &quot;semaphore&quot; ); 
    IAtomicLong resource = hazelcastInstance.getAtomicLong( &quot;resource&quot; ); 
    for ( int k = 0 ; k &lt; 1000 ; k++ ) {
      System.out.println( &quot;At iteration: &quot; + k + &quot;, Active Threads: &quot; + resource.get() );
      semaphore.acquire();
      try {
        resource.incrementAndGet();
        Thread.sleep( 1000 );
        resource.decrementAndGet();
      } finally { 
        semaphore.release();
      }
    }
    System.out.println(&quot;Finished&quot;);
  }
}
</code></pre>
<p>Let&#39;s limit the concurrent access to this resource by allowing at most 3 threads. This can be configured declaratively by setting the <code>initial-permits</code> property, as shown below.</p>
<pre><code class="lang-xml">&lt;semaphore name=&quot;semaphore&quot;&gt; 
  &lt;initial-permits&gt;3&lt;/initial-permits&gt;
&lt;/semaphore&gt;
</code></pre>
<p><img src="images/NoteSmall.jpg" alt="image"> <strong><em>NOTE:</em></strong> <em>If there is a shortage of permits while the semaphore is being created, value of this property can be set to a negative number.</em></p>
<p>If you execute the above <code>SemaphoreMember</code> class 5 times, output will be similar to the following:</p>
<p><code>At iteration: 0, Active Threads: 1</code></p>
<p><code>At iteration: 1, Active Threads: 2</code></p>
<p><code>At iteration: 2, Active Threads: 3</code></p>
<p><code>At iteration: 3, Active Threads: 3</code></p>
<p><code>At iteration: 4, Active Threads: 3</code></p>
<p>As can be seen, maximum count of concurrent threads is equal or smaller than 3. If you remove the semaphore acquire/release statements in <code>SemaphoreMember</code>, you will see that there is no limitation on the number of concurrent usages.</p>
<p>Hazelcast also provides backup support for ISemaphore. When a member goes down, another member can take over the semaphore with the permit information (permits are automatically released when a member goes down). To enable this, synchronous or asynchronous backup should be configured with the properties <code>backup-count</code> and <code>async-backup-count</code>(by default, synchronous backup is already enabled).</p>
<p>A sample configuration is shown below.</p>
<pre><code class="lang-xml">&lt;semaphore name=&quot;semaphore&quot;&gt;
  &lt;initial-permits&gt;3&lt;/initial-permits&gt;
  &lt;backup-count&gt;1&lt;/backup-count&gt;
&lt;/semaphore&gt;
</code></pre>
<p><img src="images/NoteSmall.jpg" alt="image"> <strong><em>NOTE:</em></strong> <em>If high performance is more important (than not losing the permit information), you can disable the backups by setting <code>backup-count</code> to 0.</em></p>
<h2 id="iatomicreference">IAtomicReference</h2>
<p>The IAtomicLong is very useful if you need to deal with a long, but in some cases you need to deal with a reference. That is why Hazelcast also supports the IAtomicReference which is the distributed version of the <code>java.util.concurrent.atomic.AtomicReference</code>.</p>
<p>So lets see the IAtomicReference in action:</p>
<pre><code class="lang-java">public class Member {
    public static void main(String[] args) {
        Config config = new Config();

        HazelcastInstance hz = Hazelcast.newHazelcastInstance(config);

        IAtomicReference&lt;String&gt; ref = hz.getAtomicReference(&quot;reference&quot;);
        ref.set(&quot;foo&quot;);
        System.out.println(ref.get());
        System.exit(0);
    } 
}
</code></pre>
<p>When you execute the above sample, you will see the below output.</p>
<p><code>foo</code></p>
<p>Just like the IAtomicLong, the IAtomicReference has a bunch of methods that accept a &#39;function&#39; as argument like <code>alter</code>, <code>alterAndGet</code>, <code>getAndAlter</code> and <code>apply</code>. There are two big advantages of using these methods:</p>
<ul>
<li>It is better to send the function to the data, then the data to the function from a performance point of view. Often the function is a lot smaller than the value and therefore cheaper to send over the line. Also the function only needs to be transferred once to the target machine, and the value needs to be transferred twice.</li>
<li>You do not need to deal with concurrency control. If you would perform a load, transform, store, you could run into a data race since another thread might have updated the value you are about to overwrite. </li>
</ul>
<p>Of course there are some issues you need to be aware of as described below.</p>
<ul>
<li>IAtomicReference works based on the byte-content and not on the object-reference. So if you are using the <code>compareAndSet</code> method, it is important not to change to original value because its serialized content will then be different. 
Also important to know is that, if you rely on Java serialization, sometimes (especially with hashmaps) the same object can result in different binary content.</li>
<li>IAtomicReference will always have 1 synchronous backup.</li>
<li>All methods returning an object will return a private copy. So you can modify it, but the rest of the world will be shielded from your changes. If you want these changes to be visible to the rest of the world, you need to write the change back to the IAtomicReference; but be careful with introducing a data-race. </li>
<li>The &#39;in memory format&#39; of an IAtomicReference is <code>binary</code>. So the receiving side does not need to have the class definition available, unless it needs to be deserialized on the other side (e.g. because a method like &#39;alter&#39; is executed. This deserialization is done for every call that needs to have the object instead of the binary content, so be careful with expensive object graphs that need to be deserialized.</li>
<li>If you have an object with many fields or an object graph, and you only need to calculate some information or need a subset of fields, you can use the <code>apply</code> method for that. This way the whole object does not need to be sent over the line, only the information that is relevant.</li>
</ul>
<p><br></br></p>
<h2 id="icountdownlatch">ICountDownLatch</h2>
<p>Hazelcast ICountDownLatch is the distributed implementation of <code>java.util.concurrent.CountDownLatch</code>. As you may know, CountDownLatch is considered to be a gate keeper for concurrent activities. It enables the threads to wait for other threads to complete their operations.</p>
<p>Below sample codes describe the mechanism of ICountDownLatch. Assume that there is a leader process and there are follower ones that will wait until the leader completes. Here is the leader:</p>
<pre><code class="lang-java">public class Leader {
  public static void main( String[] args ) throws Exception {
    HazelcastInstance hazelcastInstance = Hazelcast.newHazelcastInstance();
    ICountDownLatch latch = hazelcastInstance.getCountDownLatch( &quot;countDownLatch&quot; );
    System.out.println( &quot;Starting&quot; );
    latch.trySetCount( 1 );
    Thread.sleep( 30000 );
    latch.countDown();
    System.out.println( &quot;Leader finished&quot; );
    latch.destroy();
  }
}
</code></pre>
<p>Since only a single step is needed to be completed as a sample, above code initializes the latch with 1. Then, sleeps for a while to simulate a process and starts the countdown. Finally, it clears up the latch. And now, let&#39;s write a follower:</p>
<pre><code class="lang-java">public class Follower {
  public static void main( String[] args ) throws Exception {
    HazelcastInstance hazelcastInstance = Hazelcast.newHazelcastInstance();
    ICountDownLatch latch = hazelcastInstance.getCountDownLatch( &quot;countDownLatch&quot; );
    System.out.println( &quot;Waiting&quot; );
    boolean success = latch.await( 10, TimeUnit.SECONDS );
    System.out.println( &quot;Complete: &quot; + success );
  }
}
</code></pre>
<p>The follower class above first retrieves ICountDownLatch and then calls the <code>await</code> method to enable the thread to listen for the latch. The method <code>await</code> has a timeout value as a parameter. This is useful when <code>countDown</code> method fails. To see ICountDownLatch on action, start the leader first and then start one or more followers. You will see that followers will wait until the leader completes.</p>
<p>In a distributed environment, it is possible that the counting down cluster member may go down. In this case, all listeners are notified immediately and automatically by Hazelcast. Of course, state of the current process just before the failure should be verified and &#39;how to continue now&#39; should be decided (e.g. restart all process operations, continue with the first failed process operation, throw an exception, etc.).</p>
<p>Although the ICountDownLatch is a very useful synchronization aid, it probably is not one you will use on a daily basis. Unlike Java’s implementation, Hazelcast’s ICountDownLatch count can be re-set after a countdown has finished but not during an active count.</p>
<p><img src="images/NoteSmall.jpg" alt="image"> <strong><em>NOTE:</em></strong> <em>ICountDownLatch has 1 synchronous backup and no asynchronous backups. Its backup count is not configurable. Also, the count cannot be re-set during an active count, it should be re-set after the countdown is finished.</em></p>
<h2 id="idgenerator">IdGenerator</h2>
<p>Hazelcast IdGenerator is used to generate cluster-wide unique identifiers. Generated identifiers are long type primitive values between 0 and <code>Long.MAX_VALUE</code>. </p>
<p>ID generation occurs almost at the speed of <code>AtomicLong.incrementAndGet()</code>. A group of 1 million identifiers is allocated for each cluster member. In the background, this allocation takes place with an IAtomicLong incremented by 1 million. Once cluster member claims to generate IDs (allocation is done), IdGenerator is able to increment a local counter. If a cluster member uses all IDs in the group, it will have another 1 million IDs. By this way, only one time of network traffic is needed, meaning 999.999 identifiers are generated in memory. And this is fast.</p>
<p>Let&#39;s write a sample identifier generator.</p>
<pre><code class="lang-java">public class IdGeneratorExample {
  public static void main( String[] args ) throws Exception {
    HazelcastInstance hazelcastInstance = Hazelcast.newHazelcastInstance();
    IdGenerator idGen = hazelcastInstance.getIdGenerator( &quot;newId&quot; );
    while (true) {
      Long id = idGen.newId();
      System.err.println( &quot;Id: &quot; + id );
      Thread.sleep( 1000 );
    }
  }
}
</code></pre>
<p>And let&#39;s run the above code two times. Output will be similar to the below.</p>
<pre><code class="lang-plain">Members [1] {
  Member [127.0.0.1]:5701 this
}
Id: 1
Id: 2
Id: 3
</code></pre>
<pre><code class="lang-plain">Members [2] {
  Member [127.0.0.1]:5701
  Member [127.0.0.1]:5702 this
}
Id: 1000001
Id: 1000002
Id: 1000003
</code></pre>
<p>You can see that the generated IDs are unique and counting upwards. If you see duplicated identifiers, it means your instances could not form a cluster. </p>
<p><img src="images/NoteSmall.jpg" alt="image"> <strong><em>NOTE:</em></strong> <em>Generated IDs are unique during the life cycle of the cluster. If the entire cluster is restarted, IDs start from 0 again or you can initialize to a value using the <code>init()</code> method of IdGenerator.</em></p>
<p><img src="images/NoteSmall.jpg" alt="image"> <strong><em>NOTE:</em></strong> <em>IdGenerator has 1 synchronous backup and no asynchronous backups. Its backup count is not configurable.</em></p>
<h2 id="replicated-map">Replicated Map</h2>
<p>A replicated map is a weakly consistent, distributed key-value data structure provided by Hazelcast.</p>
<p>In difference to all other data structures which are partitioned in design, a replicated map does not partition data
(it does not spread data to different cluster members) but replicates the data to all nodes.</p>
<p>This leads to higher memory consumption but faster read and write access since data are available on all nodes and
writes take place on local nodes, eventually being replicated to all other nodes.</p>
<p>Weak consistency compared to eventually consistency means that replication is done on a best efforts basis. Lost or missing updates
are neither tracked nor resent. This kind of data structures is suitable for immutable
objects, catalogue data or idempotent calculable data (like HTML pages).</p>
<p>It nearly fully implements the <code>java.util.Map</code> interface but lacks the methods from <code>java.util.concurrent.ConcurrentMap</code> since
there are no atomic guarantees to writes or reads.</p>
<pre><code class="lang-java">import com.hazelcast.core.Hazelcast;
import com.hazelcast.core.HazelcastInstance;
import java.util.Collection;
import java.util.Map;

HazelcastInstance hazelcastInstance = Hazelcast.newHazelcastInstance();
Map&lt;String, Customer&gt; customers = hazelcastInstance.getReplicatedMap(&quot;customers&quot;);
customers.put( &quot;1&quot;, new Customer( &quot;Joe&quot;, &quot;Smith&quot; ) );
customers.put( &quot;2&quot;, new Customer( &quot;Ali&quot;, &quot;Selam&quot; ) );
customers.put( &quot;3&quot;, new Customer( &quot;Avi&quot;, &quot;Noyan&quot; ) );

Collection&lt;Customer&gt; colCustomers = customers.values();
for ( Customer customer : colCustomers ) {
  // process customer
}
</code></pre>
<p><code>HazelcastInstance::getReplicatedMap</code> actually returns <code>com.hazelcast.core.ReplicatedMap</code> which, as stated above, extends
<code>java.util.Map</code> interface.</p>
<p>The <code>com.hazelcast.core.ReplicatedMap</code> interface has some additional methods for registering entry listeners or retrieving
values in an expected order.</p>
<h3 id="for-consideration">For Consideration</h3>
<p>A replicated map <strong>does not</strong> support ordered writes! In case of a conflict by two nodes simultaneously written to the
same key, a vector clock algorithm is used to resolve and decide on one of the values.</p>
<p>Due to the weakly consistent nature and the previously mentioned behaviors of replicated map, there is a
chance of reading staled data at any time. There is no read guarantee like repeatable reads.</p>
<h3 id="breakage-of-the-map-contract">Breakage of the Map-Contract</h3>
<p>ReplicatedMap does offer a distributed <code>java.util.Map::clear</code> implementation, but due to the asynchronous nature and the
weakly consistency of it, there is no point in time where you can say the map is empty. Every node on itself
applies it to its local dataset in &quot;a near point in time&quot;.
If you need a definite point in time to empty the map, you may want to consider using a lock around the <code>clear</code> operation.</p>
<p>There are ways to simulate this method by locking your user codebase and executing a remote operation that will
utilize <code>DistributedObject::destroy</code> to destroy the node&#39;s own proxy and storage of the ReplicatedMap. A new proxy instance
and storage will be created on next retrieval of the ReplicatedMap using <code>HazelcastInstance::getReplicatedMap</code>.
That means, you have to reallocate the ReplicatedMap in your code. Afterwards, just release the lock when finished.</p>
<h3 id="technical-design">Technical design</h3>
<p>There are several technical design decisions that worth mentioning. We strongly suggest reading the following section
to be aware of the configurable behavior.</p>
<p><strong>Initial provisioning</strong></p>
<p>If a new member joins, there are two ways of handling the initial provisioning that is executed to replicate all existing
values to the new member.</p>
<p>First of all, you can have an async fill up which does not block reads while fill up operation is underway. That way,
you have immediate access on the new member but it will take time until all values are eventually accessible. Not yet
replicated values are returned as non existing (null).
Write operations to already existing keys during this async phase can be lost since the vector clock for an entry
might not be initialized by another member yet and might be seen as an old update by other members.</p>
<p>The second way is to have a synchronous initial fill up which blocks every read or write access to the map until the
fill up operation is finished. This way should be used with caution since it might block your application from operation.</p>
<p><strong>Replication delay</strong></p>
<p>By default, the replication of values is delayed by 100 milliseconds when no current waiting replication is found. This is used
to collect multiple updates and to minimize the operations overhead on replication. A hard limit of 1000 replications
is built into the system to prevent <code>OutOfMemory</code> situations where you put lots of data into the replicated map in a really
short time.
The delay is configurable and a value of &quot;0&quot; means immediate replication. That way, you can configure the trade off between
replication overhead and time for the value to be replicated.</p>
<p><strong>Concurrency Level</strong></p>
<p>The concurrency level configuration is used to define the number of mutexes and segments inside the replicated map storage.
A mutex/segment is chosen by calculating the <code>hashCode</code> of the key and using module by the concurrency level. If multiple
keys fall into the same mutex ,they will have to wait for other mutex holders on the same mutex to finish their operation.</p>
<p>For high amount of values or high contention on the mutexes, this value might be interesting to be changed.</p>
<h3 id="in-memory-format-on-replicatedmap">In Memory Format on ReplicatedMap</h3>
<p>Currently two <code>in-memory-format</code> values are usable with the ReplicatedMap.</p>
<ul>
<li><p><code>OBJECT</code> (default): The data will be stored in deserialized form. This configuration is the default choice since
data replication is mostly used for high speed access. Please be aware that, changing values without a <code>Map::put</code> is
not reflected on other nodes but is visible on the changing nodes for later value accesses.</p>
</li>
<li><p><code>BINARY</code>: The data will be stored in serialized binary format and have to be deserialized on every request. This
option offers higher encapsulation since changes to values are always discarded as long as the newly changed object is
not explicitly <code>Map::put</code> into the map again.</p>
</li>
</ul>
<h3 id="entrylistener-on-replicatedmap">EntryListener on ReplicatedMap</h3>
<p>In general a <code>com.hazelcast.core.EntryListener</code> used on a ReplicatedMap serves the same purpose as it would on other
data structures in Hazelcast. You can use it to react on add, update, remove operations whereas eviction is not yet
supported by replicated maps.</p>
<p>The fundamental difference in behavior, compared to the other data structures, is that an EntryListener only reflects
changes on local data. Since replication is asynchronous, all listener events are fired only when an operation is finished
on a local node. With that in mind, events can fire at different times on different nodes.</p>
<pre><code class="lang-java">import com.hazelcast.core.EntryEvent;
import com.hazelcast.core.EntryListener;
import com.hazelcast.core.Hazelcast;
import com.hazelcast.core.HazelcastInstance;
import com.hazelcast.core.ReplicatedMap;

HazelcastInstance hazelcastInstance = Hazelcast.newHazelcastInstance();
ReplicatedMap&lt;String, Customer&gt; customers = hazelcastInstance.getReplicatedMap(&quot;customers&quot;);

customers.addEntryListener( new EntryListener&lt;String, Customer&gt;() {
  @Override
  public void entryAdded( EntryEvent&lt;String, Customer&gt; event ) {
    log( &quot;Entry added: &quot; + event );
  }

  @Override
  public void entryUpdated( EntryEvent&lt;String, Customer&gt; event ) {
    log( &quot;Entry updated: &quot; + event );
  }

  @Override
  public void entryRemoved( EntryEvent&lt;String, Customer&gt; event ) {
    log( &quot;Entry removed: &quot; + event );
  }

  @Override
  public void entryEvicted( EntryEvent&lt;String, Customer&gt; event ) {
    // Currently not supported, will never fire
  }
});

customers.put( &quot;1&quot;, new Customer( &quot;Joe&quot;, &quot;Smith&quot; ) ); // add event
customers.put( &quot;1&quot;, new Customer( &quot;Ali&quot;, &quot;Selam&quot; ) ); // update event
customers.remove( &quot;1&quot; ); // remove event
</code></pre>
<h1 id="distributed-events">Distributed Events</h1>
<p>Hazelcast allows you to register for entry events to get notified when events occurred. Event Listeners are cluster-wide so when a listener is registered in one member of cluster, it is actually registering for events originated at any member in the cluster. When a new member joins, events originated at the new member will also be delivered.</p>
<p>An Event is created only if there is a listener registered. If there is no listener registered, then no event will be created. If a predicate provided while registering the listener, predicate should be passed before sending the event to the listener (node/client).</p>
<p>As a rule of thumb, event listener should not implement heavy processes in its event methods which block the thread for long time. If needed, <code>ExecutorService</code> can be used to transfer long running processes to another thread and offload current listener thread.</p>
<h2 id="event-listeners">Event Listeners</h2>
<ul>
<li><strong>MembershipListener</strong> for cluster membership events</li>
<li><strong>DistributedObjectListener</strong> for distributed object creation and destroy events</li>
<li><strong>MigrationListener</strong> for partition migration start and complete events</li>
<li><strong>LifecycleListener</strong> for HazelcastInstance lifecycle events</li>
<li><strong>EntryListener</strong> for IMap and MultiMap entry events</li>
<li><strong>ItemListener</strong> for IQueue, ISet and IList item events (please refer to Event Registration and Configuration sections of <a href="#set">Set</a> and <a href="#list">List</a>).</li>
<li><strong>MessageListener</strong> for ITopic message events</li>
<li><strong>ClientListener</strong> for client connection events</li>
</ul>
<h2 id="global-event-configuration">Global Event Configuration</h2>
<ul>
<li><code>hazelcast.event.queue.capacity</code>: default value is 1000000</li>
<li><code>hazelcast.event.queue.timeout.millis</code>: default value is 250</li>
<li><code>hazelcast.event.thread.count</code>: default value is 5</li>
</ul>
<p>There is a striped executor in each node to control and dispatch received events to user. This striped executor also guarantees the order. For all events in Hazelcast, the order that events are generated and the order they are published to the user are guaranteed for given keys. For map and multimap, order is preserved for the operations on same key of the entry. For list, set, topic and queue, order is preserved for events on that instance of the distributed data structure.</p>
<p>Order guarantee is achieved by making only one thread responsible for a particular set of events (entry events of a key in a map, item events of a collection, etc.) in <code>StripedExecutor</code>.</p>
<p>If event queue reaches the capacity (<code>hazelcast.event.queue.capacity</code>) and last item cannot be put to the event queue for the period specified in  <code>hazelcast.event.queue.timeout.millis</code>, these events will be dropped with a warning message like &quot;EventQueue overloaded&quot;.</p>
<p>If listeners are doing a computation that requires a long time, this can cause event queue to reach its maximum capacity and lost of events. For map and multimap, <code>hazelcast.event.thread.count</code> can be configured to a higher value so that less collision occurs for keys, therefore worker threads will not block each other in <code>StripedExecutor</code>. For list, set,  topic and queue, heavy work should be offloaded to another thread. Notice that, in order to preserve order guarantee, the user should implement similar logic with <code>StripedExecutor</code> in offloaded thread pool.
<br> </br></p>
<p><strong><em>RELATED INFORMATION</em></strong></p>
<p><em>Please refer to <a href="#listener-configurations">Listener Configurations</a> section on how to configure each listener.</em></p>
<h1 id="distributed-computing">Distributed Computing</h1>
<h2 id="executor-service">Executor Service</h2>
<h3 id="executor-overview">Executor Overview</h3>
<p>One of the coolest features of Java 1.5 is the Executor framework, which allows you to asynchronously execute your tasks, logical units of works, such as database query, complex calculation, image rendering, etc.</p>
<p>The default implementation of this framework (ThreadPoolExecutor) is designed to run within a single JVM. In distributed systems, this implementation is not desired since you may want a task submitted in a JVM and processed in another one. Hazelcast offers IExecutorService to be used in distributed environments that implements <code>java.util.concurrent.ExecutorService</code>, to serve the applications requiring computational and data processing power.</p>
<p>With IExecutorService, you can execute tasks asynchronously and perform other useful things meanwhile. When ready, get the result and move on. If execution of the task takes longer than expected, you may consider canceling the task execution. In Java Executor framework, tasks are implemented as <code>java.util.concurrent.Callable</code> and <code>java.util.Runnable</code>. If you need to return a value and submit to Executor, Callable is used. Otherwise, Runnable is used (if you do not need to return a value). Naturally, tasks should be <code>Serializable</code> since they will be distributed.</p>
<h4 id="callable">Callable</h4>
<p>Below is a sample Callable.</p>
<pre><code class="lang-java">import com.hazelcast.core.HazelcastInstance;
import com.hazelcast.core.HazelcastInstanceAware;
import com.hazelcast.core.IMap;

import java.io.Serializable;
import java.util.concurrent.Callable;

public class SumTask
    implements Callable&lt;Integer&gt;, Serializable, HazelcastInstanceAware {

  private transient HazelcastInstance hazelcastInstance;

  public void setHazelcastInstance( HazelcastInstance hazelcastInstance ) {
    this.hazelcastInstance = hazelcastInstance;
  }

  public Integer call() throws Exception {
    IMap&lt;String, Integer&gt; map = hazelcastInstance.getMap( &quot;map&quot; );
    int result = 0;
    for ( String key : map.localKeySet() ) {
      System.out.println( &quot;Calculating for key: &quot; + key );
      result += map.get( key );
    }
    System.out.println( &quot;Local Result: &quot; + result );
    return result;
  }
}
</code></pre>
<p>Executing a task by using executor framework is very straight forward. Simply obtain an <code>ExecutorService</code> instance, generally via <code>Executors</code> and submit the task which returns a <code>Future</code>. After executing task, you do not have to wait for execution to complete, you can process other things and when ready use the <code>future</code> object to retrieve the result as shown in code below.</p>
<pre><code class="lang-java">ExecutorService executorService = Executors.newSingleThreadExecutor();
Future&lt;String&gt; future = executorService.submit( new Echo( &quot;myinput&quot; ) );
//while it is executing, do some useful stuff
//when ready, get the result of your execution
String result = future.get();
</code></pre>
<p>Please note that Echo callable in the very above sample also implements Serializable interface, since it may be sent to another JVM to be processed.</p>
<p><img src="images/NoteSmall.jpg" alt="image"> <strong><em>NOTE:</em></strong> <em>When a task is deserialized, HazelcastInstance needs to be accessed. To do this, the task should implement <code>HazelcastInstanceAware</code> interface. Please see <a href="#hazelcastinstanceaware-interface">HazelcastInstanceAware Interface</a> for more information.</em>
<br></br></p>
<h4 id="runnable">Runnable</h4>
<p>Let&#39;s now go with a sample that is Runnable. Below is a task that waits for some time and echoes a message.</p>
<pre><code class="lang-java">public class EchoTask implements Runnable, Serializable {
  private final String msg;

  public EchoTask( String msg ) {
    this.msg = msg;
  }

  @Override
  public void run() {
    try {
      Thread.sleep( 5000 );
    } catch ( InterruptedException e ) {
    }
    System.out.println( &quot;echo:&quot; + msg );
  }
}
</code></pre>
<p>Then let&#39;s write a class that submits and executes echo messages:</p>
<pre><code class="lang-java">public class MasterMember {
  public static void main( String[] args ) throws Exception {
    HazelcastInstance hazelcastInstance = Hazelcast.newHazelcastInstance();
    IExecutorService executor = hazelcastInstance.getExecutorService( &quot;exec&quot; );
    for ( int k = 1; k &lt;= 1000; k++ ) {
      Thread.sleep( 1000 );
      System.out.println( &quot;Producing echo task: &quot; + k );
      executor.execute( new EchoTask( String.valueOf( k ) ) );
    }
    System.out.println( &quot;EchoTaskMain finished!&quot; );
  }
}
</code></pre>
<p>Above, Executor is retrieved from HazelcastInstance and 1000 echo tasks are submitted.</p>
<h4 id="executor-thread-configuration">Executor Thread Configuration</h4>
<p>By default, Executor is configured to have 8 threads in the pool. It can be changed through the <code>pool-size</code> property using declarative configuration (<code>hazelcast.xml</code>). A sample is shown below (using above Executor).</p>
<pre><code class="lang-xml">&lt;executor-service name=&quot;exec&quot;&gt;
  &lt;pool-size&gt;1&lt;/pool-size&gt;
&lt;/executor-service&gt;
</code></pre>
<h4 id="scaling">Scaling</h4>
<p>Executor service can be scaled both vertically (scale up) and horizontally (scale out).</p>
<p>To scale up, processing capacity of the JVM should be improved. This can be done by increasing the <code>pool-size</code> property mentioned in the previous subsection (i.e., increasing the thread count). However, please be aware of your JVM&#39;s capacity. If you think it cannot handle such additional load caused by increasing the thread count, you may want to consider improving the JVM&#39;s resources (CPU, memory, etc.). As an example, please set the <code>pool-size</code> to 5 and run the above <code>MasterMember</code>. You will see that <code>EchoTask</code> is run as soon as it is produced.</p>
<p>To scale out, more JVMs should be added instead of increasing only one JVM&#39;s capacity. In reality, you may want to expand your cluster by adding more physical or virtual machines. For the EchoTask sample above, you can simply create another Hazelcast instance. It will automatically get involved in the executions started in <code>MasterMember</code> and start processing.</p>
<h3 id="execution">Execution</h3>
<p>Distributed executor service is a distributed implementation of <code>java.util.concurrent.ExecutorService</code>. It allows you to execute your code in the cluster. In this section, all the code samples are based on the Echo class above. Please note that Echo class is <code>Serializable</code>. You can ask Hazelcast to execute your code (<code>Runnable, Callable</code>);</p>
<ul>
<li>on a specific cluster member you choose,</li>
<li>on the member owning the key you choose,</li>
<li>on the member Hazelcast will pick, and</li>
<li>on all or subset of the cluster members.</li>
</ul>
<pre><code class="lang-java">import com.hazelcast.core.Member;
import com.hazelcast.core.Hazelcast;
import com.hazelcast.core.IExecutorService;
import java.util.concurrent.Callable;
import java.util.concurrent.Future;   
import java.util.Set;

public void echoOnTheMember( String input, Member member ) throws Exception {
  Callable&lt;String&gt; task = new Echo( input );
  HazelcastInstance hazelcastInstance = Hazelcast.newHazelcastInstance();
  IExecutorService executorService = 
      hazelcastInstance.getExecutorService( &quot;default&quot; );

  Future&lt;String&gt; future = executorService.submitToMember( task, member );
  String echoResult = future.get();
}

public void echoOnTheMemberOwningTheKey( String input, Object key ) throws Exception {
  Callable&lt;String&gt; task = new Echo( input );
  HazelcastInstance hazelcastInstance = Hazelcast.newHazelcastInstance();
  IExecutorService executorService =
      hazelcastInstance.getExecutorService( &quot;default&quot; );

  Future&lt;String&gt; future = executorService.submitToKeyOwner( task, key );
  String echoResult = future.get();
}

public void echoOnSomewhere( String input ) throws Exception { 
  HazelcastInstance hazelcastInstance = Hazelcast.newHazelcastInstance();
  IExecutorService executorService =
      hazelcastInstance.getExecutorService( &quot;default&quot; );

  Future&lt;String&gt; future = executorService.submit( new Echo( input ) );
  String echoResult = future.get();
}

public void echoOnMembers( String input, Set&lt;Member&gt; members ) throws Exception {
  HazelcastInstance hazelcastInstance = Hazelcast.newHazelcastInstance();
  IExecutorService executorService = 
      hazelcastInstance.getExecutorService( &quot;default&quot; );

  Map&lt;Member, Future&lt;String&gt;&gt; futures = executorService
      .submitToMembers( new Echo( input ), members );

  for ( Future&lt;String&gt; future : futures.values() ) {
    String echoResult = future.get();
    // ...
  }
}
</code></pre>
<p><img src="images/NoteSmall.jpg" alt="image"> <strong><em>NOTE:</em></strong> <em>You can obtain the set of cluster members via <code>HazelcastInstance#getCluster().getMembers()</code> call.</em></p>
<h3 id="execution-cancellation">Execution Cancellation</h3>
<p>What if the code you execute in cluster takes longer than expected. If you cannot stop/cancel that task, it will keep eating your resources. Standard Java executor framework solves this problem with by introducing <code>cancel()</code> API and &quot;encouraging&quot; us to code and design for cancellations, which is highly ignored part of software development.</p>
<pre><code class="lang-java">public class Fibonacci&lt;Long&gt; implements Callable&lt;Long&gt;, Serializable {
  int input = 0; 

  public Fibonacci() { 
  } 

  public Fibonacci( int input ) { 
    this.input = input;
  } 

  public Long call() {
    return calculate( input );
  }

  private long calculate( int n ) {
    if ( Thread.currentThread().isInterrupted() ) {
      return 0;
    }
    if ( n &lt;= 1 ) {
      return n;
    } else {
      return calculate( n - 1 ) + calculate( n - 2 );
    }
  }
}
</code></pre>
<p>The callable class above calculates the Fibonacci number for a given number. In the <code>calculate</code> method, we are checking to see if the current thread is interrupted so that code can be responsive to cancellations once the execution is started. Below <code>fib()</code> method submits the Fibonacci calculation task for number &#39;n&#39; and waits maximum 3 seconds for result. If the execution does not completed in 3 seconds, <code>future.get()</code> will throw <code>TimeoutException</code> and upon catching it, we cancel the execution for saving some CPU cycles.</p>
<pre><code class="lang-java">long fib( int n ) throws Exception {
  HazelcastInstance hazelcastInstance = Hazelcast.newHazelcastInstance();
  IExecutorService es = hazelcastInstance.getExecutorService();
  Future future = es.submit( new Fibonacci( n ) );  
  try {
    return future.get( 3, TimeUnit.SECONDS );
  } catch ( TimeoutException e ) {
    future.cancel( true );            
  }
  return -1;
}
</code></pre>
<p><code>fib(20)</code> will probably take less than 3 seconds but, <code>fib(50)</code> will take way longer. (This is not the example for writing better Fibonacci calculation code, but for showing how to cancel a running execution that takes too long). The method <code>future.cancel(false)</code> can only cancel execution before it is running (executing), but <code>future.cancel(true)</code> can interrupt running executions if your code is able to handle the interruption. So, if you are willing to be able to cancel already running task, then your task has to be designed to handle interruption. If <code>calculate (int n)</code> method did not have <code>(Thread.currentThread().isInterrupted())</code> line, then you would not be able to cancel the execution after it is started.</p>
<h3 id="execution-callback">Execution Callback</h3>
<p><code>ExecutionCallback</code> offered by Hazelcast allows you to asynchronously get notified when the execution is done. </p>
<p>Let&#39;s use the Fibonacci series to explain this. Below sample code is the calculation.</p>
<pre><code class="lang-java">public class Fibonacci&lt;Long&gt; implements Callable&lt;Long&gt;, Serializable {
  int input = 0;

  public Fibonacci() {
  }

  public Fibonacci( int input ) {
    this.input = input;
  }

  public Long call() {
    return calculate( input );
  }

  private long calculate( int n ) {
    if (n &lt;= 1) {
      return n;
    } else {
      return calculate( n - 1 ) + calculate( n - 2 );
    }
  }
}
</code></pre>
<p>And, below sample code prints the result asynchronously.</p>
<pre><code class="lang-java">import com.hazelcast.core.Hazelcast;
import com.hazelcast.core.ExecutionCallback;
import com.hazelcast.core.IExecutorService;
import java.util.concurrent.Future;

HazelcastInstance hazelcastInstance = Hazelcast.newHazelcastInstance();
IExecutorService es = hazelcastInstance.getExecutorService();
Callable&lt;Long&gt; task = new Fibonacci( 10 );

es.submit(task, new ExecutionCallback&lt;Long&gt; () {

  @Override
  public void onResponse( Long response ) {
    System.out.println( &quot;Fibonacci calculation result = &quot; + response );
  }

  @Override
  public void onFailure( Throwable t ) {
    t.printStackTrace();
  }
};
</code></pre>
<p>As it can be seen, <code>ExecutionCallback</code> has the methods <code>onResponse</code> and <code>onFailure</code>. The former one in the above code is called upon a valid response and prints the calculation result, whereas the latter one is called upon a failure and prints the stacktrace.</p>
<h2 id="entry-processor">Entry Processor</h2>
<h3 id="entry-processor-overview">Entry Processor Overview</h3>
<p>Hazelcast supports entry processing. Entry processor is a function that executes your code on a map entry in an atomic way. </p>
<p>Entry processor enables fast in-memory operations on a map without having to worry about locks or concurrency issues. It can be applied to a single map entry or on all map entries and supports choosing target entries using predicates. You do not need any explicit lock on entry. Practically, Hazelcast locks the entry, runs the EntryProcessor, and then unlocks the entry.</p>
<p>Hazelcast sends the entry processor to each cluster member and these members apply it to map entries. So, if you add more members, your processing is completed faster.</p>
<p>If entry processing is the major operation for a map and the map consists of complex objects, then using <code>OBJECT</code> as <code>in-memory-format</code> is recommended to minimize serialization cost. By default, the entry value is stored as a byte array (<code>BINARY</code> format), but when it is stored as an object (OBJECT format), then entry processor is applied directly on the object. In that case, no serialization or deserialization is performed. But if there is a defined event listener, new entry value will be serialized when passing to event publisher service.</p>
<p><img src="images/NoteSmall.jpg" alt="image"> <strong><em>NOTE</em></strong>: <em>When <code>in-memory-format</code> is <code>OBJECT</code>, old value of the updated entry will be null.</em></p>
<p>There are below methods in IMap interface for entry processing:</p>
<pre><code class="lang-java">/**
 * Applies the user defined EntryProcessor to the entry mapped by the key.
 * Returns the the object which is result of the process() method of EntryProcessor.
 */
Object executeOnKey( K key, EntryProcessor entryProcessor );

/**
 * Applies the user defined EntryProcessor to the entries mapped by the collection of keys.
 * the results mapped by each key in the collection.
 */
Map&lt;K, Object&gt; executeOnKeys( Set&lt;K&gt; keys, EntryProcessor entryProcessor );

/**
 * Applies the user defined EntryProcessor to the entry mapped by the key with
 * specified ExecutionCallback to listen event status and returns immediately.
 */
void submitToKey( K key, EntryProcessor entryProcessor, ExecutionCallback callback );


/**
 * Applies the user defined EntryProcessor to the all entries in the map.
 * Returns the results mapped by each key in the map.
 */
Map&lt;K, Object&gt; executeOnEntries( EntryProcessor entryProcessor );

/**
 * Applies the user defined EntryProcessor to the entries in the map which satisfies 
 provided predicate.
 * Returns the results mapped by each key in the map.
 */
Map&lt;K, Object&gt; executeOnEntries( EntryProcessor entryProcessor, Predicate predicate );
</code></pre>
<p>And, here is the EntryProcessor interface:</p>
<pre><code class="lang-java">public interface EntryProcessor&lt;K, V&gt; extends Serializable {
  Object process( Map.Entry&lt;K, V&gt; entry );

  EntryBackupProcessor&lt;K, V&gt; getBackupProcessor();
}
</code></pre>
<p><img src="images/NoteSmall.jpg" alt="image"> <strong><em>NOTE</em></strong>: <em>If you want to execute a task on a single key, you can also use <code>executeOnKeyOwner</code> provided by Executor Service. But, in this case, you need to perform a lock and serialization.</em></p>
<p>When using <code>executeOnEntries</code> method, if the number of entries is high and you do need the results, then returning null in <code>process()</code> method is a good practice. By this way, results of the processing is not stored in the map and hence out of memory errors are eliminated.</p>
<p>If your code is modifying the data, then you should also provide a processor for backup entries:</p>
<pre><code class="lang-java">public interface EntryBackupProcessor&lt;K, V&gt; extends Serializable {
    void processBackup( Map.Entry&lt;K, V&gt; entry );
}
</code></pre>
<p>This is required to prevent the primary map entries from having different values than backups. Because entry processor is applied both on primary and backup entries.</p>
<p><img src="images/NoteSmall.jpg" alt="image"> <strong><em>NOTE</em></strong>: <em>You should explicitly call <code>setValue</code> method of <code>Map.Entry</code> when modifying data in Entry Processor. Otherwise, Entry Processor will be accepted as read-only.</em></p>
<h3 id="sample-entry-processor-code">Sample Entry Processor Code</h3>
<pre><code class="lang-java">public class EntryProcessorTest {

  @Test
  public void testMapEntryProcessor() throws InterruptedException {
    Config config = new Config().getMapConfig( &quot;default&quot; )
        .setInMemoryFormat( MapConfig.InMemoryFormat.OBJECT );

    HazelcastInstance hazelcastInstance1 = Hazelcast.newHazelcastInstance( config );
    HazelcastInstance hazelcastInstance2 = Hazelcast.newHazelcastInstance( config );
    IMap&lt;Integer, Integer&gt; map = hazelcastInstance1.getMap( &quot;mapEntryProcessor&quot; );
    map.put( 1, 1 );
    EntryProcessor entryProcessor = new IncrementingEntryProcessor();
    map.executeOnKey( 1, entryProcessor );
    assertEquals( map.get( 1 ), (Object) 2 );
    hazelcastInstance1.getLifecycleService().shutdown();
    hazelcastInstance2.getLifecycleService().shutdown();
  }

  @Test
  public void testMapEntryProcessorAllKeys() throws InterruptedException {
    StaticNodeFactory factory = new StaticNodeFactory( 2 );
    Config config = new Config().getMapConfig( &quot;default&quot; )
        .setInMemoryFormat( MapConfig.InMemoryFormat.OBJECT );

    HazelcastInstance hazelcastInstance1 = factory.newHazelcastInstance( config );
    HazelcastInstance hazelcastInstance2 = factory.newHazelcastInstance( config );
    IMap&lt;Integer, Integer&gt; map = hazelcastInstance1
        .getMap( &quot;mapEntryProcessorAllKeys&quot; );

    int size = 100;
    for ( int i = 0; i &lt; size; i++ ) {
      map.put( i, i );
    }
    EntryProcessor entryProcessor = new IncrementingEntryProcessor();
    Map&lt;Integer, Object&gt; res = map.executeOnEntries( entryProcessor );
    for ( int i = 0; i &lt; size; i++ ) {
      assertEquals( map.get( i ), (Object) (i + 1) );
    }
    for ( int i = 0; i &lt; size; i++ ) {
      assertEquals( map.get( i ) + 1, res.get( i ) );
    }
    hazelcastInstance1.getLifecycleService().shutdown();
    hazelcastInstance2.getLifecycleService().shutdown();
  }

  static class IncrementingEntryProcessor
      implements EntryProcessor, EntryBackupProcessor, Serializable {

    public Object process( Map.Entry entry ) {
      Integer value = (Integer) entry.getValue();
      entry.setValue( value + 1 );
      return value + 1;
    }

    public EntryBackupProcessor getBackupProcessor() {
      return IncrementingEntryProcessor.this;
    }

    public void processBackup( Map.Entry entry ) {
      entry.setValue( (Integer) entry.getValue() + 1 );
    }
  }
}
</code></pre>
<h3 id="abstract-entry-processor">Abstract Entry Processor</h3>
<p><code>AbstractEntryProcessor</code> class can be used when the same processing will be performed both on primary and backup map entries (i.e. same logic applies to them). If <code>EntryProcessor</code> is used, you need to apply the same logic to backup entries separately. <code>AbstractEntryProcessor</code> class brings an easiness on this primary/backup processing.</p>
<p>Please see below sample code.</p>
<pre><code class="lang-java">public abstract class AbstractEntryProcessor &lt;K, V&gt;
    implements EntryProcessor &lt;K, V&gt; {

  private final EntryBackupProcessor &lt;K,V&gt; entryBackupProcessor;
  public AbstractEntryProcessor() {
    this(true);
  }

  public AbstractEntryProcessor(boolean applyOnBackup) {
    if ( applyOnBackup ) {
      entryBackupProcessor = new EntryBackupProcessorImpl();
    } else {
      entryBackupProcessor = null;
    }
  } 

  @Override
  public abstract Object process(Map.Entry&lt;K, V&gt; entry);

  @Override
  public final EntryBackupProcessor &lt;K, V&gt; getBackupProcessor() {
    return entryBackupProcessor;
  }

  private class EntryBackupProcessorImpl implements EntryBackupProcessor &lt;K,V&gt;{
    @Override
    public void processBackup(Map.Entry&lt;K, V&gt; entry) {
      process(entry); 
    }
  }    
}
</code></pre>
<p>In the above sample, the method <code>getBackupProcessor</code> returns an <code>EntryBackupProcessor</code> instance. This means, the same processing will be applied to both primary and backup entries. If you want to apply the processing only on the primary entries, then <code>getBackupProcessor</code> method should return null. </p>
<h1 id="distributed-query">Distributed Query</h1>
<h2 id="query-overview">Query Overview</h2>
<p>Hazelcast partitions your data and spreads across cluster of servers. You can surely iterate over the map entries and look for certain entries (specified by predicates) you are interested in but this is not very efficient as you will have to bring entire entry set and iterate locally. Instead, Hazelcast allows you to run distributed queries on your distributed map.</p>
<h4 id="how-it-works">How It Works</h4>
<ul>
<li>Requested predicate is sent to each member in the cluster.</li>
<li>Each member looks at its own local entries and filters them according to the predicate. At this stage, key/value pairs of the entries are deserialized and then passed to the predicate.</li>
<li>Then the predicate requester merges all the results come from each member into a single set.</li>
</ul>
<p>If you add new members to the cluster, partition count for each member is reduced and hence the time spent by each member on iterating its entries is reduced, too. So, the above querying approach is highly scalable. Another reason for being highly scalable is that, it is the pool of partition threads that evaluates the entries concurrently in each member. And, as you can guess, the network traffic is also reduced since only filtered data is sent to the requester.</p>
<p>Hazelcast offers below APIs for distributed query purposes:</p>
<ul>
<li>Criteria API</li>
<li>Distributed SQL Query
<br></br></li>
</ul>
<p>Assume that you have an &quot;employee&quot; map containing values of <code>Employee</code> objects, as coded below.</p>
<pre><code class="lang-java">import java.io.Serializable;

public class Employee implements Serializable {
private String name;
private int age;
private boolean active;
private double salary;

public Employee(String name, int age, boolean live, double price) {
    this.name = name;
    this.age = age;
    this.active = live;
    this.salary = price;
}

public Employee() {
}

public String getName() {
    return name;
}

public int getAge() {
    return age;
}

public double getSalary() {
    return salary;
}

public boolean isActive() {
    return active;
}
}
</code></pre>
<p>Now, let&#39;s look for the employees who are active and with age less than 30 using the aforementioned APIs (Criteria API and Distributed SQL Query). Below subsections describes each query mechanism for this sample.</p>
<h3 id="criteria-api">Criteria API</h3>
<p>Criteria API is a programming interface offered by Hazelcast similar to Java Persistence Query Language (JPQL). Below is the code
for the above sample query.</p>
<pre><code class="lang-java">import com.hazelcast.core.IMap;
import com.hazelcast.query.Predicate;
import com.hazelcast.query.PredicateBuilder;
import com.hazelcast.query.EntryObject;
import com.hazelcast.config.Config;

IMap&lt;String, Employee&gt; map = hazelcastInstance.getMap( &quot;employee&quot; );

EntryObject e = new PredicateBuilder().getEntryObject();
Predicate predicate = e.is( &quot;active&quot; ).and( e.get( &quot;age&quot; ).lessThan( 30 ) );

Set&lt;Employee&gt; employees = map.values( predicate );
</code></pre>
<p>In the above sample, <code>predicate</code> verifies whether the entry is active and its <code>age</code> value is less than 30. This <code>predicate</code> is
applied to the <code>employee</code> map using the <code>map.values(predicate)</code> method. This method sends the predicate to all cluster members
and merges the results coming from them. As you can guess, since the predicate is communicated between the members, it needs to
be serializable.</p>
<p><img src="images/NoteSmall.jpg" alt="image"><strong><em>NOTE:</em></strong> <em>Predicates can also be applied to <code>keySet</code>, <code>entrySet</code> and <code>localKeySet</code> of Hazelcast distributed 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;map.</em></p>
<h4 id="predicates-class">Predicates Class</h4>
<p><code>Predicates</code> class offered by Hazelcast includes a lot of operators that will meet your query requirements. Some of them are
explained below.</p>
<ul>
<li><code>equal</code>: checks if the result of an expression is equal to a given value.</li>
<li><code>notEqual</code>: checks if the result of an expression is not equal to a given value.</li>
<li><code>instanceOf</code>: checks if the result of an expression has a certain type</li>
<li><code>like</code>: checks if the result of an expression matches some string pattern. % (percentage sign) is placeholder for many
characters,  (underscore) is placeholder for only one character.</li>
<li><code>greaterThan</code>: checks if the result of an expression is greater than a certain value.</li>
<li><code>greaterEqual</code>: checks if the result of an expression is greater or equal than a certain value.</li>
<li><code>lessThan</code>: checks if the result of an expression is less than a certain value</li>
<li><code>lessEqual</code>: checks if the result of an expression is than than or equal to a certain value.</li>
<li><code>between</code>: checks if the result of an expression is between 2 values (this is inclusive).</li>
<li><code>in</code>: checks if the result of an expression is an element of a certain collection.</li>
<li><code>isNot</code>: checks if the result of an expression is false.</li>
<li><code>regex</code>: checks if the result of an expression matches some regular expression.
<br></br></li>
</ul>
<p><strong><em>RELATED INFORMATION:</em></strong> <em>Please see
<a href="https://github.com/hazelcast/hazelcast/blob/2709bc81cd499a3160827de24422cdb6cf98fe36/hazelcast/src/main/java/com/hazelcast/query/Predicates.java">Predicates</a>
class for all predicates provided.</em></p>
<h4 id="joining-predicates-with-and-or-not">Joining Predicates with AND, OR, NOT</h4>
<p>Predicates can be joined using the <code>and</code>, <code>or</code> and <code>not</code> operators, as shown in the below examples.</p>
<pre><code class="lang-java">public Set&lt;Person&gt; getWithNameAndAge( String name, int age ) {
  Predicate namePredicate = Predicates.equal( &quot;name&quot;, name );
  Predicate agePredicate = Predicates.equal( &quot;age&quot;, age );
  Predicate predicate = Predicates.and( namePredicate, agePredicate );
  return personMap.values( predicate );
}
</code></pre>
<pre><code class="lang-java">public Set&lt;Person&gt; getWithNameOrAge( String name, int age ) {
  Predicate namePredicate = Predicates.equal( &quot;name&quot;, name );
  Predicate agePredicate = Predicates.equal( &quot;age&quot;, age );
  Predicate predicate = Predicates.or( namePredicate, agePredicate );
  return personMap.values( predicate );
}
</code></pre>
<pre><code class="lang-java">public Set&lt;Person&gt; getNotWithName( String name ) {
  Predicate namePredicate = Predicates.equal( &quot;name&quot;, name );
  Predicate predicate = Predicates.not( namePredicate );
  return personMap.values( predicate );
}
</code></pre>
<h4 id="predicatebuilder">PredicateBuilder</h4>
<p>Predicate usage can be simplified using the <code>PredicateBuilder</code> class. It offers a more simpler predicate building. Please see the
below sample code which which selects all people with a certain name and age.</p>
<pre><code class="lang-java">public Set&lt;Person&gt; getWithNameAndAgeSimplified( String name, int age ) {
  EntryObject e = new PredicateBuilder().getEntryObject();
  Predicate agePredicate = e.get( &quot;age&quot; ).equal( age );
  Predicate predicate = e.get( &quot;name&quot; ).equal( name ).and( agePredicate );
  return personMap.values( predicate );
}
</code></pre>
<h3 id="distributed-sql-query">Distributed SQL Query</h3>
<p><code>com.hazelcast.query.SqlPredicate</code> takes regular SQL <code>where</code> clause. Here is an example:</p>
<pre><code class="lang-java">IMap&lt;Employee&gt; map = hazelcastInstance.getMap( &quot;employee&quot; );
Set&lt;Employee&gt; employees = map.values( new SqlPredicate( &quot;active AND age &lt; 30&quot; ) );
</code></pre>
<h4 id="supported-sql-syntax-">Supported SQL syntax:</h4>
<p><strong>AND/OR:</strong> <code>&lt;expression&gt; AND &lt;expression&gt; AND &lt;expression&gt;...</code></p>
<ul>
<li><code>active AND age&gt;30</code></li>
<li><code>active=false OR age = 45 OR name = &#39;Joe&#39;</code></li>
<li><code>active AND ( age &gt; 20 OR salary &lt; 60000 )</code></li>
</ul>
<p><strong>Equality:</strong> <code>=, !=, &lt;, &lt;=, &gt;, &gt;=</code></p>
<ul>
<li><code>&lt;expression&gt; = value</code></li>
<li><code>age &lt;= 30</code></li>
<li><code>name = &quot;Joe&quot;</code></li>
<li><code>salary != 50000</code></li>
</ul>
<p><strong>BETWEEN: </strong> <code>&lt;attribute&gt; [NOT] BETWEEN &lt;value1&gt; AND &lt;value2&gt;</code></p>
<ul>
<li><code>age BETWEEN 20 AND 33 ( same as age &gt;= 20  AND age &lt;= 33 )</code></li>
<li><code>age NOT BETWEEN 30 AND 40 ( same as age &lt; 30 OR age &gt; 40 )</code></li>
</ul>
<p><strong>LIKE:</strong> <code>&lt;attribute&gt; [NOT] LIKE &#39;expression&#39;</code></p>
<p>The <code>%</code> (percentage sign) is placeholder for multiple characters, an <code>_</code> (underscore) is placeholder for only one character.</p>
<ul>
<li><code>name LIKE &#39;Jo%&#39;</code> (true for &#39;Joe&#39;, &#39;Josh&#39;, &#39;Joseph&#39; etc.)</li>
<li><code>name LIKE &#39;Jo_&#39;</code> (true for &#39;Joe&#39;; false for &#39;Josh&#39;)</li>
<li><code>name NOT LIKE &#39;Jo_&#39;</code> (true for &#39;Josh&#39;; false for &#39;Joe&#39;)</li>
<li><code>name LIKE &#39;J_s%&#39;</code> (true for &#39;Josh&#39;, &#39;Joseph&#39;; false &#39;John&#39;, &#39;Joe&#39;)</li>
</ul>
<p><strong>IN:</strong> <code>&lt;attribute&gt; [NOT] IN (val1, val2,...)</code></p>
<ul>
<li><code>age IN ( 20, 30, 40 )</code></li>
<li><code>age NOT IN ( 60, 70 )</code></li>
<li><code>active AND ( salary &gt;= 50000 OR ( age NOT BETWEEN 20 AND 30 ) )</code></li>
<li><code>age IN ( 20, 30, 40 ) AND salary BETWEEN ( 50000, 80000 )</code></li>
</ul>
<h3 id="paging-predicate-order-limit-">Paging Predicate (Order &amp; Limit)</h3>
<p>Hazelcast provides paging for defined predicates. For this purpose, <code>PagingPredicate</code> class has been developed. You may want to
get collection of keys, values or entries page by page, by filtering them with predicates and giving the size of pages. Also, you
can sort the entries by specifying comparators.</p>
<p>Below is a sample code where the <code>greaterEqual</code> predicate is used to get values from &quot;students&quot; map. This predicate puts a filter
such that the objects with value of &quot;age&quot; is greater than or equal to 18 will be retrieved. Then, a <code>PagingPredicate</code> is
constructed in which the page size is 5. So, there will be 5 objects in each page.</p>
<p>The first time the values are called will constitute the first page. You can get the subsequent pages by using the <code>nextPage()</code>
method of <code>PagingPredicate</code> and querying the map again with updated <code>PagingPredicate</code>.</p>
<pre><code class="lang-java">IMap&lt;Integer, Student&gt; map = hazelcastInstance.getMap( &quot;students&quot; );
Predicate greaterEqual = Predicates.greaterEqual( &quot;age&quot;, 18 );
PagingPredicate pagingPredicate = new PagingPredicate( greaterEqual, 5 );
// Retrieve the first page
Collection&lt;Student&gt; values = map.values( pagingPredicate );
...
// Set up next page
pagingPredicate.nextPage();
// Retrieve next page
values = map.values( pagingPredicate );
...
</code></pre>
<p>If a comparator is not specified for <code>PagingPredicate</code> and when you want to get collection of keys or values page by page, this collection must be an instance of <code>Comparable</code> (i.e. it must implement <code>java.lang.Comparable</code>). Otherwise, <code>java.lang.IllegalArgument</code> exception is thrown.</p>
<p>Paging Predicate is not supported in Transactional Context.
<br></br></p>
<p><strong><em>RELATED INFORMATION</em></strong></p>
<p><em>Please refer to the <a href="http://hazelcast.org/docs/latest/javadoc/com/hazelcast/query/Predicates.html">Javadoc</a> for all
predicates.</em></p>
<h3 id="indexing">Indexing</h3>
<p>Hazelcast distributed queries will run on each member in parallel and only results will return the conn. When a query runs on a
member, Hazelcast will iterate through the entire owned entries and find the matching ones. This can be made faster by indexing
the mostly queried fields. Just like you would do for your database. Of course, indexing will add overhead for each <code>write</code>
operation but queries will be a lot faster. If you are querying your map a lot, make sure to add indexes for most frequently
queried fields. So, if your <code>active and age &lt; 30</code> query, for example, is used a lot, make sure you add index for <code>active</code> and
<code>age</code> fields. Here is how:</p>
<pre><code class="lang-java">IMap map = hazelcastInstance.getMap( &quot;employees&quot; );
// ordered, since we have ranged queries for this field
map.addIndex( &quot;age&quot;, true );
// not ordered, because boolean field cannot have range
map.addIndex( &quot;active&quot;, false );
</code></pre>
<p><code>IMap.addIndex(fieldName, ordered)</code> is used for adding index. For each indexed field, if you have ranged queries such as <code>age&gt;30</code>,
<code>age BETWEEN 40 AND 60</code>, then <code>ordered</code> parameter should be <code>true</code>. Otherwise, set it to <code>false</code>.</p>
<p>Also, you can define <code>IMap</code> indexes in configuration, a sample of which is shown below.</p>
<pre><code class="lang-xml">&lt;map name=&quot;default&quot;&gt;
  ...
  &lt;indexes&gt;
    &lt;index ordered=&quot;false&quot;&gt;name&lt;/index&gt;
    &lt;index ordered=&quot;true&quot;&gt;age&lt;/index&gt;
  &lt;/indexes&gt;
&lt;/map&gt;
</code></pre>
<p>This sample in programmatic configuration looks like below.</p>
<pre><code class="lang-java">mapConfig.addMapIndexConfig( new MapIndexConfig( &quot;name&quot;, false ) );
mapConfig.addMapIndexConfig( new MapIndexConfig( &quot;age&quot;, true ) );
</code></pre>
<p>And, the following is the Spring declarative configuration for the same sample.</p>
<pre><code class="lang-xml">&lt;hz:map name=&quot;default&quot;&gt;
  &lt;hz:indexes&gt;
    &lt;hz:index attribute=&quot;name&quot;/&gt;
    &lt;hz:index attribute=&quot;age&quot; ordered=&quot;true&quot;/&gt;
  &lt;/hz:indexes&gt;
&lt;/hz:map&gt;
</code></pre>
<p><br></br>
<img src="images/NoteSmall.jpg" alt="image"> <strong><em>NOTE:</em></strong> <em>Non-primitive types to be indexed should implement </em><code>Comparable</code><em>.</em></p>
<h3 id="query-thread-configuration">Query Thread Configuration</h3>
<p>Size of the thread pool dedicated to query operations can be changed using the <code>pool-size</code> property. Below is a sample declarative configuration.</p>
<pre><code class="lang-xml">&lt;executor-service name=&quot;hz:query&quot;&gt;
  &lt;pool-size&gt;100&lt;/pool-size&gt;
&lt;/executor-service&gt;
</code></pre>
<p>And, below is the programmatic configuration equivalent to the sample above.</p>
<pre><code class="lang-java">Config cfg = new Config();
cfg.getExecutorConfig(&quot;hz:query&quot;).setPoolSize(100);
</code></pre>
<h2 id="mapreduce">MapReduce</h2>
<p>You have heard about MapReduce ever since Google released its <a href="http://research.google.com/archive/mapreduce.html">research white paper</a> on this concept. With Hadoop as the most common and well known implementation, MapReduce gained a broad audience and made it into all kinds of business applications dominated by data warehouses.</p>
<p>From what we see at the white paper, MapReduce is a software framework for processing large amounts of data in a distributed way. Therefore, the processing is normally spread over several machines. The basic idea behind MapReduce is to map your source data into a collection of key-value pairs and reducing those pairs, grouped by key, in a second
step towards the final result.</p>
<p>The main idea can be summarized with below 3 simple steps.</p>
<ol>
<li>Read source data</li>
<li>Map data to one or multiple key-value pairs</li>
<li>Reduce all pairs with the same key</li>
</ol>
<p><strong>Use Cases</strong></p>
<p>The best known examples for MapReduce algorithms are text processing tools like counting the word frequency in large texts or websites. Apart from that, there are more interesting example use cases as listed below.</p>
<ul>
<li>Log Analysis</li>
<li>Data Querying</li>
<li>Aggregation and summing</li>
<li>Distributed Sort</li>
<li>ETL (Extract Transform Load)</li>
<li>Credit and Risk management</li>
<li>Fraud detection</li>
<li>and more...</li>
</ul>
<h3 id="mapreduce-essentials">MapReduce Essentials</h3>
<p>This section will give a deeper insight on the MapReduce pattern and help to understand the semantics behind the different MapReduce phases and how they are implemented in Hazelcast.</p>
<p>In addition to this, there are hints in the sections which compare Hadoop and Hazelcast MapReduce implementation to help adopters with Hadoop background to quickly get familiar with their new target.</p>
<h4 id="mapreduce-workflow-example">MapReduce Workflow Example</h4>
<p>Below flowchart demonstrates a basic workflow of the already mentioned word count example (distributed occurrences analysis). From left to right, it iterates over all entries of a data structure (in this case an IMap). In the mapping phase, it splits the sentence in single words and emits a key-value pair per word with the word as a key and 1 as the value. In the next phase, values are collected (grouped) and transported to their
corresponding reducers where they are eventually reduced to a single key-value pair with the value as the number of occurrences of the word. As the last step, the different reducer results are grouped up to the final result and returned to the requester.</p>
<p><img src="images/mapreduce_workflow_small.png" alt=""></p>
<p>In pseudo code, the corresponding map and reduce function would look like the following. Hazelcast code example will be shown in the next section.</p>
<pre><code class="lang-plain">map( key:String, document:String ):Void -&gt;
  for each w:word in document:
    emit( w, 1 )

reduce( word:String, counts:List[Int] ):Int -&gt;
  return sum( counts )
</code></pre>
<h4 id="mapreduce-phases">MapReduce Phases</h4>
<p>As seen in the workflow example, a MapReduce process consists of multiple phases. The original MapReduce pattern describes two phases (map, reduce) and one optional phase (combine). In Hazelcast, these phases are either only existing virtually to explain the data flow or are executed in parallel during the real operation while the general idea is still persisting.</p>
<p>(K x V)* -&gt; (L x W)*</p>
<p>[(k<em>1</em>, v<em>1</em>), ..., (k<em>n</em>, v<em>n</em>)] -&gt; [(l<em>1</em>, w<em>1</em>), ..., (l<em>m</em>, w<em>m</em>)]</p>
<p><strong>Mapping Phase</strong></p>
<p>The mapping phase iterates all key-value pairs of any kind of legal input source. The mapper then analyzes the input pairs and emits zero or more new key-value pairs.</p>
<p>K x V -&gt; (L x W)*</p>
<p>(k, v) -&gt; [(l<em>1</em>, w<em>1</em>), ..., (l<em>n</em>, w<em>n</em>)]</p>
<p><strong>Combine Phase</strong></p>
<p>In the combine phase, multiple key-value pairs with the same key are collected and combined to an intermediate result before being send to the reducers. <strong>Combine phase is also optional in Hazelcast, but is highly recommended to use to lower the traffic.</strong></p>
<p>In terms of the word count example, this can be explained using the sentences &quot;Saturn is a planet but the Earth is a planet, too&quot;. As shown above, we would send two key-value pairs (planet, 1). The registered combiner now collects those two pairs and combines them to an intermediate result of (planet, 2). Instead of two key-value
pairs sent through the wire, there is now only one for the key &quot;planet&quot;.</p>
<p>The pseudo code for a combiner is pretty the same as for the reducer.</p>
<pre><code class="lang-text">combine( word:String, counts:List[Int] ):Void -&gt;
  emit( word, sum( counts ) )
</code></pre>
<p><strong>Grouping / Shuffling Phase</strong></p>
<p>The grouping or shuffling phase only exists virtually in Hazelcast since it is not a real phase; emitted key-value pairs with the same key are always transferred to the same reducer in the same job. That way they are grouped together which is equivalent to the shuffling phase.</p>
<p><strong>Reducing Phase</strong></p>
<p>In the reducing phase, the collected intermediate key-value pairs are reduced by their keys to build the final by-key result. This value can be a sum of all the emitted values of the same key, an average value or something completely different depending on the use case.</p>
<p>A reduced representation of this phase:</p>
<p>L x W* -&gt; X*</p>
<p>(l, [w<em>1</em>, ..., w<em>n</em>]) -&gt; [x<em>1</em>, ..., x<em>n</em>]</p>
<p><strong>Producing the Final Result</strong></p>
<p>This also is not a real MapReduce phase but is the final step in Hazelcast after all reducers notified that reducing has finished. The original job initiator then requests all reduced results and builds the final result.</p>
<h4 id="additional-mapreduce-resources">Additional MapReduce Resources</h4>
<p>The Internet is full of useful resources to find deeper information on MapReduce. Below is a short collection of some more introduction material. In addition, there are a lot of amazing books written about all kinds of MapReduce patterns and how to write a MapReduce function for your use case. To name them all is sadly out of scope of this documentation.</p>
<ul>
<li><a href="http://labs.google.com/papers/mapreduce.html">http://labs.google.com/papers/mapreduce.html</a></li>
<li><a href="http://en.wikipedia.org/wiki/MapReduce">http://en.wikipedia.org/wiki/MapReduce</a></li>
<li><a href="http://hci.stanford.edu/courses/cs448g/a2/files/map_reduce_tutorial.pdf">http://hci.stanford.edu/courses/cs448g/a2/files/map_reduce_tutorial.pdf</a></li>
<li><a href="http://ksat.me/map-reduce-a-really-simple-introduction-kloudo/">http://ksat.me/map-reduce-a-really-simple-introduction-kloudo/</a></li>
<li><a href="http://www.slideshare.net/franebandov/an-introduction-to-mapreduce-6789635">http://www.slideshare.net/franebandov/an-introduction-to-mapreduce-6789635</a></li>
</ul>
<h3 id="introduction-to-mapreduce-api">Introduction to MapReduce API</h3>
<p>This section explains basics of the Hazelcast MapReduce framework. While walking through the different API classes, we will build the word count example that was discussed earlier and create it step by step.</p>
<p>The Hazelcast API for MapReduce operations consists of a fluent DSL like configuration syntax to build and submit jobs. JobTracker is the basic entry point to all MapReduce operations and is retrieved from <code>com.hazelcast.core.HazelcastInstance</code> by calling <code>getJobTracker</code> and supplying the name of the required JobTracker configuration. The configuration for JobTrackers will be discussed later, for now we focus on the API itself.
In addition, the complete submission part of the API is built to support a fully reactive way of programming.</p>
<p>To give an easy introduction to people that are already used to Hadoop, we decided to create the class names as familiar as possible to their counterparts on Hadoop. That means while most users will recognize a lot of similar sounding classes, the way to configure the jobs is more fluent due to the already mentioned DSL like styled API.</p>
<p>While building the example, we will go through as much options as possible, e.g. we create a specialized JobTracker configuration (at the end). Special JobTracker configuration are not required, as for all other Hazelcast features you can use &quot;default&quot; as the configuration name, but special configurations offer better options to predict behavior of the framework while execution.</p>
<p>The full example is available <a href="http://github.com/noctarius/hz-map-reduce">here</a> as a ready to run Maven project.</p>
<h4 id="jobtracker">JobTracker</h4>
<p>The JobTracker is used to create Job instances whereas every instance of <code>com.hazelcast.mapreduce.Job</code> defines a single MapReduce configuration. The same Job can be submitted multiple times, no matter if executed in parallel or after the previous execution is finished.</p>
<p><img src="images/NoteSmall.jpg" alt="image"> <strong><em>NOTE:</em></strong> <em>After retrieving the JobTracker, be aware of the fact that it should only be used with data structures derived from the same HazelcastInstance. Otherwise you can get unexpected behavior</em></p>
<p>To retrieve a JobTracker from Hazelcast, we will start by using the &quot;default&quot; configuration for convenience reasons to show the basic way.</p>
<pre><code class="lang-java">import com.hazelcast.mapreduce.*;

JobTracker jobTracker = hazelcastInstance.getJobTracker( &quot;default&quot; );
</code></pre>
<p>JobTracker is retrieved using the same kind of entry point as most of other Hazelcast features. After building the cluster connection, you use the created HazelcastInstance to request the configured (or default) JobTracker from Hazelcast.</p>
<p>Next step will be to create a new Job and configure it to execute our first MapReduce request against cluster data.</p>
<h4 id="job">Job</h4>
<p>As mentioned in the last section, a Job is created using the retrieved JobTracker instance. A Job defines exactly one configuration of a MapReduce task. Mapper, combiner and reducers will be defined per job but since the Job instance is only a configuration, it is possible to be submitted multiple times, no matter if executions happening in parallel or one after the other.</p>
<p>A submitted job is always identified using a unique combination of the JobTracker&#39;s name and a, on submit-time generated, jobId. The way for retrieving the jobId will be shown in one of the later sections.</p>
<p>To create a Job, a second class <code>com.hazelcast.mapreduce.KeyValueSource</code> is necessary. We will have a deeper look at the KeyValueSource class in the next section, for now it is enough to know that it is used to wrap any kind of data or data structure into a well defined set of key-value pairs.</p>
<p>Below example code is a direct follow up of the example of the JobTracker section and reuses the already created HazelcastInstance and JobTracker instances.</p>
<p>We start by retrieving an instance of our data map and create the Job instance afterwards. Implementations used to configure the Job will be discussed while walking further through the API documentation, they are not yet discussed.</p>
<p><img src="images/NoteSmall.jpg" alt="image"> <strong><em>NOTE:</em></strong> <em>Since the Job class is highly depending on generics to support type safety, the generics change over time and may not be assignment compatible to old variable types. To make use of the full potential of the fluent API, we recommend to use fluent method chaining as shown in this example to prevent the need of too much variables.</em></p>
<pre><code class="lang-java">IMap&lt;String, String&gt; map = hazelcastInstance.getMap( &quot;articles&quot; );
KeyValueSource&lt;String, String&gt; source = KeyValueSource.fromMap( map );
Job&lt;String, String&gt; job = jobTracker.newJob( source );

ICompletableFuture&lt;Map&lt;String, Long&gt;&gt; future = job
    .mapper( new TokenizerMapper() )
    .combiner( new WordCountCombinerFactory() )
    .reducer( new WordCountReducerFactory() )
    .submit();

// Attach a callback listener
future.andThen( buildCallback() );

// Wait and retrieve the result
Map&lt;String, Long&gt; result = future.get();
</code></pre>
<p>As seen above, we create the Job instance and define a mapper, combiner, reducer and eventually submit the request to the cluster. The <code>submit</code> method returns an ICompletableFuture that can be used to attach our callbacks or just to wait for the result to be processed in a blocking fashion.</p>
<p>There are more options available for job configuration like defining a general chunk size or on what keys the operation will be operate. For more information, please consolidate the Javadoc matching your used Hazelcast version.</p>
<h4 id="keyvaluesource">KeyValueSource</h4>
<p>The KeyValueSource is able to either wrap Hazelcast data structures (like IMap, MultiMap, IList, ISet) into key-value pair input sources or to build your own custom key-value input source. The latter option makes it possible to feed Hazelcast MapReduce with all kind of data like just-in-time downloaded web page contents or data files. People familiar with  Hadoop will recognize similarities with the Input class.</p>
<p>You can imagine a KeyValueSource as a bigger <code>java.util.Iterator</code> implementation. Whereas most methods are required to be implemented, <code>getAllKeys</code> is optional to implement. If implementation is able to gather all keys upfront, it should be implemented and <code>isAllKeysSupported</code> must return true, that way Job configured KeyPredicates are able to be evaluate keys upfront before sending them to the cluster. Otherwise, they are serialized and transferred as well to be evaluated at execution time.</p>
<p>As shown in the example above, the abstract KeyValueSource class provides a number of static methods to easily wrap Hazelcast data structures into KeyValueSource implementations already provided by Hazelcast. The data structures&#39; generics are inherited into the resulting KeyValueSource instance. For data structures like IList or ISet, the key type is always String. While mapping, the key is the data structure&#39;s name whereas
the value type and value itself are inherited from the IList or ISet itself.</p>
<pre><code class="lang-java">// KeyValueSource from com.hazelcast.core.IMap
IMap&lt;String, String&gt; map = hazelcastInstance.getMap( &quot;my-map&quot; );
KeyValueSource&lt;String, String&gt; source = KeyValueSource.fromMap( map );
</code></pre>
<pre><code class="lang-java">// KeyValueSource from com.hazelcast.core.MultiMap
MultiMap&lt;String, String&gt; multiMap = hazelcastInstance.getMultiMap( &quot;my-multimap&quot; );
KeyValueSource&lt;String, String&gt; source = KeyValueSource.fromMultiMap( multiMap );
</code></pre>
<pre><code class="lang-java">// KeyValueSource from com.hazelcast.core.IList
IList&lt;String&gt; list = hazelcastInstance.getList( &quot;my-list&quot; );
KeyValueSource&lt;String, String&gt; source = KeyValueSource.fromList( list );
</code></pre>
<pre><code class="lang-java">// KeyValueSource from com.hazelcast.core.IList
ISet&lt;String&gt; set = hazelcastInstance.getSet( &quot;my-set&quot; );
KeyValueSource&lt;String, String&gt; source = KeyValueSource.fromSet( set );
</code></pre>
<p><strong>PartitionIdAware</strong></p>
<p>The <code>com.hazelcast.mapreduce.PartitionIdAware</code> interface can be implemented by the KeyValueSource implementation if the underlying data set is aware of the Hazelcast partitioning schema (as it is for all internal data structures). If this interface is implemented, the same KeyValueSource instance is reused multiple times for all partitions on the cluster node. As a consequence, the <code>close</code> and <code>open</code> methods are also executed
multiple times but once per partitionId.</p>
<h4 id="mapper">Mapper</h4>
<p>Using the Mapper interface, you will implement the mapping logic. Mappers can transform, split, calculate, aggregate data from data sources. In Hazelcast, it is also possible to integrate data from more than the KeyValueSource data source by implementing <code>com.hazelcast.core.HazelcastInstanceAware</code> and requesting additional maps, multimaps, list, sets.</p>
<p>The mappers <code>map</code> function is called once per available entry in the data structure. If you work on distributed data structures that operate in a partition based fashion, then multiple mappers work in parallel on the different cluster nodes, on the nodes&#39; assigned partitions. Mappers then prepare and maybe transform the input key-value pair and emit zero or more key-value pairs for reducing phase.</p>
<p>For our word count example, we retrieve an input document (a text document) and we transform it by splitting the text into the available words. After that, as discussed in the pseudo code, we emit every single word with a key-value pair of the word itself as key and 1 as the value.</p>
<p>A common implementation of that Mapper might look like the following example:</p>
<pre><code class="lang-java">public class TokenizerMapper implements Mapper&lt;String, String, String, Long&gt; {
  private static final Long ONE = Long.valueOf( 1L );

  @Override
  public void map(String key, String document, Context&lt;String, Long&gt; context) {
    StringTokenizer tokenizer = new StringTokenizer( document.toLowerCase() );
    while ( tokenizer.hasMoreTokens() ) {
      context.emit( tokenizer.nextToken(), ONE );
    }
  }
}
</code></pre>
<p>The code is pretty basic and just splits the mapped texts into their tokens and iterate over the tokenizer as long as there are more tokens and emits a pair per word. What is to note, we&#39;re not yet collecting multiple occurrences of the same word but just fire every word on its own.</p>
<p><strong>LifecycleMapper / LifecycleMapperAdapter</strong></p>
<p>The LifecycleMapper interface or its adapter class LifecycleMapperAdapter can be used to make the Mapper implementation lifecycle aware. That means it will be notified when mapping of a partition or set of data begins and when the last entry was mapped.</p>
<p>Only special algorithms might have a need for those additional lifecycle events to perform preparation, cleanup or emit additional values.</p>
<h4 id="combiner-combinerfactory">Combiner / CombinerFactory</h4>
<p>As stated in the introduction, a Combiner is used to minimize traffic between the different cluster nodes when transmitting mapped values from mappers to the reducers by aggregating multiple values for the same emitted key. This is a fully optional operation but is highly recommended to be used.</p>
<p>Combiners can be seen as an intermediate reducer. The calculated value is always assigned back to the key for which the combiner initially was created. Since combiners are created per emitted key, not the Combiner implementation itself is defined in the jobs configuration but a CombinerFactory that is able to create the expected Combiner instance.</p>
<p>Due to the fact that Hazelcast MapReduce is executing mapping and reducing phase in parallel, the Combiner implementation must be able to deal with chunked data. That means, it is required to reset its internal state whenever <code>finalizeChunk</code> is called. Calling that method creates a chunk of intermediate data to be grouped (shuffled) and sent to the reducers.</p>
<p>Combiners can override <code>beginCombine</code> and <code>finalizeCombine</code> to perform preparation or cleanup work.</p>
<p>For our word count example, we are going to have a simple CombinerFactory and Combiner implementation similar to the following one:</p>
<pre><code class="lang-java">public class WordCountCombinerFactory
    implements CombinerFactory&lt;String, Long, Long&gt; {

  @Override
  public Combiner&lt;Long, Long&gt; newCombiner( String key ) {
    return new WordCountCombiner();
  }

  private class WordCountCombiner extends Combiner&lt;Long, Long&gt; {
    private long sum = 0;

    @Override
    public void combine( Long value ) {
      sum++;
    }

    @Override
    public Long finalizeChunk() {
      return sum;
    }

    @Override
    public void reset() {
      sum = 0;
    }
  }
}
</code></pre>
<p>As mentioned before, the Combiner must be able to return its current value as a chunk and reset the internal state by setting sum back to 0. Since combiners are always called from a single thread, no synchronization or volatility of the variables is necessary.</p>
<h4 id="reducer-reducerfactory">Reducer / ReducerFactory</h4>
<p>Reducers doing the last bit of algorithm work. This can be aggregating values, calculating averages or anything else that is expected by the algorithm to work.</p>
<p>Since values arrive in chunks, the reduce method is called multiple times for every emitted value of the creation key. This also can happen multiple times per chunk if no Combiner implementation was configured for a job configuration.</p>
<p>In difference of the combiners, a reducers <code>finalizeReduce</code> method is only called once per reducer (which means once per key). So, a reducer does not need to be able to reset its internal state at any time.</p>
<p>Reducers can override <code>beginReduce</code> to perform preparation work.</p>
<p>Again for our word count example, the implementation will look similar to the following code snippet:</p>
<pre><code class="lang-java">public class WordCountReducerFactory implements ReducerFactory&lt;String, Long, Long&gt; {

  @Override
  public Reducer&lt;Long, Long&gt; newReducer( String key ) {
    return new WordCountReducer();
  }

  private class WordCountReducer extends Reducer&lt;Long, Long&gt; {
    private volatile long sum = 0;

    @Override
    public void reduce( Long value ) {
      sum += value.longValue();
    }

    @Override
    public Long finalizeReduce() {
      return sum;
    }
  }
}
</code></pre>
<p>Different from combiners, reducer tends to switch threads if running out of data to prevent blocking threads from the JobTracker configuration. They are rescheduled at a later point when new data to be processed arrives but unlikely to be executed on the same thread as before. Due to this fact, some volatility of the internal state might be necessary.</p>
<h4 id="collator">Collator</h4>
<p>A Collator is an optional operation that is executed on the job emitting node and is able to modify the finally reduced result before returned to the user&#39;s codebase. Only special use cases are likely to make use of collators.</p>
<p>For an imaginary use case, we might want to know how many words were all over in the documents we analyzed and for this case, a Collator implementation can be given to the <code>submit</code> method of the Job instance.</p>
<p>A collator would look like the following snippet:</p>
<pre><code class="lang-java">public class WordCountCollator implements Collator&lt;Map.Entry&lt;String, Long&gt;, Long&gt; {

  @Override
  public Long collate( Iterable&lt;Map.Entry&lt;String, Long&gt;&gt; values ) {
    long sum = 0;

    for ( Map.Entry&lt;String, Long&gt; entry : values ) {
      sum += entry.getValue().longValue();
    }
    return sum;
  }
}
</code></pre>
<p>The definition of the input type is a bit strange but due to the fact that Combiner and Reducer implementations are optional, the input type heavily depends on the state of the data. As stated above, collators are non-typical use cases and the generics of the framework always help in finding the correct signature.</p>
<h4 id="keypredicate">KeyPredicate</h4>
<p>A KeyPredicate can be used to pre-select if a key should be selected for mapping in the mapping phase. If the KeyValueSource implementation is able to know all keys upfront to execution, the keys are filtered before the operations are divided to the different cluster nodes.</p>
<p>It is also possible to be used to select only a special range of data (e.g. a time-frame) or similar use cases.</p>
<p>A basic KeyPredicate implementation to only map keys containing the word &quot;hazelcast&quot; might look like the following code class:</p>
<pre><code class="lang-java">public class WordCountKeyPredicate implements KeyPredicate&lt;String&gt; {

  @Override
  public boolean evaluate( String s ) {
    return s != null &amp;&amp; s.toLowerCase().contains( &quot;hazelcast&quot; );
  }
}
</code></pre>
<h4 id="trackablejob-and-job-monitoring">TrackableJob and Job Monitoring</h4>
<p>A TrackableJob instance can be retrieved after submitting a job. It is requested from the JobTracker using the, per JobTracker, unique jobId. It can be used to get runtime statistics of the job. At the moment, the information available are limited to the number of processed (mapped) records and the processing state of the different partitions or nodes (if KeyValueSource is not PartitionIdAware).</p>
<p>To retrieve the jobId after submission of the job, use <code>com.hazelcast.mapreduce.JobCompletableFuture</code> instead of the <code>com.hazelcast.core.ICompletableFuture</code> as variable type for the returned future.</p>
<p>Below snippet will give a quick introduction on how to retrieve the instance and the runtime data. For more information, please have a look at the Javadoc corresponding your running Hazelcast version.</p>
<pre><code class="lang-java">IMap&lt;String, String&gt; map = hazelcastInstance.getMap( &quot;articles&quot; );
KeyValueSource&lt;String, String&gt; source = KeyValueSource.fromMap( map );
Job&lt;String, String&gt; job = jobTracker.newJob( source );

JobCompletableFuture&lt;Map&lt;String, Long&gt;&gt; future = job
    .mapper( new TokenizerMapper() )
    .combiner( new WordCountCombinerFactory() )
    .reducer( new WordCountReducerFactory() )
    .submit();

String jobId = future.getJobId();
TrackableJob trackableJob = jobTracker.getTrackableJob(jobId);

JobProcessInformation stats = trackableJob.getJobProcessInformation();
int processedRecords = stats.getProcessedRecords();
log( &quot;ProcessedRecords: &quot; + processedRecords );

JobPartitionState[] partitionStates = stats.getPartitionStates();
for ( JobPartitionState partitionState : partitionStates ) {
  log( &quot;PartitionOwner: &quot; + partitionState.getOwner()
          + &quot;, Processing state: &quot; + partitionState.getState().name() );
}
</code></pre>
<p><img src="images/NoteSmall.jpg" alt="image"> <strong><em>NOTE:</em></strong> <em>Caching of the JobProcessInformation does not work on Java native clients since current values are retrieved while retrieving the instance to minimize traffic between executing node and client.</em></p>
<h4 id="jobtracker-configuration">JobTracker Configuration</h4>
<p>The JobTracker configuration is used to setup behavior of the Hazelcast MapReduce framework.</p>
<p>Every JobTracker is capable of running multiple MapReduce jobs at once and so one configuration is meant as a shared resource for all jobs created by the same JobTracker. The configuration gives full control over the expected load behavior and thread counts to be used.</p>
<p>The following snippet shows a typical JobTracker configuration. We will discuss the configuration properties one by one:</p>
<pre><code class="lang-xml">&lt;jobtracker name=&quot;default&quot;&gt;
  &lt;max-thread-size&gt;0&lt;/max-thread-size&gt;
  &lt;!-- Queue size 0 means number of partitions * 2 --&gt;
  &lt;queue-size&gt;0&lt;/queue-size&gt;
  &lt;retry-count&gt;0&lt;/retry-count&gt;
  &lt;chunk-size&gt;1000&lt;/chunk-size&gt;
  &lt;communicate-stats&gt;true&lt;/communicate-stats&gt;
  &lt;topology-changed-strategy&gt;CANCEL_RUNNING_OPERATION&lt;/topology-changed-strategy&gt;
&lt;/jobtracker&gt;
</code></pre>
<ul>
<li><strong>max-thread-size:</strong> Configures the maximum thread pool size of the JobTracker.</li>
<li><strong>queue-size:</strong> Defines the maximum number of tasks that are able to wait to be processed. A value of 0 means unbounded queue. Very low numbers can prevent successful execution since job might not be correctly scheduled or intermediate chunks are lost.</li>
<li><strong>retry-count:</strong> Currently not used but reserved for later use where the framework will automatically try to restart / retry operations from an available save point.</li>
<li><strong>chunk-size:</strong> Defines the number of emitted values before a chunk is sent to the reducers. If your emitted values are big or you want to better balance your work, you might want to change this to a lower or higher value. A value of 0 means immediate transmission but remember that low values mean higher traffic costs. A very high value might cause an OutOfMemoryError to occur if emitted values not fit into heap memory before
being sent to reducers. To prevent this, you might want to use a combiner to pre-reduce values on mapping nodes.</li>
<li><strong>communicate-stats:</strong> Defines if statistics (for example about processed entries) are transmitted to the job emitter. This might be used to show any kind of progress to a user inside of an UI system but produces additional traffic. If not needed, you might want to deactivate this.</li>
<li><strong>topology-changed-strategy:</strong> Defines how the MapReduce framework will react on topology changes while executing a job. Currently, only CANCEL_RUNNING_OPERATION is fully supported which throws an exception to the job emitter (will throw a <code>com.hazelcast.mapreduce.TopologyChangedException</code>).</li>
</ul>
<h3 id="hazelcast-mapreduce-architecture">Hazelcast MapReduce Architecture</h3>
<p>This sub-chapter will explain some of the internals of the MapReduce framework. This is meant to be more advanced stuff. If you&#39;re not interested in how it works internally you might want to stop reading here.</p>
<h4 id="node-interoperation-example">Node Interoperation Example</h4>
<p>To understand the following technical internals, we first will have a short look at what happens in terms of an example workflow.</p>
<p>To make the understanding simple, we think of an <code>IMap&lt;String, Integer&gt;</code> and emitted keys to have the same types. Imagine you have a three node cluster and initiate the MapReduce job on the first node. After you requested the JobTracker from your running / connected Hazelcast, we submit the task and retrieve the ICompletableFuture which gives us a chance of waiting for the result to be calculated or adding a callback to go a more reactive way.</p>
<p>The example expects that the chunk size is 0 or 1 so an emitted value is directly sent to the reducers. Internally, the job is prepared, started and executed on all nodes as shown below whereas the first node acts as the job owner (job emitter):</p>
<pre><code class="lang-plain">Node1 starts MapReduce job
Node1 emits key=Foo, value=1
Node1 does PartitionService::getKeyOwner(Foo) =&gt; results in Node3

Node2 emits key=Foo, value=14
Node2 asks jobOwner (Node1) for keyOwner of Foo =&gt; results in Node3

Node1 sends chunk for key=Foo to Node3

Node3 receives chunk for key=Foo and looks if there is already a Reducer,
      if not creates one for key=Foo
Node3 processes chunk for key=Foo

Node2 sends chunk for key=Foo to Node3

Node3 receives chunk for key=Foo and looks if there is already a Reducer and uses
      the previous one
Node3 processes chunk for key=Foo

Node1 send LastChunk information to Node3 because processing local values finished

Node2 emits key=Foo, value=27
Node2 has cached keyOwner of Foo =&gt; results in Node3
Node2 sends chunk for key=Foo to Node3

Node3 receives chunk for key=Foo and looks if there is already a Reducer and uses
      the previous one
Node3 processes chunk for key=Foo

Node2 send LastChunk information to Node3 because processing local values finished

Node3 finishes reducing for key=Foo

Node1 registers its local partitions are processed
Node2 registers its local partitions are processed

Node1 sees all partitions processed and requests reducing from all nodes

Node1 merges all reduced results together in a final structure and returns it
</code></pre>
<p>As you can see, the flow is quite complex but extremely powerful since everything is executed in parallel. Reducers do not wait until all values are emitted but immediately begin to reduce (when first chunk for an emitted key arrives).</p>
<h4 id="internal-architecture">Internal Architecture</h4>
<p>Beginning with the package level, there is one basic package: <code>com.hazelcast.mapreduce</code>. This includes the external API and the <strong>impl</strong> package which itself contains the internal implementation.</p>
<ul>
<li>The <strong>impl</strong> package contains all the default KeyValueSource implementations and abstract base and support classes for exposed API.</li>
<li>The <strong>client</strong> package contains all classes that are needed on client and server (node) side when a MapReduce job is offered from a client.</li>
<li>The <strong>notification</strong> package contains all &quot;notification&quot; or event classes that are used to notify other members about progress on operations.</li>
<li>The <strong>operation</strong> package contains all operations that are used by the workers or job owner to coordinate work and sync partition or reducer processing.</li>
<li>The <strong>task</strong> package contains all classes that execute the actual MapReduce operation. It features the supervisor, mapping phase implementation and mapping and reducing tasks.</li>
</ul>
<p>And now to the technical walk-through: As stated above, a MapReduce Job is always retrieved from a named JobTracker which in case is implemented in NodeJobTracker (extends AbstractJobTracker) and is configured using the configuration DSL. All of the internal implementation is completely ICompletableFuture driven and mostly non-blocking in design.</p>
<p>On submit, the Job creates a unique UUID which afterwards acts as a jobId and is combined with the JobTracker&#39;s name to be uniquely identifiable inside the cluster. Then, the preparation is sent around the cluster and every member prepares its execution by creating a a JobSupervisor, MapCombineTask and ReducerTask. The job emitting JobSupervisor gains special capabilities to synchronize and control JobSupervisors on other nodes for the same job.</p>
<p>If preparation is finished on all nodes, the job itself is started by executing a StartProcessingJobOperation on every node. This initiates a MappingPhase implementation (defaults to KeyValueSourceMappingPhase) and starts the actual mapping on the nodes.</p>
<p>The mapping process is currently a single threaded operation per node, but will be extended to run in parallel on multiple partitions (configurable per Job) in future versions. The Mapper is now called on every available value on the partition and eventually emits values. For every emitted value, either a configured CombinerFactory is called to create a Combiner or a cached one is used (or the default CollectingCombinerFactory is used to create Combiners). When the chunk limit is reached on a node, a IntermediateChunkNotification is prepared by collecting emitted keys to their corresponding nodes. This is either done by asking the job owner to assign members or by an already cached assignment. In later versions, a PartitionStrategy might be configurable, too.</p>
<p>The IntermediateChunkNotification is then sent to the reducers (containing only values for this node) and is offered to the ReducerTask. On every offer, the ReducerTask checks if it is already running and if not, it submits itself to the configured ExecutorService (from the JobTracker configuration).</p>
<p>If reducer queue runs out of work, the ReducerTask is removed from the ExecutorService to not block threads but eventually will be resubmitted on next chunk of work.</p>
<p>On every phase, the partition state is changed to keep track of the currently running operations. A JobPartitionState can be in one of the following states with self-explanatory titles: <code>[WAITING, MAPPING, REDUCING, PROCESSED, CANCELLED]</code>. On deeper interest of the states, look at the Javadoc.</p>
<ul>
<li>Node asks for new partition to process: WAITING =&gt; MAPPING</li>
<li>Node emits first chunk to a reducer: MAPPING =&gt; REDUCING</li>
<li>All nodes signal that they finished mapping phase and reducing is finished, too: REDUCING =&gt; PROCESSED</li>
</ul>
<p>Eventually (or hopefully), all JobPartitionStates are reached to the state PROCESSED. Then, the job emitter&#39;s JobSupervisor asks all nodes for their reduced results and executes a potentially offered Collator. With this Collator, the overall result is calculated before it removes itself from the JobTracker, doing some final cleanup and returning the result to the requester (using the internal TrackableJobFuture).</p>
<p>If a job is cancelled while execution, all partitions are immediately set to CANCELLED state and a CancelJobSupervisorOperation is executed on all nodes to kill the running processes.</p>
<p>While the operation is running in addition to the default operations, some more like
ProcessStatsUpdateOperation (updates processed records statistics) or NotifyRemoteExceptionOperation (notifies the nodes that the sending node encountered an unrecoverable situation and the Job needs to
be cancelled - e.g. NullPointerException inside of a Mapper) are executed against the job owner to keep track of the process.</p>
<h2 id="aggregators">Aggregators</h2>
<p>Based on the Hazelcast MapReduce framework, Aggregators are ready-to-use data aggregations. These are typical operations like
sum up values, finding minimum or maximum values, calculating averages and other operations that you would expect to be available 
in the relational database world.  </p>
<p>Aggregation operations are implemented, as mentioned above, on top of the MapReduce framework and therefore all operations can be
achieved using pure map-reduce calls but using the Aggregation feature is more convenient for a big set of standard operations.</p>
<h3 id="aggregations-basics">Aggregations Basics</h3>
<p>This short section will quickly guide you through the basics of the Aggregations framework and some of the available classes.
We also will implement a first base example.</p>
<p>Aggregations are available on both types of map interfaces, <code>com.hazelcast.core.IMap</code> and <code>com.hazelcast
.core.MultiMap</code>, using
the <code>aggregate</code> methods. Two overloaded methods are available to customize resource management of the
underlying MapReduce framework by supplying a custom configured <code>com.hazelcast.mapreduce.JobTracker</code> instance. To find out how to
configure the MapReduce framework please see <a href="#jobtracker-configuration">JobTracker Configuration</a> section. We will
later see another way to configure the automatically used MapReduce framework if no special <code>JobTracker</code> is supplied.</p>
<p>To make Aggregations more convenient to use and future proof, the API is already heavily optimized for Java 8 and future version
but still fully compatible to any Java version Hazelcast supports (Java 6 and Java 7). The biggest difference is how you have to
work with the Java generics; on Java 6 and 7 the generics resolving process is not as strong as on Java 8 and
upcoming Java versions. In addition, the whole Aggregations API has full Java 8 Project Lambda (or Closure, 
<a href="https://jcp.org/en/jsr/detail?id=335">JSR 335</a>) support.</p>
<p>For illustration of the differences in Java 6 and 7 in comparison to Java 8, we  will have a quick look at both source code
examples. After that, the documentation will focus on using Java 8 syntax to keep examples short and easy to understand but still
offer some hints as to what it looks like in Java 6 or 7.</p>
<p>The first basic example will produce the sum of some <code>int</code> values stored in a Hazelcast IMap. This is a very basic example not yet
using a lot of the functionality of the Aggregations framework but will already perfectly show the main difference.</p>
<pre><code class="lang-java">IMap&lt;String, Integer&gt; personAgeMapping = hazelcastInstance.getMap( &quot;person-age&quot; );
for ( int i = 0; i &lt; 1000; i++ ) {
  String lastName = RandomUtil.randomLastName();
  int age = RandomUtil.randomAgeBetween( 20, 80 );
  personAgeMapping.put( lastName, Integer.valueOf( age ) );
}
</code></pre>
<p>With our demo data prepared we can have a look at how to produce the sums in different Java versions.</p>
<h4 id="aggregations-and-java-6-or-java-7">Aggregations and Java 6 or Java 7</h4>
<p>Since Java 6 and 7, as mentioned earlier, are not as strong on resolving generics as Java 8 we need to be a bit more verbose
with what we write or you might want to consider using raw types but breaking the type safety to ease this process.</p>
<p>For a short introduction on what the following lines mean have a quick look at the source code comments. We will dig deeper into
the different options in a bit. </p>
<pre><code class="lang-java">// No filter applied, select all entries
Supplier&lt;String, Integer, Integer&gt; supplier = Supplier.all();
// Choose the sum aggregation
Aggregation&lt;String, Integer, Integer&gt; aggregation = Aggregations.integerSum();
// Execute the aggregation
int sum = personAgeMapping.aggregate( supplier, aggregation );
</code></pre>
<h4 id="aggregations-and-java-8">Aggregations and Java 8</h4>
<p>On Java 8 the Aggregations API looks much simpler since Java is now able to resolve the generic parameters for us. That means
the above lines of source will end up in one line on Java 8.</p>
<pre><code>int sum = personAgeMapping.aggregate( Supplier.all(), Aggregations.integerSum() );
</code></pre><p>As you can see, this really looks stunning and easy to use.</p>
<h4 id="quick-look-at-the-mapreduce-framework">Quick look at the MapReduce Framework</h4>
<p>As mentioned before, the Aggregations implementation is based on the Hazelcast MapReduce framework and therefore you might find
overlaps of the different APIs and we have already seen one before. One overload of the <code>aggregate</code> method can be supplied with
a <code>JobTracker</code> which is part of the MapReduce framework.</p>
<p>If you are going to implement your own aggregations you also end up implementing them using a mixture of the Aggregations and
the MapReduce API. If you are looking forward to implement your own aggregation, e.g. to make the life of colleagues easier,
please read <a href="#implementing-aggregations">Implementing Aggregations</a>.</p>
<p>For the full MapReduce documentation please see <a href="#mapreduce">MapReduce</a>.</p>
<h3 id="introduction-to-aggregations-api">Introduction to Aggregations API</h3>
<p>Following the basic example, we now want to look into the real API, for the possible options and what can be achieved using the
Aggregations API. To work on some more and deeper examples, let&#39;s quickly have a look at the available classes and interfaces and
discuss their usage.</p>
<h4 id="supplier">Supplier</h4>
<p>The <code>com.hazelcast.mapreduce.aggregation.Supplier</code> is used to provide filtering and data extraction to the aggregation operation.
This class already provides a few different static methods to achieve most common cases. We already learned about <code>Supplier.all()</code>
which accepts all incoming values and does not apply any data extraction or transformation upon them before supplying them to
the aggregation function itself.</p>
<p>For filtering data sets, you have two different options by default. You can either supply a <code>com.hazelcast.query.Predicate</code>
if you want to filter on values and / or keys or a <code>com.hazelcast.mapreduce.KeyPredicate</code> if you can decide directly on the data
key without the need to deserialize the value.</p>
<p>As mentioned above, all APIs are fully Java 8 and Lambda compatible, so let&#39;s have a look on how we can do basic filtering using
those two options.</p>
<p>First, we have a look at a <code>KeyPredicate</code> and only accept people whose last name is &quot;Jones&quot;.</p>
<pre><code class="lang-java">Supplier&lt;...&gt; supplier = Supplier.fromKeyPredicate(
    lastName -&gt; &quot;Jones&quot;.equalsIgnoreCase( lastName )
);
</code></pre>
<pre><code class="lang-java">class JonesKeyPredicate implements KeyPredicate&lt;String&gt; {
  public boolean evaluate( String key ) {
    return &quot;Jones&quot;.equalsIgnoreCase( key );
  }
}
</code></pre>
<p>Using the standard Hazelcast <code>Predicate</code> interface, you can also filter based on the value of a data entry. For example, you can
only select values which are divisible without remainder by 4 using the following example. </p>
<pre><code class="lang-java">Supplier&lt;...&gt; supplier = Supplier.fromPredicate(
    entry -&gt; entry.getValue() % 4 == 0
);
</code></pre>
<pre><code class="lang-java">class DivisiblePredicate implements Predicate&lt;String, Integer&gt; {
  public boolean apply( Map.Entry&lt;String, Integer&gt; entry ) {
    return entry.getValue() % 4 == 0;
  }
}
</code></pre>
<p>As well as filtering, <code>Supplier</code> is also used to extract or transform data before providing it
to the aggregation operation itself. The following short example shows how to transform an input value to a string.</p>
<pre><code class="lang-java">Supplier&lt;String, Integer, String&gt; supplier = Supplier.all(
    value -&gt; Integer.toString(value)
);
</code></pre>
<p>A Java 6 / 7 example will follow up below in the following section.</p>
<p>Apart from the fact we transformed the input value of type <code>int</code> (or Integer) to a string, we can see that the generic information
of the resulting <code>Supplier</code> has changed as well. This indicates that we now have an aggregation working on string values.</p>
<p>Another feature of <code>Supplier</code> is its ability to chain multiple filtering rules, so let&#39;s combine all of the
above examples into one rule set:</p>
<pre><code class="lang-java">Supplier&lt;String, Integer, String&gt; supplier =
    Supplier.fromKeyPredicate(
        lastName -&gt; &quot;Jones&quot;.equalsIgnoreCase( lastName ),
        Supplier.fromPredicate(
            entry -&gt; entry.getValue() % 4 == 0,  
            Supplier.all( value -&gt; Integer.toString(value) )
        )
    );
</code></pre>
<p>Last but not least, you might prefer (or end up in a necessary situation) implementing your <code>Supplier</code> based on special
requirements. But do not be afraid, this is a very basic task. The <code>Supplier</code> abstract class has just one method.
<br></br></p>
<p><img src="images/NoteSmall.jpg" alt="image"> <strong><em>NOTE:</em></strong> <em>Due to a limitation of the Java Lambda API you cannot implement abstract classes using Lambdas, so instead it is
recommended to create a standard named class instead.</em></p>
<pre><code class="lang-java">class MyCustomSupplier extends Supplier&lt;String, Integer, String&gt; {
  public String apply( Map.Entry&lt;String, Integer&gt; entry ) {
    Integer value = entry.getValue();
    if (value == null) {
      return null;
    }
    return value % 4 == 0 ? String.valueOf( value ) : null;
  }
}
</code></pre>
<p><code>Supplier</code>s are expected to return null from the <code>apply</code> method whenever the input value should not be mapped to the aggregation
process. This can be used, as seen above, to implement filter rules directly. Implementing filters using the
<code>KeyPredicate</code> and <code>Predicate</code> interfaces might be more convenient.</p>
<p>To use your own <code>Supplier</code>, just pass it to the aggregate method or use it in combination with other <code>Supplier</code>s.</p>
<pre><code class="lang-java">int sum = personAgeMapping.aggregate( new MyCustomSupplier(), Aggregations.count() );
</code></pre>
<pre><code class="lang-java">Supplier&lt;String, Integer, String&gt; supplier =
    Supplier.fromKeyPredicate(
        lastName -&gt; &quot;Jones&quot;.equalsIgnoreCase( lastName ),
        new MyCustomSupplier()
     );
int sum = personAgeMapping.aggregate( supplier, Aggregations.count() );
</code></pre>
<h4 id="aggregation-and-aggregations">Aggregation and Aggregations</h4>
<p>The <code>com.hazelcast.mapreduce.aggregation.Aggregation</code> interface defines the aggregation operation itself. It contains a set of
MapReduce API implementations like <code>Mapper</code>, <code>Combiner</code>, <code>Reducer</code>, <code>Collator</code>. These implementations are normally unique to
the chosen <code>Aggregation</code>. This interface can also be implemented with your aggregation operations based on map-reduce calls. To
find deeper information on this, please have a look at <a href="#implementing-aggregations">Implementing Aggregations</a>.</p>
<p>A common predefined set of aggregations are provided by the <code>com.hazelcast.mapreduce.aggregation.Aggregations</code> class. This class
contains type safe aggregations of the following types:</p>
<ul>
<li>Average (Integer, Long, Double, BigInteger, BigDecimal)</li>
<li>Sum (Integer, Long, Double, BigInteger, BigDecimal)</li>
<li>Min (Integer, Long, Double, BigInteger, BigDecimal, Comparable)</li>
<li>Max (Integer, Long, Double, BigInteger, BigDecimal, Comparable)</li>
<li>DistinctValues</li>
<li>Count</li>
</ul>
<p>Those aggregations are a lot like their counterparts on relational databases and can be equated to SQL statements as set out
below.</p>
<h5 id="average">Average</h5>
<p>Calculates an average value based on all selected values.</p>
<pre><code class="lang-java">map.aggregate( Supplier.all( person -&gt; person.getAge() ),
               Aggregations.integerAvg() );
</code></pre>
<pre><code class="lang-sql">SELECT AVG(person.age) FROM person;
</code></pre>
<h5 id="sum">Sum</h5>
<p>Calculates a sum based on all selected values.</p>
<pre><code class="lang-java">map.aggregate( Supplier.all( person -&gt; person.getAge() ),
               Aggregations.integerSum() );
</code></pre>
<pre><code class="lang-sql">SELECT SUM(person.age) FROM person;
</code></pre>
<h5 id="minimum-min-">Minimum (Min)</h5>
<p>Finds the minimal value over all selected values.</p>
<pre><code class="lang-java">map.aggregate( Supplier.all( person -&gt; person.getAge() ),
               Aggregations.integerMin() );
</code></pre>
<pre><code class="lang-sql">SELECT MIN(person.age) FROM person;
</code></pre>
<h5 id="maximum-max-">Maximum (Max)</h5>
<p>Finds the maximal value over all selected values.</p>
<pre><code class="lang-java">map.aggregate( Supplier.all( person -&gt; person.getAge() ),
               Aggregations.integerMax() );
</code></pre>
<pre><code class="lang-sql">SELECT MAX(person.age) FROM person;
</code></pre>
<h5 id="distinct-values">Distinct Values</h5>
<p>Returns a collection of distinct values over the selected values</p>
<pre><code class="lang-java">map.aggregate( Supplier.all( person -&gt; person.getAge() ),
               Aggregations.distinctValues() );
</code></pre>
<pre><code class="lang-sql">SELECT DISTINCT person.age FROM person;
</code></pre>
<h5 id="count">Count</h5>
<p>Returns the element count over all selected values </p>
<pre><code class="lang-java">map.aggregate( Supplier.all(), Aggregations.count() );
</code></pre>
<pre><code class="lang-sql">SELECT COUNT(*) FROM person;
</code></pre>
<h4 id="propertyextractor">PropertyExtractor</h4>
<p>We have already used the <code>com.hazelcast.mapreduce.aggregation.PropertyExtractor</code> interface before when we had a look at the example
on how to use a <code>Supplier</code> to transform a value to another type. It can also be used to extract attributes from values.</p>
<pre><code class="lang-java">class Person {
  private String firstName;
  private String lastName;
  private int age;

  // getters and setters
}

PropertyExtractor&lt;Person, Integer&gt; propertyExtractor = (person) -&gt; person.getAge();
</code></pre>
<pre><code class="lang-java">class AgeExtractor implements PropertyExtractor&lt;Person, Integer&gt; {
  public Integer extract( Person value ) {
    return value.getAge();
  }
}
</code></pre>
<p>In this example, we extract the value from the person&#39;s age attribute and so the value type changes from Person to <code>Integer</code> which
again is reflected in the generics information to stay type safe.</p>
<p><code>PropertyExtractor</code>s are meant to be used for any kind of transformation of data, you might even want to have multiple
transformation steps chained one after another.</p>
<h4 id="aggregation-configuration">Aggregation Configuration</h4>
<p>As stated before, the easiest way to configure the resources used by the underlying MapReduce framework is to supply a <code>JobTracker</code>
to the aggregation call itself by passing it to either <code>IMap::aggregate</code> or <code>MultiMap::aggregate</code>.</p>
<p>There is also a second way on how to implicitly configure the underlying used <code>JobTracker</code>. If no specific <code>JobTracker</code> was
passed for the aggregation call, internally the one to be used will be created using a naming specification as the following:</p>
<p>For <code>IMap</code> aggregation calls the naming spec is created as:</p>
<ul>
<li><code>hz::aggregation-map-</code> and concatenated the name of the map</li>
</ul>
<p>For <code>MultiMap</code> it is very similar:</p>
<ul>
<li><code>hz::aggregation-multimap-</code> and concatenated the name of the MultiMap</li>
</ul>
<p>knowing that (the specification of the name), we can configure the <code>JobTracker</code> as expected 
(as described in the Jobtracker section) using the naming spec we just learned For more information on configuration of the 
<code>JobTracker</code> please see <a href="#jobtracker-configuration">JobTracker Configuration</a>. </p>
<p>To finish this section, let&#39;s have a quick example for the above naming specs:</p>
<pre><code class="lang-java">IMap&lt;String, Integer&gt; map = hazelcastInstance.getMap( &quot;mymap&quot; );

// The internal JobTracker name resolves to &#39;hz::aggregation-map-mymap&#39; 
map.aggregate( ... );
</code></pre>
<pre><code class="lang-java">MultiMap&lt;String, Integer&gt; multimap = hazelcastInstance.getMultiMap( &quot;mymultimap&quot; );

// The internal JobTracker name resolves to &#39;hz::aggregation-multimap-mymultimap&#39; 
multimap.aggregate( ... );
</code></pre>
<h3 id="aggregations-examples">Aggregations Examples</h3>
<p>For the final example, imagine you are working for an international company and you have an employee database stored in Hazelcast
<code>IMap</code> with all employees worldwide and a <code>MultiMap</code> for assigning employees to their certain locations or offices. In addition,
there is another <code>IMap</code> which holds the salary per employee.</p>
<p>Let&#39;s have a look at our data model:</p>
<pre><code class="lang-java">class Employee implements Serializable {
  private String firstName;
  private String lastName;
  private String companyName;
  private String address;
  private String city;
  private String county;
  private String state;
  private int zip;
  private String phone1;
  private String phone2;
  private String email;
  private String web;

  // getters and setters
}

class SalaryMonth implements Serializable {
  private Month month;
  private int salary;

  // getters and setters
}

class SalaryYear implements Serializable {
  private String email;
  private int year;
  private List&lt;SalaryMonth&gt; months;

  // getters and setters

  public int getAnnualSalary() {
    int sum = 0;
    for ( SalaryMonth salaryMonth : getMonths() ) {
      sum += salaryMonth.getSalary();
    }
    return sum;
  }
}
</code></pre>
<p>The two <code>IMap</code>s and the <code>MultiMap</code>, they are both keyed by the string of email and are defined as follows:</p>
<pre><code class="lang-java">IMap&lt;String, Employee&gt; employees = hz.getMap( &quot;employees&quot; );
IMap&lt;String, SalaryYear&gt; salaries = hz.getMap( &quot;salaries&quot; );
MultiMap&lt;String, String&gt; officeAssignment = hz.getMultiMap( &quot;office-employee&quot; );
</code></pre>
<p>So far, we know all important information to work out some example aggregations. We will look into some deeper implementation
details and how we can work around some current limitations that will be eliminated in future versions of the API.</p>
<p>So let&#39;s start with an already seen, very basic example. We want to know the average salary of all of our employees. To do this,
we need a <code>PropertyExtractor</code> and the average aggregation for type <code>Integer</code>.</p>
<pre><code class="lang-java">IMap&lt;String, SalaryYear&gt; salaries = hazelcastInstance.getMap( &quot;salaries&quot; );
PropertyExtractor&lt;SalaryYear, Integer&gt; extractor =
    (salaryYear) -&gt; salaryYear.getAnnualSalary();
int avgSalary = salaries.aggregate( Supplier.all( extractor ),
                                    Aggregations.integerAvg() );
</code></pre>
<p>That&#39;s it. Internally, we created a map-reduce task based on the predefined aggregation and fire it up immediately. Currently, all
aggregation calls are blocking operations, so it is not yet possible to execute the aggregation in a reactive way (using
<code>com.hazelcast.core.ICompletableFuture</code>) but this will be part of one of the upcoming versions.</p>
<h4 id="map-join-example">Map Join Example</h4>
<p>The following example is already a bit more complex, so we only want to have our US based employees selected into the average
salary calculation, so we need to execute some kind of a join operation between the employees and salaries maps.</p>
<pre><code class="lang-java">class USEmployeeFilter implements KeyPredicate&lt;String&gt;, HazelcastInstanceAware {
  private transient HazelcastInstance hazelcastInstance;

  public void setHazelcastInstance( HazelcastInstance hazelcastInstance ) {
    this.hazelcastInstance = hazelcastInstance;
  }

  public boolean evaluate( String email ) {
    IMap&lt;String, Employee&gt; employees = hazelcastInstance.getMap( &quot;employees&quot; );
    Employee employee = employees.get( email );
    return &quot;US&quot;.equals( employee.getCountry() );
  }
}
</code></pre>
<p>Using the <code>HazelcastInstanceAware</code> interface, we get the current instance of Hazelcast injected into our filter and can perform data
joins on other data structures of the cluster. We now only select employees that work as part of our US offices into the
aggregation.</p>
<pre><code class="lang-java">IMap&lt;String, SalaryYear&gt; salaries = hazelcastInstance.getMap( &quot;salaries&quot; );
PropertyExtractor&lt;SalaryYear, Integer&gt; extractor =
    (salaryYear) -&gt; salaryYear.getAnnualSalary();
int avgSalary = salaries.aggregate( Supplier.fromKeyPredicate(
                                        new USEmployeeFilter(), extractor
                                    ), Aggregations.integerAvg() );
</code></pre>
<h4 id="grouping-example">Grouping Example</h4>
<p>For our next example, we will do some grouping based on the different worldwide offices. Currently, a group aggregator is not yet 
available, that means we need a small workaround to achieve this goal. In later versions of the Aggregations API this will not be 
required anymore since it will be available out of the box in a much more convenient way.</p>
<p>So again, let&#39;s start with our filter. This time we want to filter based on an office name and we again need to do some data joins
to achieve this kind of filtering. </p>
<p><strong>A short tip:</strong> to minimize the data transmission on the aggregation we can use
<a href="#data-affinity">Data Affinity</a> rules to influence the partitioning of data. Be aware that this is an expert feature of Hazelcast.</p>
<pre><code class="lang-java">class OfficeEmployeeFilter implements KeyPredicate&lt;String&gt;, HazelcastInstanceAware {
  private transient HazelcastInstance hazelcastInstance;
  private String office;

  // Deserialization Constructor
  public OfficeEmployeeFilter() {
  } 

  public OfficeEmployeeFilter( String office ) {
    this.office = office;
  }

  public void setHazelcastInstance( HazelcastInstance hazelcastInstance ) {
    this.hazelcastInstance = hazelcastInstance;
  }

  public boolean evaluate( String email ) {
    MultiMap&lt;String, String&gt; officeAssignment = hazelcastInstance
        .getMultiMap( &quot;office-employee&quot; );

    return officeAssignment.containsEntry( office, email );    
  }
}
</code></pre>
<p>Now, we can execute our aggregations. As mentioned, we currently need to do the grouping on our own by executing multiple
aggregations in a row but that will go away soon.</p>
<pre><code class="lang-java">Map&lt;String, Integer&gt; avgSalariesPerOffice = new HashMap&lt;String, Integer&gt;();

IMap&lt;String, SalaryYear&gt; salaries = hazelcastInstance.getMap( &quot;salaries&quot; );
MultiMap&lt;String, String&gt; officeAssignment =
    hazelcastInstance.getMultiMap( &quot;office-employee&quot; );

PropertyExtractor&lt;SalaryYear, Integer&gt; extractor =
    (salaryYear) -&gt; salaryYear.getAnnualSalary();

for ( String office : officeAssignment.keySet() ) {
  OfficeEmployeeFilter filter = new OfficeEmployeeFilter( office );
  int avgSalary = salaries.aggregate( Supplier.fromKeyPredicate( filter, extractor ),
                                      Aggregations.integerAvg() );

  avgSalariesPerOffice.put( office, avgSalary );
}
</code></pre>
<h4 id="simple-count-example">Simple Count Example</h4>
<p>After the previous example, we want to fade out from this section by executing one final, easy but nice aggregation. We
just want to know how many employees we currently have on a worldwide basis. Before reading the next lines of source code, you
can try to do it on your own to see if you understood the way of executing aggregations.</p>
<p>As said, this is again a very basic example but it is the perfect closing point for this section:</p>
<pre><code class="lang-java">IMap&lt;String, Employee&gt; employees = hazelcastInstance.getMap( &quot;employees&quot; );
int count = employees.size();
</code></pre>
<p>Ok, after that quick joke, we look at the real two code lines:</p>
<pre><code class="lang-java">IMap&lt;String, Employee&gt; employees = hazelcastInstance.getMap( &quot;employees&quot; );
int count = employees.aggregate( Supplier.all(), Aggregations.count() );
</code></pre>
<p>We now have a good overview of how to use aggregations in real life situations. If you want to do your colleagues a favor you
might want to end up writing your own additional set of aggregations. Then please read on the next section, if not just stop
here.</p>
<h3 id="implementing-aggregations">Implementing Aggregations</h3>
<p>This section explains how to implement your own aggregations for convenient reasons in your own application. It
is meant to be an advanced users section so if you do not intend to implement your own aggregation, you might want to
stop reading here and probably come back at a later point in time when there is the need to know how to implement your own
aggregation.</p>
<p>The main interface for making your own aggregation is <code>com.hazelcast.mapreduce.aggregation.Aggregation</code>. It consists of four
methods that can be explained very briefly.</p>
<pre><code class="lang-java">interface Aggregation&lt;Key, Supplied, Result&gt; {
  Mapper getMapper(Supplier&lt;Key, ?, Supplied&gt; supplier);
  CombinerFactory getCombinerFactory();
  ReducerFactory getReducerFactory();
  Collator&lt;Map.Entry, Result&gt; getCollator();
}
</code></pre>
<p>As we can see, an <code>Aggregation</code> implementation is nothing more than defining a map-reduce task with a small difference. The <code>Mapper</code>
is always expected to work on a <code>Supplier</code> that filters and / or transforms the mapped input value to some output value.</p>
<p>Whereas, <code>getMapper</code> and <code>getReducerFactory</code> are expected to return non-null values, <code>getCombinerFactory</code> and <code>getCollator</code> are
optional operations and do not need to be implemented. If you want to implement these, it heavily depends on your use case you want
to achieve.</p>
<p>For more information on how you implement mappers, combiners, reducer and collators you should have a look at the
<a href="#mapreduce">MapReduce</a> section, since it is out of the scope of this chapter to explain it.</p>
<p>For best speed and traffic usage, as mentioned in the map-reduce documentation, you should add a <code>Combiner</code> to your aggregation
whenever it is possible to do some kind of pre-reduction step.</p>
<p>Your implementation also should use DataSerializable or IdentifiedDataSerializable for best compatibility and speed / stream-size
reasons.</p>
<p><br></br></p>
<h2 id="continuous-query">Continuous Query</h2>
<p>Continuous query enables to listen to the modifications performed on specific map entries. It is an entry listener with predicates. Please see <a href="#entry-listener">Entry Listener</a> for information on how to add entry listeners to a map.</p>
<p>As an example, let&#39;s listen to the changes made on an employee with the surname &quot;Smith&quot;. First, let&#39;s create the <code>Employee</code> class.</p>
<pre><code class="lang-java">import java.io.Serializable;

public class Employee implements Serializable {

    private final String surname;

    public Employee(String surname) {
        this.surname = surname;
    }

    @Override
    public String toString() {
        return &quot;Employee{&quot; +
                &quot;surname=&#39;&quot; + surname + &#39;\&#39;&#39; +
                &#39;}&#39;;
    }
}
</code></pre>
<p>Then, let&#39;s create the continuous query by adding the entry listener with the <code>surname</code> predicate.</p>
<pre><code class="lang-java">import com.hazelcast.core.*;
import com.hazelcast.query.SqlPredicate;

public class ContinuousQuery {

    public static void main(String[] args) {
        HazelcastInstance hz = Hazelcast.newHazelcastInstance();
        IMap&lt;String, String&gt; map = hz.getMap(&quot;map&quot;);
        map.addEntryListener(new MyEntryListener(),
                new SqlPredicate(&quot;surname=smith&quot;), true);
        System.out.println(&quot;Entry Listener registered&quot;);
    }

    static class MyEntryListener
            implements EntryListener&lt;String, String&gt; {
        @Override
        public void entryAdded(EntryEvent&lt;String, String&gt; event) {
            System.out.println(&quot;Entry Added:&quot; + event);
        }

        @Override
        public void entryRemoved(EntryEvent&lt;String, String&gt; event) {
            System.out.println(&quot;Entry Removed:&quot; + event);
        }

        @Override
        public void entryUpdated(EntryEvent&lt;String, String&gt; event) {
            System.out.println(&quot;Entry Updated:&quot; + event);
        }

        @Override
        public void entryEvicted(EntryEvent&lt;String, String&gt; event) {
            System.out.println(&quot;Entry Evicted:&quot; + event);
        }

        @Override
        public void mapEvicted(MapEvent event) {
            System.out.println(&quot;Map Evicted:&quot; + event);

        }
    }
}
</code></pre>
<p>And now, let&#39;s play with the employee &quot;smith&quot; and see how that will be listened.</p>
<pre><code class="lang-java">import com.hazelcast.core.Hazelcast;
import com.hazelcast.core.HazelcastInstance;
import com.hazelcast.core.IMap;

public class Modify {

    public static void main(String[] args) {
        HazelcastInstance hz = Hazelcast.newHazelcastInstance();
        IMap&lt;String, Employee&gt; map = hz.getMap(&quot;map&quot;);

        map.put(&quot;1&quot;, new Employee(&quot;smith&quot;));
        map.put(&quot;2&quot;, new Employee(&quot;jordan&quot;));
        System.out.println(&quot;done&quot;);
        System.exit(0);
    }
}
</code></pre>
<p>When you first run the class <code>ContinuousQuery</code> and then <code>Modify</code>, you will see the output similar to the one below.</p>
<pre><code>entryAdded:EntryEvent {Address[192.168.178.10]:5702} key=1,oldValue=null,
value=Person{name= smith }, event=ADDED, by Member [192.168.178.10]:5702
</code></pre><p><br> </br></p>
<h1 id="user-defined-services">User Defined Services</h1>
<p>In the case of special/custom needs, Hazelcast&#39;s SPI (Service Provider Interface) module offers the users to develop their own distributed data structures and services.</p>
<h2 id="sample-case">Sample Case</h2>
<p>Throughout this section, a distributed counter that we are going to create, will be the guide to reveal the usage of Hazelcast SPI.</p>
<p>Here is our counter.</p>
<pre><code class="lang-java">public interface Counter{
   int inc(int amount);
}
</code></pre>
<p>This counter will have the below features:</p>
<ul>
<li>It is planned to be stored in Hazelcast. </li>
<li>Different cluster members can call it. </li>
<li>It will be scalable, meaning that the capacity for the number of counters scales with the number of cluster members.</li>
<li>It will be highly available, meaning that if a member hosting this counter goes down, a backup will be available on a different member.</li>
</ul>
<p>All these features are going to be realized with the steps below. In each step, a new functionality to this counter will be added.</p>
<ol>
<li>Create the class.</li>
<li>Enable the class.</li>
<li>Add properties.</li>
<li>Place a remote call.</li>
<li>Create the containers.</li>
<li>Enable partition migration.</li>
<li>Create the backups.</li>
</ol>
<h3 id="create-the-class">Create the Class</h3>
<p>To have the counter as a functioning distributed object, we need a class. This class (namely CounterService in our sample) will be the gateway between Hazelcast internals and the counter, so that we can add features to the counter. In this step the CounterService is created. Its lifecycle will be managed by Hazelcast. </p>
<p><code>CounterService</code> should implement the interface <code>com.hazelcast.spi.ManagedService</code> as shown below.</p>
<pre><code class="lang-java">import com.hazelcast.spi.ManagedService;
import com.hazelcast.spi.NodeEngine;

import java.util.Properties;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;

public class CounterService implements ManagedService {
    private NodeEngine nodeEngine;

    @Override
    public void init( NodeEngine nodeEngine, Properties properties ) {
        System.out.println( &quot;CounterService.init&quot; );
        this.nodeEngine = nodeEngine;
    }

    @Override
    public void shutdown( boolean terminate ) {
        System.out.println( &quot;CounterService.shutdown&quot; );
    }

    @Override
    public void reset() {
    }

}
</code></pre>
<p>As can be seen from the code, below methods are implemented. </p>
<ul>
<li><code>init</code>: This is called when this CounterService is initialized. <code>NodeEngine</code> enables access to Hazelcast internals such as <code>HazelcastInstance</code> and <code>PartitionService</code>. Also, the object <code>Properties</code> will provide us with creating our own properties.</li>
<li><code>shutdown</code>: This is called when CounterService is shutdown. It cleans up the resources.</li>
<li><code>reset</code>: This is called when cluster members face with Split-Brain issue. This occurs when disconnected members that have created their own cluster are merged back into the main cluster. Services can also implement the SplitBrainHandleService to indicate that they can take part in the merge process. For the CounterService we are going to implement as a no-op.</li>
</ul>
<h3 id="enable-the-class">Enable the Class</h3>
<p>Now, we need to enable the class <code>CounterService</code>. Declarative way of doing this is shown below.</p>
<pre><code class="lang-xml">&lt;network&gt;
   &lt;join&gt;&lt;multicast enabled=&quot;true&quot;/&gt; &lt;/join&gt;
&lt;/network&gt;
&lt;services&gt;
   &lt;service enabled=&quot;true&quot;&gt;
      &lt;name&gt;CounterService&lt;/name&gt;
      &lt;class-name&gt;CounterService&lt;/class-name&gt;
   &lt;/service&gt;
&lt;/services&gt;
</code></pre>
<p><code>CounterService</code> is declared within the <code>services</code> tag of configuration. </p>
<ul>
<li>Setting the <code>enabled</code> attribute as <code>true</code> enables the service.</li>
<li><code>name</code> attribute defines the name of the service. It should be a unique name (<code>CounterService</code> in our case) since it will be looked up when a remote call is made. Note that, the value of this attribute will be sent at each request. So, a longer value means more data (de)serialization. A good practice is giving an understandable name with the shortest possible length.</li>
<li><code>class-name</code>: Class name of the service (<code>CounterService</code> in our case). Class should have a <em>no-arg</em> constructor. Otherwise, the object cannot be initialized.</li>
</ul>
<p>Moreover, note that multicast is enabled as the join mechanism. In the later sections, we will see why.</p>
<h3 id="add-properties">Add Properties</h3>
<p>Remember that the <code>init</code> method takes <code>Properties</code> object as an argument. This means we can add properties to the service. These properties are passed to the method <code>init</code>. Adding properties can be done declaratively as shown below.</p>
<pre><code class="lang-xml">&lt;service enabled=&quot;true&quot;&gt;
   &lt;name&gt;CounterService&lt;/name&gt;
   &lt;class-name&gt;CounterService&lt;/class-name&gt;
   &lt;properties&gt; 
      &lt;someproperty&gt;10&lt;/someproperty&gt;
   &lt;/properties&gt;
&lt;/service&gt;
</code></pre>
<p>If you want to parse a more complex XML, the interface <code>com.hazelcast.spi.ServiceConfigurationParser</code> can be used. It gives you access to the XML DOM tree.</p>
<h3 id="start-the-service">Start the Service</h3>
<p>Now, let&#39;s start a HazelcastInstance as shown below, which will eagerly start the CounterService.</p>
<pre><code class="lang-java">import com.hazelcast.core.Hazelcast;

public class Member {
    public static void main(String[] args) {
        Hazelcast.newHazelcastInstance();
    }
}
</code></pre>
<p>Once it is started, below output will be seen.</p>
<p><code>CounterService.init</code></p>
<p>Once the HazelcastInstance is shutdown (for example with Ctrl+C), below output will be seen.</p>
<p><code>CounterService.shutdown</code></p>
<h3 id="place-a-remote-call-proxy">Place a Remote Call - Proxy</h3>
<p>Until so far, we accomplished only to start <code>CounterService</code> as part of a HazelcastInstance startup.</p>
<p>Now, let&#39;s connect the Counter interface to CounterService and perform a remote call to the cluster member hosting the counter data. Then, we are going to return a dummy result. </p>
<p>Remote calls are performed via a proxy in Hazelcast. Proxies expose the methods at the client side. Once a method is called, proxy creates an operation object, sends this object to the cluster member responsible from executing that operation and then sends the result. </p>
<p>First, we need to make the Counter interface a distributed object. It should extend the <code>DistributedObject</code> interface for this purpose, as shown below.</p>
<pre><code class="lang-java">import com.hazelcast.core.DistributedObject;

public interface Counter extends DistributedObject {
    int inc(int amount);
}
</code></pre>
<p>Now, we need to make the CounterService implementing not only the ManagedService interface, but also the interface <code>com.hazelcast.spi.RemoteService</code>. This way, a client will be able to get a handle of a counter proxy.</p>
<pre><code class="lang-java">import com.hazelcast.core.DistributedObject;
import com.hazelcast.spi.ManagedService;
import com.hazelcast.spi.NodeEngine;
import com.hazelcast.spi.RemoteService;

import java.util.Properties;

public class CounterService implements ManagedService, RemoteService {
    public static final String NAME = &quot;CounterService&quot;;

    private NodeEngine nodeEngine;

    @Override
    public DistributedObject createDistributedObject(String objectName) {
        return new CounterProxy(objectName, nodeEngine, this);
    }

    @Override
    public void destroyDistributedObject(String objectName) {
        // for the time being a no-op, but in the later examples this will be implemented
    }

    @Override
    public void init(NodeEngine nodeEngine, Properties properties) {
        this.nodeEngine = nodeEngine;
    }

    @Override
    public void shutdown(boolean terminate) {
    }

    @Override
    public void reset() {
    }
}
</code></pre>
<p>The <code>CounterProxy</code> returned by the method <code>createDistributedObject</code> is a local representation to (potentially) remote managed data and logic.
<br></br></p>
<p><img src="images/NoteSmall.jpg" alt="image"> <strong><em>NOTE:</em></strong> <em>Note that caching and removing the proxy instance are done outside of this service.</em>
<br></br></p>
<p>Now, it is time to implement the <code>CounterProxy</code> as shown below.</p>
<pre><code class="lang-java">import com.hazelcast.spi.AbstractDistributedObject;
import com.hazelcast.spi.InvocationBuilder;
import com.hazelcast.spi.NodeEngine;
import com.hazelcast.util.ExceptionUtil;

import java.util.concurrent.Future;

public class CounterProxy extends AbstractDistributedObject&lt;CounterService&gt; implements Counter {
    private final String name;

    public CounterProxy(String name, NodeEngine nodeEngine, CounterService counterService) {
        super(nodeEngine, counterService);
        this.name = name;
    }

    @Override
    public String getServiceName() {
        return CounterService.NAME;
    }

    @Override
    public String getName() {
        return name;
    }

    @Override
    public int inc(int amount) {
        NodeEngine nodeEngine = getNodeEngine();
        IncOperation operation = new IncOperation(name, amount);
        int partitionId = nodeEngine.getPartitionService().getPartitionId(name);
        InvocationBuilder builder = nodeEngine.getOperationService()
                .createInvocationBuilder(CounterService.NAME, operation, partitionId);
        try {
            final Future&lt;Integer&gt; future = builder.invoke();
            return future.get();
        } catch (Exception e) {
            throw ExceptionUtil.rethrow(e);
        }
    }
}
</code></pre>
<p><code>CounterProxy</code> is a local representation of remote data/functionality, it does not include the counter state. So, the method <code>inc</code> should be invoked on the cluster member hosting the real counter. This invocation can be performed using Hazelcast SPI. It will send the operations to the correct member and return the results.</p>
<p>Let&#39;s dig deeper into the method <code>inc</code>.</p>
<ul>
<li>First, we create <code>IncOperation</code> with a given <code>name</code> and <code>amount</code>.</li>
<li>Then, we get the partition ID based on the <code>name</code>; by this way, all operations for a given name will result in the same partition ID.</li>
<li>Then, we create an <code>InvocationBuilder</code> where the connection between operation and partition is made.</li>
<li>Finally, we invoke the <code>InvocationBuilder</code> and wait for its result. This waiting is performed simply with a <code>future.get()</code>. Of course, in our case, timeout is not important. However, it is a good practice to use a timeout for a real system since operations should be completed in a certain amount of time. </li>
</ul>
<p>Hazelcast&#39;s <code>ExceptionUtil</code> is a good solution when it comes to dealing with execution exceptions. When the execution of the operation fails with an exception, an <code>ExecutionException</code> is thrown and handled with the method <code>ExceptionUtil.rethrow(Throwable)</code>. </p>
<p>If it is an <code>InterruptedException</code>, we have two options: Either propagating the exception or just using the <code>ExceptionUtil.rethrow</code> for all exceptions. Please see below sample.</p>
<pre><code class="lang-java">  try {
     final Future&lt;Integer&gt; future = invocation.invoke();
     return future.get();
  } catch(InterruptedException e){
     throw e;
  } catch(Exception e){
     throw ExceptionUtil.rethrow(e);
  }
</code></pre>
<p>Now, let&#39;s write the <code>IncOperation</code>. It implements <code>PartitionAwareOperation</code> interface, meaning that it will be executed on partition that hosts the counter.</p>
<pre><code class="lang-java">import com.hazelcast.nio.ObjectDataInput;
import com.hazelcast.nio.ObjectDataOutput;
import com.hazelcast.spi.AbstractOperation;
import com.hazelcast.spi.PartitionAwareOperation;

import java.io.IOException;

class IncOperation extends AbstractOperation implements PartitionAwareOperation {
    private String objectId;
    private int amount, returnValue;

    // Important to have a no-arg constructor for deserialization
    public IncOperation() {
    }

    public IncOperation(String objectId, int amount) {
        this.amount = amount;
        this.objectId = objectId;
    }

    @Override
    public void run() throws Exception {
        System.out.println(&quot;Executing &quot; + objectId + &quot;.inc() on: &quot; + getNodeEngine().getThisAddress());
        returnValue = 0;
    }

    @Override
    public boolean returnsResponse() {
        return true;
    }

    @Override
    public Object getResponse() {
        return returnValue;
    }

    @Override
    protected void writeInternal(ObjectDataOutput out) throws IOException {
        super.writeInternal(out);
        out.writeUTF(objectId);
        out.writeInt(amount);
    }

    @Override
    protected void readInternal(ObjectDataInput in) throws IOException {
        super.readInternal(in);
        objectId = in.readUTF();
        amount = in.readInt();
    }
}
</code></pre>
<p>The method <code>run</code> does the actual execution. Since <code>IncOperation</code> will return a response, the method <code>returnsResponse</code> returns <code>true</code>. If your method is asynchronous and does not need to return a response, it is better to return <code>false</code> since it will be faster. Actual response is stored in the field <code>returnValue</code> field and it is retrieved by the method <code>getResponse</code>.</p>
<p>You see two other methods in the above code: <code>writeInternal</code> and <code>readInternal</code>. Since <code>IncOperation</code> needs to be serialized, these two methods should be overwritten. Hence, <code>objectId</code> and <code>amount</code> will be serialized and available when the operation is executed. For the deserialization, note that the operation must have a <em>no-arg</em> constructor.</p>
<p>Now, let&#39;s run our code.</p>
<pre><code class="lang-java">import com.hazelcast.core.Hazelcast;
import com.hazelcast.core.HazelcastInstance;

import java.util.UUID;

public class Member {
    public static void main(String[] args) {
        HazelcastInstance[] instances = new HazelcastInstance[2];
        for (int k = 0; k &lt; instances.length; k++)
            instances[k] = Hazelcast.newHazelcastInstance();

        Counter[] counters = new Counter[4];
        for (int k = 0; k &lt; counters.length; k++)
            counters[k] = instances[0].getDistributedObject(CounterService.NAME, k+&quot;counter&quot;);

        for (Counter counter : counters)
            System.out.println(counter.inc(1));

        System.out.println(&quot;Finished&quot;);
        System.exit(0);
    }
}
</code></pre>
<p>Once run, you will see the output as below.</p>
<p><code>Executing 0counter.inc() on: Address[192.168.1.103]:5702</code></p>
<p><code>0</code></p>
<p><code>Executing 1counter.inc() on: Address[192.168.1.103]:5702</code></p>
<p><code>0</code></p>
<p><code>Executing 2counter.inc() on: Address[192.168.1.103]:5701</code></p>
<p><code>0</code></p>
<p><code>Executing 3counter.inc() on: Address[192.168.1.103]:5701</code></p>
<p><code>0</code></p>
<p><code>Finished</code></p>
<p>As you see, counters are stored in different cluster members. Also note that, increment is not in its real action for now since the value remains as <strong>0</strong>. </p>
<p>So, until now, we have made the basics up and running. In the next section, we will make a more real counter, cache the proxy instances and deal with proxy instance destruction.</p>
<h3 id="create-the-containers">Create the Containers</h3>
<p>First, let&#39;s create a Container for every partition in the system, that will contain all counters and proxies.</p>
<pre><code class="lang-java">import java.util.HashMap;
import java.util.Map;

class Container {
    private final Map&lt;String, Integer&gt; values = new HashMap();

    int inc(String id, int amount) {
        Integer counter = values.get(id);
        if (counter == null) {
            counter = 0;
        }
        counter += amount;
        values.put(id, counter);
        return counter;
    }

    public void init(String objectName) {
        values.put(objectName,0);
    }

    public void destroy(String objectName) {
        values.remove(objectName);
    }

    ...
}
</code></pre>
<p>Hazelcast guarantees that a single thread will be active in a single partition. So, when accessing a container, concurrency control will not be an issue. </p>
<p>This section uses Container instance per partition approach. In this way, there will not be any mutable shared state between partitions. It also makes operations on partitions simpler since you do not need to filter out data that does not belong to a certain partition.</p>
<p>Now, let&#39;s integrate the Container in the CounterService, as shown below.</p>
<pre><code class="lang-java">import com.hazelcast.spi.ManagedService;
import com.hazelcast.spi.NodeEngine;
import com.hazelcast.spi.RemoteService;

import java.util.HashMap;
import java.util.Map;
import java.util.Properties;

public class CounterService implements ManagedService, RemoteService {
    public final static String NAME = &quot;CounterService&quot;;
    Container[] containers;
    private NodeEngine nodeEngine;

    @Override
    public void init(NodeEngine nodeEngine, Properties properties) {
        this.nodeEngine = nodeEngine;
        containers = new Container[nodeEngine.getPartitionService().getPartitionCount()];
        for (int k = 0; k &lt; containers.length; k++)
            containers[k] = new Container();
    }

    @Override
    public void shutdown(boolean terminate) {
    }

    @Override
    public CounterProxy createDistributedObject(String objectName) {
        int partitionId = nodeEngine.getPartitionService().getPartitionId(objectName);
        Container container = containers[partitionId];
        container.init(objectName);
        return new CounterProxy(objectName, nodeEngine, this);
    }

    @Override
    public void destroyDistributedObject(String objectName) {
        int partitionId = nodeEngine.getPartitionService().getPartitionId(objectName);
        Container container = containers[partitionId];
        container.destroy(objectName);
    }

    @Override
    public void reset() {
    }

    public static class Container {
        final Map&lt;String, Integer&gt; values = new HashMap&lt;String, Integer&gt;();

        private void init(String objectName) {
            values.put(objectName, 0);
        }

        private void destroy(String objectName){
            values.remove(objectName);
        }
    }
}
</code></pre>
<p>As you see, a container for every partition is created with the method <code>init</code>. Then, we create the proxy with the method <code>createDistributedObject</code>. And finally, we need to remove the value of the object, using the method <code>destroyDistributedObject</code>. Otherwise, we may get OutOfMemory exception.</p>
<p>And now, as the last step in creating a Container, we will connect the method <code>IncOperation.run</code> to the Container, as shown below.</p>
<pre><code class="lang-java">import com.hazelcast.nio.ObjectDataInput;
import com.hazelcast.nio.ObjectDataOutput;
import com.hazelcast.spi.AbstractOperation;
import com.hazelcast.spi.PartitionAwareOperation;

import java.io.IOException;
import java.util.Map;

class IncOperation extends AbstractOperation implements PartitionAwareOperation {
    private String objectId;
    private int amount, returnValue;

    public IncOperation() {
    }

    public IncOperation(String objectId, int amount) {
        this.amount = amount;
        this.objectId = objectId;
    }

    @Override
    public void run() throws Exception {
        System.out.println(&quot;Executing &quot; + objectId + &quot;.inc() on: &quot; + getNodeEngine().getThisAddress());
        CounterService service = getService();
        CounterService.Container container = service.containers[getPartitionId()];
        Map&lt;String, Integer&gt; valuesMap = container.values;

        Integer counter = valuesMap.get(objectId);
        counter += amount;
        valuesMap.put(objectId, counter);
        returnValue = counter;
    }

    @Override
    public boolean returnsResponse() {
        return true;
    }

    @Override
    public Object getResponse() {
        return returnValue;
    }

    @Override
    protected void writeInternal(ObjectDataOutput out) throws IOException {
        super.writeInternal(out);
        out.writeUTF(objectId);
        out.writeInt(amount);
    }

    @Override
    protected void readInternal(ObjectDataInput in) throws IOException {
        super.readInternal(in);
        objectId = in.readUTF();
        amount = in.readInt();
    }
}
</code></pre>
<p><code>partitionId</code> has a range between <strong>0</strong> and <strong>partitionCount</strong> and can be used as an index for the container array. Therefore, <code>partitionId</code> can easily be used to retrieve the container. And once the container has been retrieved, we can access the value. </p>
<p>Let&#39;s run the below sample code.</p>
<pre><code class="lang-java">import com.hazelcast.core.Hazelcast;
import com.hazelcast.core.HazelcastInstance;

public class Member {
    public static void main(String[] args) {
        HazelcastInstance[] instances = new HazelcastInstance[2];
        for (int k = 0; k &lt; instances.length; k++)
            instances[k] = Hazelcast.newHazelcastInstance();

        Counter[] counters = new Counter[4];
        for (int k = 0; k &lt; counters.length; k++)
            counters[k] = instances[0].getDistributedObject(CounterService.NAME, k+&quot;counter&quot;);

        System.out.println(&quot;Round 1&quot;);
        for (Counter counter: counters)
            System.out.println(counter.inc(1));

        System.out.println(&quot;Round 2&quot;);
        for (Counter counter: counters)
            System.out.println(counter.inc(1));

        System.out.println(&quot;Finished&quot;);
        System.exit(0);
    }
}
</code></pre>
<p>The output will be seen as follows.</p>
<pre><code>Round 1
Executing 0counter.inc() on: Address[192.168.1.103]:5702
1
Executing 1counter.inc() on: Address[192.168.1.103]:5702
1
Executing 2counter.inc() on: Address[192.168.1.103]:5701
1
Executing 3counter.inc() on: Address[192.168.1.103]:5701
1
Round 2
Executing 0counter.inc() on: Address[192.168.1.103]:5702
2
Executing 1counter.inc() on: Address[192.168.1.103]:5702
2
Executing 2counter.inc() on: Address[192.168.1.103]:5701
2
Executing 3counter.inc() on: Address[192.168.1.103]:5701
2
Finished
</code></pre><p>Above output indicates that we have now a basic distributed counter up and running.</p>
<h3 id="partition-migration">Partition Migration</h3>
<p>In the previous section, we created a real distributed counter. Now, we need to make sure that the content of partition containers is migrated to different cluster members, when a member is joining to or leaving the cluster. To make this happen, first we need to add three new methods (<code>applyMigrationData</code>, <code>toMigrationData</code> and <code>clear</code>) to the Container, as shown below.</p>
<pre><code class="lang-java">import java.util.HashMap;
import java.util.Map;

class Container {
    private final Map&lt;String, Integer&gt; values = new HashMap();

    int inc(String id, int amount) {
        Integer counter = values.get(id);
        if (counter == null) {
            counter = 0;
        }
        counter += amount;
        values.put(id, counter);
        return counter;
    }

    void clear() {
        values.clear();
    }

    void applyMigrationData(Map&lt;String, Integer&gt; migrationData) {
        values.putAll(migrationData);
    }

    Map&lt;String, Integer&gt; toMigrationData() {
        return new HashMap(values);
    }

    public void init(String objectName) {
        values.put(objectName,0);
    }

    public void destroy(String objectName) {
        values.remove(objectName);
    }
}
</code></pre>
<ul>
<li><code>toMigrationData</code>: This is called when Hazelcast wants to start the partition migration from the member owning the partition. The result of this method is the partition data in a form so that it can be serialized to another member.</li>
<li><code>applyMigrationData</code>: This is called when <code>migrationData</code> (created by the method <code>toMigrationData</code>) is going to be applied to the member that is going to be the new partition owner.</li>
<li><code>clear</code>: This is called when the partition migration is successfully completed and the old partition owner gets rid of all data in the partition. This method is called also when the partition migration operation fails and to-be-the-new partition owner needs to roll back its changes.</li>
</ul>
<p>After these three methods are added to the Container, we need to create a <code>CounterMigrationOperation</code> class that transfers <code>migrationData</code> from one member to another and calls the method <code>applyMigrationData</code> on the correct partition of the new partition owner. A sample is shown below.</p>
<pre><code class="lang-java">import com.hazelcast.nio.ObjectDataInput;
import com.hazelcast.nio.ObjectDataOutput;
import com.hazelcast.spi.AbstractOperation;

import java.io.IOException;
import java.util.HashMap;
import java.util.Map;

public class CounterMigrationOperation extends AbstractOperation {

    Map&lt;String, Integer&gt; migrationData;

    public CounterMigrationOperation() {
    }

    public CounterMigrationOperation(Map&lt;String, Integer&gt; migrationData) {
        this.migrationData = migrationData;
    }

    @Override
    public void run() throws Exception {
        CounterService service = getService();
        Container container = service.containers[getPartitionId()];
        container.applyMigrationData(migrationData);
    }

    @Override
    protected void writeInternal(ObjectDataOutput out) throws IOException {
        out.writeInt(migrationData.size());
        for (Map.Entry&lt;String, Integer&gt; entry : migrationData.entrySet()) {
            out.writeUTF(entry.getKey());
            out.writeInt(entry.getValue());
        }
    }

    @Override
    protected void readInternal(ObjectDataInput in) throws IOException {
        int size = in.readInt();
        migrationData = new HashMap&lt;String, Integer&gt;();
        for (int i = 0; i &lt; size; i++)
            migrationData.put(in.readUTF(), in.readInt());
    }
}
</code></pre>
<p><br></br>
<img src="images/NoteSmall.jpg" alt="image"> <strong><em>NOTE:</em></strong> <em>During a partition migration, no other operations are executed on the related partition.</em>
<br></br></p>
<p>Now, we need to make our CounterService class to also implement  <code>MigrationAwareService</code> interface. By this way, Hazelcast knows that the CounterService will be able to perform partition migration. See the below code.</p>
<pre><code class="lang-java">import com.hazelcast.core.DistributedObject;
import com.hazelcast.partition.MigrationEndpoint;
import com.hazelcast.spi.*;

import java.util.Map;
import java.util.Properties;

public class CounterService implements ManagedService, RemoteService, MigrationAwareService {
    public final static String NAME = &quot;CounterService&quot;;
    Container[] containers;
    private NodeEngine nodeEngine;

    @Override
    public void init(NodeEngine nodeEngine, Properties properties) {
        this.nodeEngine = nodeEngine;
        containers = new Container[nodeEngine.getPartitionService().getPartitionCount()];
        for (int k = 0; k &lt; containers.length; k++)
            containers[k] = new Container();
    }

    @Override
    public void shutdown(boolean terminate) {
    }

    @Override
    public DistributedObject createDistributedObject(String objectName) {
        int partitionId = nodeEngine.getPartitionService().getPartitionId(objectName);
        Container container = containers[partitionId];
        container.init(objectName);
        return new CounterProxy(objectName, nodeEngine,this);
    }

    @Override
    public void destroyDistributedObject(String objectName) {
        int partitionId = nodeEngine.getPartitionService().getPartitionId(objectName);
        Container container = containers[partitionId];
        container.destroy(objectName);
    }

    @Override
    public void beforeMigration(PartitionMigrationEvent e) {
        //no-op
    }

    @Override
    public void clearPartitionReplica(int partitionId) {
        Container container = containers[partitionId];
        container.clear();
    }

    @Override
    public Operation prepareReplicationOperation(PartitionReplicationEvent e) {
        if (e.getReplicaIndex() &gt; 1) {
            return null;
        }
        Container container = containers[e.getPartitionId()];
        Map&lt;String, Integer&gt; data = container.toMigrationData();
        return data.isEmpty() ? null : new CounterMigrationOperation(data);
    }

    @Override
    public void commitMigration(PartitionMigrationEvent e) {
        if (e.getMigrationEndpoint() == MigrationEndpoint.SOURCE) {
            Container c = containers[e.getPartitionId()];
            c.clear();
        }

        //todo
    }

    @Override
    public void rollbackMigration(PartitionMigrationEvent e) {
        if (e.getMigrationEndpoint() == MigrationEndpoint.DESTINATION) {
            Container c = containers[e.getPartitionId()];
            c.clear();
        }
    }

    @Override
    public void reset() {
    }
}
</code></pre>
<p>With the <code>MigrationAwareService</code> interface, some additional methods are exposed. For example, the method <code>prepareMigrationOperation</code> returns all the data of the partition that is going to be moved.</p>
<p>The method <code>commitMigration</code> commits the data, meaning in this case, clears the partition container of the old owner. </p>
<pre><code class="lang-java">import com.hazelcast.core.Hazelcast;
import com.hazelcast.core.HazelcastInstance;

public class Member {
    public static void main(String[] args) throws Exception {
        HazelcastInstance[] instances = new HazelcastInstance[3];
        for (int k = 0; k &lt; instances.length; k++)
            instances[k] = Hazelcast.newHazelcastInstance();

        Counter[] counters = new Counter[4];
        for (int k = 0; k &lt; counters.length; k++)
            counters[k] = instances[0].getDistributedObject(CounterService.NAME, k + &quot;counter&quot;);

        for (Counter counter : counters)
            System.out.println(counter.inc(1));

        Thread.sleep(10000);

        System.out.println(&quot;Creating new members&quot;);

        for (int k = 0; k &lt; 3; k++) {
            Hazelcast.newHazelcastInstance();
        }

        Thread.sleep(10000);

        for (Counter counter : counters)
            System.out.println(counter.inc(1));

        System.out.println(&quot;Finished&quot;);
        System.exit(0);
    }
}
</code></pre>
<p>Once we run the above code, the output will be seen as follows.</p>
<pre><code>Executing 0counter.inc() on: Address[192.168.1.103]:5702
Executing backup 0counter.inc() on: Address[192.168.1.103]:5703
1
Executing 1counter.inc() on: Address[192.168.1.103]:5703
Executing backup 1counter.inc() on: Address[192.168.1.103]:5701
1
Executing 2counter.inc() on: Address[192.168.1.103]:5701
Executing backup 2counter.inc() on: Address[192.168.1.103]:5703
1
Executing 3counter.inc() on: Address[192.168.1.103]:5701
Executing backup 3counter.inc() on: Address[192.168.1.103]:5703
1
Creating new members
Executing 0counter.inc() on: Address[192.168.1.103]:5705
Executing backup 0counter.inc() on: Address[192.168.1.103]:5703
2
Executing 1counter.inc() on: Address[192.168.1.103]:5703
Executing backup 1counter.inc() on: Address[192.168.1.103]:5704
2
Executing 2counter.inc() on: Address[192.168.1.103]:5705
Executing backup 2counter.inc() on: Address[192.168.1.103]:5704
2
Executing 3counter.inc() on: Address[192.168.1.103]:5704
Executing backup 3counter.inc() on: Address[192.168.1.103]:5705
2
Finished
</code></pre><p>As it can be seen the counters have moved. <code>0counter</code> moved from <em>192.168.1.103:5702</em> to <em>192.168.1.103:5705</em> and it is incremented correctly. as a result, our counters are now able to move around in the cluster. You will see the the counters will be redistributed once you add or remove a cluster member.</p>
<h3 id="create-the-backups">Create the Backups</h3>
<p>In this last phase, we make sure that the data of counter is available on another node when a member goes down. We need to have <code>IncOperation</code> class to implement <code>BackupAwareOperation</code> interface contained in SPI package. See the below code.</p>
<pre><code class="lang-java">class IncOperation extends AbstractOperation 
    implements PartitionAwareOperation, BackupAwareOperation {
   ...   

   @Override
   public int getAsyncBackupCount() {
      return 0;
   }

   @Override
   public int getSyncBackupCount() {
      return 1;
   }

   @Override
   public boolean shouldBackup() {
      return true;
   }

   @Override
   public Operation getBackupOperation() {
      return new IncBackupOperation(objectId, amount);
   }
}
</code></pre>
<p>The methods <code>getAsyncBackupCount</code> and <code>getSyncBackupCount</code> specifies the count of asynchronous and synchronous backups. For our sample, it is just one synchronous backup and no asynchronous backups. In the above code, counts of backups are hard coded, but they can also be passed to <code>IncOperation</code> as parameters. </p>
<p>The method <code>shouldBackup</code> specifies whether our Operation needs a backup or not. For our sample, it returns <code>true</code>, meaning the Operation will always have a backup even if there are no changes. Of course, in real systems, we want to have backups if there is a change. For <code>IncOperation</code> for example, having a backup when <code>amount</code> is null would be a good practice.</p>
<p>The method <code>getBackupOperation</code> returns the operation (<code>IncBackupOperation</code>) that actually performs the backup creation; as you noticed now, the backup itself is an operation and will run on the same infrastructure. </p>
<p>If, for example, a backup should be made and <code>getSyncBackupCount</code> returns <strong>3</strong>, then three <code>IncBackupOperation</code> instances are created and sent to the three machines containing the backup partition. If there are less machines available, then backups need to be created. Hazelcast will just send a smaller number of operations. </p>
<p>Now, let&#39;s have a look at the <code>IncBackupOperation</code>.</p>
<pre><code class="lang-java">public class IncBackupOperation 
    extends AbstractOperation implements BackupOperation {
   private String objectId;
   private int amount;

   public IncBackupOperation() {
   }

   public IncBackupOperation(String objectId, int amount) {
      this.amount = amount;
      this.objectId = objectId;
   }

   @Override
   protected void writeInternal(ObjectDataOutput out) throws IOException {
      super.writeInternal(out);
      out.writeUTF(objectId);
      out.writeInt(amount);
   }

   @Override
   protected void readInternal(ObjectDataInput in) throws IOException {
      super.readInternal(in);
      objectId = in.readUTF();
      amount = in.readInt();
   }

   @Override
   public void run() throws Exception {
      CounterService service = getService();
      System.out.println(&quot;Executing backup &quot; + objectId + &quot;.inc() on: &quot; 
        + getNodeEngine().getThisAddress());
      Container c = service.containers[getPartitionId()];
      c.inc(objectId, amount);
   }
}
</code></pre>
<p><br></br>
<img src="images/NoteSmall.jpg" alt="image"> <strong><em>NOTE:</em></strong> <em>Hazelcast will also make sure that a new IncOperation for that particular key will not be executed before the (synchronous) backup operation has completed.</em>
<br></br></p>
<p>Let&#39;s see the backup functionality in action with the below code.</p>
<pre><code class="lang-java">public class Member {
   public static void main(String[] args) throws Exception {
      HazelcastInstance[] instances = new HazelcastInstance[2];
      for (int k = 0; k &lt; instances.length; k++) 
         instances[k] = Hazelcast.newHazelcastInstance();

      Counter counter = instances[0].getDistributedObject(CounterService.NAME, &quot;counter&quot;);
      counter.inc(1);
      System.out.println(&quot;Finished&quot;);
      System.exit(0);
    }
}
</code></pre>
<p>Once it is run, the following output will be seen.</p>
<pre><code>Executing counter0.inc() on: Address[192.168.1.103]:5702
Executing backup counter0.inc() on: Address[192.168.1.103]:5701
Finished
</code></pre><p>As it can be seen, both <code>IncOperation</code> and <code>IncBackupOperation</code> are executed. Notice that these operations have been executed on different cluster members to guarantee high availability.</p>
<h2 id="waitnotifyservice">WaitNotifyService</h2>
<p><code>WaitNotifyService</code> is an interface offered by SPI for the objects (e.g. Lock, Semaphore) to be used when a thread needs to wait for a lock to be released.</p>
<p>This service keeps a list of waiters. For each notify operation;</p>
<ul>
<li>it looks for a waiter,</li>
<li>asks the waiter whether it wants to keep waiting,</li>
<li>if the waiter responds <em>no</em>, the service executes its registered operation (operation itself knows where to send a response),</li>
<li>rinses and repeats until a waiter wants to keep waiting.</li>
</ul>
<p>Each waiter can sit on wait-notify queue at most its operation&#39;s call timeout. For example, by default, each waiter can wait here for at most 1 minute. There is a continuous task that scans expired/timed-out waiters and invalidates them with <code>CallTimeoutException</code>. Each waiter on the remote side should retry and keep waiting if it still wants to wait. This is a liveness check for remote waiters. </p>
<p>This way, it is possible to distinguish an unresponsive node and a long (~infinite) wait. On the caller side, if waiting thread does not get a response for either a call timeout or for more than <em>2 times the call-timeout</em>, it will exit with <code>OperationTimeoutException</code>.  </p>
<p>As can be noticed, this behavior breaks the fairness. Hazelcast does not support fairness for any of the data structures with blocking operations (i.e. lock and semaphore).</p>
<h1 id="transactions">Transactions</h1>
<h2 id="transaction-interface">Transaction Interface</h2>
<p>Hazelcast can be used in transactional context. Basically, create a <code>TransactionContext</code> which can be used to begin, commit, and rollback a transaction. Obtain transaction aware instances of queues, maps, sets, lists, multimaps via <code>TransactionContext</code>, work with them and commit/rollback in one shot.</p>
<p>Hazelcast supports two types of transactions: LOCAL (One Phase) and TWO_PHASE. With the type, you have influence on how much guarantee you get when a member crashes while a transaction is committing. Default behavior is TWO_PHASE.</p>
<ul>
<li><p><strong>LOCAL</strong>: Unlike the name suggests, local is a two phase commit. First, all cohorts are asked to prepare; if everyone agrees then all cohorts are asked to commit. The problem happens when during the commit phase one or more members crash, that the system could be left in an inconsistent state.</p>
</li>
<li><p><strong>TWO_PHASE</strong>: The two phase commit is more than the classic two phase commit (if you want a regular two phase commit, use local). Before it commits, it copies the commit-log to other members, so in case of member failure, another member can complete the commit.</p>
</li>
</ul>
<pre><code class="lang-java">import java.util.Queue;
import java.util.Map;
import java.util.Set;
import com.hazelcast.core.Hazelcast;
import com.hazelcast.core.Transaction; 

HazelcastInstance hazelcastInstance = Hazelcast.newHazelcastInstance();

TransactionOptions options = new TransactionOptions()
    .setTransactionType( TransactionType.LOCAL );

TransactionContext context = hazelcastInstance.newTransactionContext( options )
context.beginTransaction();

TransactionalQueue queue = context.getQueue( &quot;myqueue&quot; );
TransactionalMap map = context.getMap( &quot;mymap&quot; );
TransactionalSet set = context.getSet( &quot;myset&quot; );

try {
  Object obj = queue.poll();
  //process obj
  map.put( &quot;1&quot;, &quot;value1&quot; );
  set.add( &quot;value&quot; );
  //do other things..
  context.commitTransaction();
} catch ( Throwable t ) {
  context.rollbackTransaction();
}
</code></pre>
<p>In a transaction, operations will not be executed immediately. Their changes will be local to the <code>TransactionContext</code> until committed. But, they will ensure the changes via locks. </p>
<p>For the above example, when <code>map.put</code> is executed, no data will be put to the map but the key will get locked for changes. While committing, operations will get executed, value will be put to the map and key will be unlocked.</p>
<p>Isolation is always <code>REPEATABLE_READ</code>. If you are in a transaction, you can read the data in your transaction and the data that is already committed. If you are not in a transaction, you can only read the committed data. </p>
<p>Implementation is different for queue/set/list and map/multimap. For queue operations (offer, poll), offered and/or polled objects are copied to the owner member in order to safely commit/rollback. For map/multimap, Hazelcast first acquires the locks for the write operations (put, remove) and holds the differences (what is added/removed/updated) locally for each transaction. When transaction is set to commit, Hazelcast will release the locks and apply the differences. When rolling back, Hazelcast will simply release the locks and discard the differences.</p>
<p><code>MapStore</code> and <code>QueueStore</code> does not participate in transactions. Hazelcast will suppress exceptions thrown by store in a transaction. Please refer to <a href="#xa-transactions">XA Transactions</a> section for further information.</p>
<h2 id="xa-transactions">XA Transactions</h2>
<p>XA describes the interface between the global transaction manager and the local resource manager. The goal of XA is to allow multiple resources (such as databases, application servers, message queues, transactional caches, etc.) to be accessed within the same transaction, thereby preserving the ACID properties across applications. XA uses a two-phase commit to ensure that all resources either commit or rollback any particular transaction consistently (all do the same).</p>
<p>By implementing <code>XAResource</code> interface, Hazelcast provides XA transactions. <code>XAResource</code> instance can be obtained via <code>TransactionContext</code>.
Below is a sample code which uses Atomikos for transaction management.</p>
<pre><code class="lang-java">UserTransactionManager tm = new UserTransactionManager();
tm.setTransactionTimeout(60);
tm.begin();

HazelcastInstance hazelcastInstance = Hazelcast.newHazelcastInstance();
TransactionContext context = hazelcastInstance.newTransactionContext();
XAResource xaResource = context.getXaResource();

Transaction transaction = tm.getTransaction();
transaction.enlistResource(xaResource);
// other resources (database, app server etc...) can be enlisted

try {
  TransactionalMap map = context.getMap(&quot;m&quot;);
  map.put(&quot;key&quot;, &quot;value&quot;);
  // other resource operations

  tm.commit();
} catch (Exception e) {
  tm.rollback();
}
</code></pre>
<h2 id="j2ee-integration">J2EE Integration</h2>
<p>Hazelcast can be integrated into J2EE containers via Hazelcast Resource Adapter (<code>hazelcast-jca-rar-</code><em>version</em><code>.rar</code>). After proper configuration, Hazelcast can participate in standard J2EE transactions.</p>
<pre><code class="lang-java">&lt;%@page import=&quot;javax.resource.ResourceException&quot; %&gt;
&lt;%@page import=&quot;javax.transaction.*&quot; %&gt;
&lt;%@page import=&quot;javax.naming.*&quot; %&gt;
&lt;%@page import=&quot;javax.resource.cci.*&quot; %&gt;
&lt;%@page import=&quot;java.util.*&quot; %&gt;
&lt;%@page import=&quot;com.hazelcast.core.*&quot; %&gt;
&lt;%@page import=&quot;com.hazelcast.jca.*&quot; %&gt;

&lt;%
UserTransaction txn = null;
HazelcastConnection conn = null;
HazelcastInstance hazelcastInstance = Hazelcast.newHazelcastInstance();

try {
  Context context = new InitialContext();
  txn = (UserTransaction) context.lookup( &quot;java:comp/UserTransaction&quot; );
  txn.begin();

  HazelcastConnectionFactory cf = (HazelcastConnectionFactory)
      context.lookup ( &quot;java:comp/env/HazelcastCF&quot; );

  conn = cf.getConnection();

  TransactionalMap&lt;String, String&gt; txMap = conn.getTransactionalMap( &quot;default&quot; );
  txMap.put( &quot;key&quot;, &quot;value&quot; );

  txn.commit();

} catch ( Throwable e ) {
  if ( txn != null ) {
    try {
      txn.rollback();
    } catch ( Exception ix ) {
      ix.printStackTrace();
    };
  }
  e.printStackTrace();
} finally {
  if ( conn != null ) {
    try {
      conn.close();
    } catch (Exception ignored) {};
  }
}
%&gt;
</code></pre>
<h3 id="sample-code-for-j2ee-integration">Sample Code for J2EE Integration</h3>
<p>Please see our sample application for <a href="https://github.com/hazelcast/hazelcast-code-samples/tree/master/hazelcast-integration/jca-ra">J2EE Integration</a>.</p>
<h3 id="resource-adapter-configuration">Resource Adapter Configuration</h3>
<p>Deploying and configuring Hazelcast resource adapter is no different than any other resource adapter since it is a standard JCA one. However, resource adapter installation and configuration is container specific, so please consult your J2EE vendor documentation for details. Most common steps are:</p>
<ol>
<li>Add the <code>hazelcast-</code><em>version</em><code>.jar</code> and <code>hazelcast-jca-</code><em>version</em><code>.jar</code> to container&#39;s classpath. Usually there is a lib directory that is loaded automatically by the container on startup.</li>
<li>Deploy <code>hazelcast-jca-rar-</code><em>version</em><code>.rar</code>. Usually there is some kind of a deploy directory. Name of the directory varies by container.</li>
<li>Make container specific configurations when/after deploying <code>hazelcast-jca-rar-</code><em>version</em><code>.rar</code>. Besides container specific configurations, JNDI name for Hazelcast resource is set.</li>
<li>Configure your application to use the Hazelcast resource. Update <code>web.xml</code> and/or <code>ejb-jar.xml</code> to let container know that your application will use the Hazelcast resource and define the resource reference.</li>
<li>Make container specific application configuration to specify JNDI name used for the resource in the application.</li>
</ol>
<h3 id="sample-glassfish-v3-web-application-configuration">Sample Glassfish v3 Web Application Configuration</h3>
<ol>
<li>Place the <code>hazelcast-</code><em>version</em><code>.jar</code> and <code>hazelcast-jca-</code><em>version</em><code>.jar</code> into <code>GLASSFISH_HOME/glassfish/domains/domain1/lib/ext/</code> directory.</li>
<li>Place the <code>hazelcast-jca-rar-</code><em>version</em><code>.rar</code> into <code>GLASSFISH_HOME/glassfish/domains/domain1/autodeploy/</code> directory.</li>
<li>Add the following lines to the <code>web.xml</code> file.</li>
</ol>
<pre><code class="lang-xml">&lt;resource-ref&gt;
  &lt;res-ref-name&gt;HazelcastCF&lt;/res-ref-name&gt;
  &lt;res-type&gt;com.hazelcast.jca.ConnectionFactoryImpl&lt;/res-type&gt;
  &lt;res-auth&gt;Container&lt;/res-auth&gt;
&lt;/resource-ref&gt;
</code></pre>
<p>Notice that, we did not have to put <code>sun-ra.xml</code> into the RAR file since it comes with the <code>hazelcast-ra-</code><em>version</em><code>.rar</code> file already.</p>
<p>If Hazelcast resource is used from EJBs, you should configure <code>ejb-jar.xml</code> for resource reference and JNDI definitions, just like we did for <code>web.xml</code>.</p>
<h3 id="sample-jboss-as-5-web-application-configuration">Sample JBoss AS 5 Web Application Configuration</h3>
<ul>
<li>Place the <code>hazelcast-</code><em>version</em><code>.jar</code> and <code>hazelcast-jca-</code><em>version</em><code>.jar</code> into <code>JBOSS_HOME/server/deploy/default/lib</code> directory.</li>
<li>Place the <code>hazelcast-jca-rar-</code><em>version</em><code>.rar</code> into <code>JBOSS_HOME/server/deploy/default/deploy</code> directory</li>
<li>Create a <code>hazelcast-ds.xml</code> file at <code>JBOSS_HOME/server/deploy/default/deploy</code> directory containing below content. Make sure to set the <code>rar-name</code> element to <code>hazelcast-ra-</code><em>version</em><code>.rar</code>.</li>
</ul>
<pre><code class="lang-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE connection-factories
  PUBLIC &quot;-//JBoss//DTD JBOSS JCA Config 1.5//EN&quot;
  &quot;http://www.jboss.org/j2ee/dtd/jboss-ds_1_5.dtd&quot;&gt;

&lt;connection-factories&gt;
  &lt;tx-connection-factory&gt;
    &lt;local-transaction/&gt;
    &lt;track-connection-by-tx&gt;true&lt;/track-connection-by-tx&gt;
    &lt;jndi-name&gt;HazelcastCF&lt;/jndi-name&gt;
    &lt;rar-name&gt;hazelcast-jca-rar-&lt;version&gt;.rar&lt;/rar-name&gt;
    &lt;connection-definition&gt;
       javax.resource.cci.ConnectionFactory
    &lt;/connection-definition&gt;
  &lt;/tx-connection-factory&gt;
&lt;/connection-factories&gt;
</code></pre>
<ul>
<li>Add the following lines to the <code>web.xml</code> file.</li>
</ul>
<pre><code class="lang-xml">&lt;resource-ref&gt;
  &lt;res-ref-name&gt;HazelcastCF&lt;/res-ref-name&gt;
  &lt;res-type&gt;com.hazelcast.jca.ConnectionFactoryImpl&lt;/res-type&gt;
  &lt;res-auth&gt;Container&lt;/res-auth&gt;
&lt;/resource-ref&gt;
</code></pre>
<ul>
<li>Add the following lines to the <code>jboss-web.xml</code> file.</li>
</ul>
<pre><code class="lang-xml">&lt;resource-ref&gt;
  &lt;res-ref-name&gt;HazelcastCF&lt;/res-ref-name&gt;
  &lt;jndi-name&gt;java:HazelcastCF&lt;/jndi-name&gt;
&lt;/resource-ref&gt;
</code></pre>
<p>If Hazelcast resource is used from EJBs, you should configure <code>ejb-jar.xml</code> and <code>jboss.xml</code> for resource reference and JNDI definitions.</p>
<p><br> </br></p>
<h3 id="sample-jboss-as-7-eap-6-web-application-configuration">Sample JBoss AS 7 / EAP 6 Web Application Configuration</h3>
<p>Deployment on JBoss AS 7 or JBoss EAP 6 is a fairly straightforward process, steps of which are shown below. The only non-trivial step is the creation of a new JBoss module with Hazelcast libraries.     </p>
<ul>
<li>Create the directory <code>&lt;jboss_home&gt;/modules/system/layers/base/com/hazelcast/main</code>.</li>
<li>Place the <code>hazelcast-</code>&lt;<em>version</em>&gt;<code>.jar</code> and <code>hazelcast-jca-</code>&lt;<em>version</em>&gt;<code>.jar</code> into the directory you created in the previous step.</li>
<li><p>Create the file <code>module.xml</code> and place it to the same directory. This file should have the below content.</p>
<pre><code class="lang-xml">&lt;module xmlns=&quot;urn:jboss:module:1.0&quot; name=&quot;com.hazelcast&quot;&gt;
&lt;resources&gt;
  &lt;resource-root path=&quot;.&quot;/&gt;
  &lt;resource-root path=&quot;hazelcast-&lt;version&gt;.jar&quot;/&gt;
  &lt;resource-root path=&quot;hazelcast-jca-&lt;version&gt;.jar&quot;/&gt;
&lt;/resources&gt;
&lt;dependencies&gt;
  &lt;module name=&quot;javax.api&quot;/&gt;
  &lt;module name=&quot;javax.resource.api&quot;/&gt;
  &lt;module name=&quot;javax.validation.api&quot;/&gt;
  &lt;module name=&quot;org.jboss.ironjacamar.api&quot;/&gt;
&lt;/dependencies&gt;
&lt;/module&gt;
</code></pre>
</li>
</ul>
<p>At this point, you have a new JBoss module with Hazelcast in it. You can now start JBoss and deploy the <code>hazelcast-jca-rar-</code>&lt;<em>version</em>&gt;<code>.rar</code> file via JBoss CLI or Administration Console.</p>
<p>Once the Hazelcast Resource Adapter is deployed, you can start using it. The easiest way is to let a container inject <code>ConnectionFactory</code> into your beans. </p>
<pre><code class="lang-java">package com.hazelcast.examples.rar;

import com.hazelcast.core.TransactionalMap;
import com.hazelcast.jca.HazelcastConnection;

import javax.annotation.Resource;
import javax.resource.ResourceException;
import javax.resource.cci.ConnectionFactory;
import java.util.logging.Level;
import java.util.logging.Logger;

@javax.ejb.Stateless
public class ExampleBean implements ExampleInterface {
    private final static Logger log = Logger.getLogger(ExampleBean.class.getName());

    @Resource(mappedName = &quot;java:/HazelcastCF&quot;)
    protected ConnectionFactory connectionFactory;

    public void insert(String key, String value) {
        HazelcastConnection hzConn = null;
        try {
            hzConn = getConnection();
            TransactionalMap&lt;String,String&gt; txmap = hzConn.getTransactionalMap(&quot;txmap&quot;);
            txmap.put(key, value);
        } finally {
            closeConnection(hzConn);
        }
    }

    private HazelcastConnection getConnection() {
        try {
            return (HazelcastConnection) connectionFactory.getConnection();
        } catch (ResourceException e) {
            throw new RuntimeException(&quot;Error while getting Hazelcast connection&quot;, e);
        }
    }

    private void closeConnection(HazelcastConnection hzConn) {
        if (hzConn != null) {
            try {
                hzConn.close();
            } catch (ResourceException e) {
                log.log(Level.WARNING, &quot;Error while closing Hazelcast connection.&quot;, e);
            }
        }
    }
}
</code></pre>
<h4 id="known-issues">Known Issues</h4>
<ul>
<li>There is a regression in JBoss EAP 6.1.0 causing failure during Hazelcast Resource Adapter deployment. The issue is fixed in JBoss EAP 6.1.1. See <a href="https://bugzilla.redhat.com/show_bug.cgi?id=976294">this</a> for additional details.  </li>
</ul>
<h1 id="hazelcast-jcache-implementation">Hazelcast JCache Implementation</h1>
<h2 id="jcache-overview">JCache Overview</h2>
<p>Starting with release 3.3.1, Hazelcast offers its JCache (Java Cache) implementation. JCache is the official caching API of 
Java and it provides a common caching specification for the Java platform. It makes it easy for Java developers to cache
data, which in many cases improves the performance.  When it comes to handling huge and non-stop changing data, 
caching is especially important.</p>
<p>Hazelcast provides a built-in distributed implementation of JSR-107 using Hazelcast infrastructure. 
It is 100% TCK (Technology Compatibility Kit) compliant. </p>
<p>This chapter explains the usage of Hazelcast’s JCache implementation. For the full details of JCache, 
please visit its website at the Java Community Process (JCP):</p>
<p><a href="#https://www.jcp.org/en/jsr/detail?id=107">https://www.jcp.org/en/jsr/detail?id=107</a></p>
<h2 id="setup-and-usage">Setup and Usage</h2>
<p>Very similar to Hazelcast&#39;s setup and usage, it is as easy as adding a dependency or dropping a jar file.</p>
<p>Hazelcast has built-in JCache implementation which will be enabled by just adding the <code>cache-api</code> dependency. When Hazelcast sees the <code>javax.cache.Caching</code> class on the classpath, it will just enable JCache.</p>
<ul>
<li>Add the file <code>hazelcast-3.3.1.jar</code> to your classpath or add it as a dependency.</li>
<li>Download the <code>cache-api</code> from maven repo or add it as a dependency as shown below.</li>
</ul>
<pre><code class="lang-xml">&lt;dependency&gt;
  &lt;groupId&gt;javax.cache&lt;/groupId&gt;
  &lt;artifactId&gt;cache-api&lt;/artifactId&gt;
  &lt;version&gt;1.0.0&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>After setting dependencies, you can start using JCache as described by the specification JSR 107. Please note that Hazelcast specific configurations still can be performed as described by this document.</p>
<h2 id="provider-types">Provider Types</h2>
<p>Hazelcast has two types of providers that you can use. You can think of these two types as Hazelcast client and server in terms of their usage purposes.</p>
<h3 id="client-provider">Client Provider</h3>
<p>In order to access the distributed cache cluster through light clients, client provider is the JCache provider to be used. 
Its fully qualified class name is <code>com.hazelcast.client.cache.impl.HazelcastClientCachingProvider</code>.
This uses the Hazelcast client.</p>
<h3 id="server-provider">Server Provider</h3>
<p>If you want to embed JCache server into your application, you can use the server provider. This is actually like embedding a Hazelcast node into your application.</p>
<p>Its fully qualified class name is <code>com.hazelcast.cache.imp.HazelcastServerCachingProvider</code>.</p>
<h2 id="provider-setup">Provider Setup</h2>
<p>After adding the <code>cache-api</code> dependency, there are below options to use Hazelcast. Depending on the Hazelcast jar file you add, Hazelcast can be used as a server or client provider:</p>
<ol>
<li>If <code>hazelcast-&lt;version&gt;.jar</code> is added to the classpath, Hazelcast can only be used as a server provider. </li>
<li>If <code>hazelcast-client-&lt;version&gt;.jar</code> is added to the classpath, default provider is the client one.</li>
<li>If <code>hazelcast-all-&lt;version&gt;.jar</code> is added to the classpath, default provider is again the client one.</li>
</ol>
<p>Adding one of these dependencies enables its default cache provider. </p>
<p>If you add <code>hazelcast-client-&lt;version&gt;.jar</code> or <code>hazelcast-all-&lt;version&gt;.jar</code>, but want to override these defaults, specify the following system property:</p>
<h3 id="hazelcast-specific-system-property">Hazelcast Specific System Property</h3>
<p><code>-Dhazelcast.jcache.provider.type=[client|server]</code></p>
<h2 id="sample-jcache-code">Sample JCache Code</h2>
<p>A sample code is shown below.</p>
<pre><code class="lang-java">CachingProvider cachingProvider = Caching.getCachingProvider();
CacheManager cacheManager = cachingProvider.getCacheManager();

//configure the cache
MutableConfiguration&lt;String, String&gt; config = new MutableConfiguration&lt;String, String&gt;();
config.setStoreByValue(true)
.setTypes(String.class, String.class)
.setExpiryPolicyFactory(AccessedExpiryPolicy.factoryOf(ONE_MINUTE))
.setStatisticsEnabled(false);

//create the cache
cacheManager.createCache(name, config);

//get the cache
Cache&lt;String, Integer&gt; cache = cacheManager.getCache(name, String.class, String.class);
cache.put(&quot;theKey&quot;, &quot;Hello World&quot;);
String value = cache.get(&quot;theKey&quot;);
System.out.println(value);//prints &#39;Hello World&#39;
</code></pre>
<p>For more samples, please see <a href="https://github.com/hazelcast/hazelcast-code-samples/tree/master/jcache/src/main/java/com/hazelcast/examples">Hazelcast JCache Code Samples</a>.</p>
<h2 id="hazelcast-cache-extension-icache">Hazelcast Cache Extension - ICache</h2>
<p>Hazelcast provides extension methods to Cache API through the interface <code>com.hazelcast.cache.ICache</code>. </p>
<p>It has two set of extensions:</p>
<ul>
<li>asynchronous version of all cache operations</li>
<li>cache operations with custom <code>ExpiryPolicy</code> parameter to apply on that specific operation.</li>
</ul>
<h3 id="async-operations">Async operations</h3>
<p>A method ending with <code>Async</code> is the asynchronous version of that method (for example <code>getAsync(K)</code> , <code>replaceAsync(K,V)</code>). These methods return a <code>Future</code> where you can get the result or wait the operation to be completed.</p>
<pre><code class="lang-java">ICache&lt;String , SessionData&gt; icache =  cache.unwrap( ICache.class );
Future&lt;SessionData&gt; future = icache.getAsync(&quot;key-1&quot; ) ;
SessionData sessionData = future.get();
</code></pre>
<p><br></br>
<img src="images/NoteSmall.jpg" alt="image"> <strong><em>NOTE:</em></strong> <em>Asynchronous methods are not compatible with synchronous events.</em>
<br></br></p>
<h3 id="custom-expirypolicy">Custom ExpiryPolicy</h3>
<p>You can provide a custom expiry policy for a cache operation if you want to by-pass the global one already set in your config configuration.</p>
<p>Using the cache configuration, you can set an expiration of one minute as shown in the sample code below.</p>
<pre><code class="lang-java">MutableConfiguration&lt;String, String&gt; config = new MutableConfiguration&lt;String, String&gt;();
config.setExpiryPolicyFactory(AccessedExpiryPolicy.factoryOf(ONE_MINUTE));
</code></pre>
<p>And you use the cache as usual:</p>
<pre><code class="lang-java">cache.put(“session-key-1”, SessionData);
</code></pre>
<p>This will use the global configuration and if we by-pass the policy and want to use a different expiry policy for some operation,</p>
<pre><code class="lang-java">ICache&lt;String , SessionData&gt; icache =  cache.unwrap( ICache.class );
icache.put(&quot;session-key-2&quot;, SessionData,  AccessedExpiryPolicy.factoryOf(TEN_MINUTE) );
</code></pre>
<p>Now, your customized session will expire in ten minutes after being accessed.</p>
<h2 id="running-the-jcache-tck">Running the JCache TCK</h2>
<p>To run the JCache (JSR107) TCK against Hazelcast, perform the below instructions.</p>
<ol>
<li>Checkout the TCK from <a href="https://github.com/jsr107/jsr107tck">https://github.com/jsr107/jsr107tck</a>.</li>
<li>Change the properties as below.</li>
</ol>
<pre><code class="lang-java">&lt;properties&gt;
    &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
    &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;

    &lt;CacheInvocationContextImpl&gt;
        javax.cache.annotation.impl.cdi.CdiCacheKeyInvocationContextImpl
    &lt;/CacheInvocationContextImpl&gt;

    &lt;domain-lib-dir&gt;${project.build.directory}/domainlib&lt;/domain-lib-dir&gt;
    &lt;domain-jar&gt;domain.jar&lt;/domain-jar&gt;


    &lt;!--################################################################################################################--&gt;
    &lt;!--Change the following properties on the command line to override with the coordinates for your implementation--&gt;
    &lt;implementation-groupId&gt;com.hazelcast&lt;/implementation-groupId&gt;
    &lt;!--&lt;implementation-artifactId&gt;hazelcast&lt;/implementation-artifactId&gt;--&gt;
    &lt;implementation-artifactId&gt;hazelcast&lt;/implementation-artifactId&gt;
    &lt;implementation-version&gt;3.3.1&lt;/implementation-version&gt;

    &lt;!-- Change the following properties to your CacheManager and Cache implementation. Used by the unwrap tests. --&gt;
    &lt;CacheManagerImpl&gt;com.hazelcast.cache.impl.HazelcastCacheManager&lt;/CacheManagerImpl&gt;
    &lt;CacheImpl&gt;com.hazelcast.cache.ICache&lt;/CacheImpl&gt;
    &lt;CacheEntryImpl&gt;com.hazelcast.cache.impl.CacheEntry&lt;/CacheEntryImpl&gt;

    &lt;!--Change the following to point to your MBeanServer, so that the TCK can resolve it. --&gt;
    &lt;javax.management.builder.initial&gt;com.hazelcast.cache.impl.TCKMBeanServerBuilder&lt;/javax.management.builder.initial&gt;
    &lt;org.jsr107.tck.management.agentId&gt;TCKMbeanServer&lt;/org.jsr107.tck.management.agentId&gt;
    &lt;jsr107.api.version&gt;1.0.0&lt;/jsr107.api.version&gt;

    &lt;!--################################################################################################################--&gt;
&lt;/properties&gt;
</code></pre>
<p>This will run the tests using an embedded Hazelcast Member.</p>
<h1 id="integrated-clustering">Integrated Clustering</h1>
<h2 id="hibernate-second-level-cache">Hibernate Second Level Cache</h2>
<p>Hazelcast provides distributed second level cache for your Hibernate entities, collections and queries. </p>
<h3 id="sample-code-for-hibernate">Sample Code for Hibernate</h3>
<p>Please see our sample application for <a href="https://github.com/hazelcast/hazelcast-code-samples/tree/master/hazelcast-integration/hibernate-2ndlevel-cache">Hibernate Second Level Cache</a>.</p>
<h3 id="supported-hibernate-versions">Supported Hibernate Versions</h3>
<ul>
<li>hibernate 3.3.x+</li>
<li>hibernate 4.x</li>
</ul>
<h3 id="hibernate-configuration">Hibernate Configuration</h3>
<p>First of all, add <code>hazelcast-hibernate3-&lt;</code><em>hazelcastversion</em><code>&gt;.jar</code> or <code>hazelcast-hibernate4-&lt;</code><em>hazelcastversion</em><code>&gt;.jar</code>  into your classpath depending on your Hibernate version.</p>
<p>Then add below properties into your Hibernate configuration file (e.g. <code>hibernate.cfg.xml</code>).</p>
<p><strong>Enabling the use of second level cache</strong></p>
<pre><code class="lang-xml">&lt;property name=&quot;hibernate.cache.use_second_level_cache&quot;&gt;true&lt;/property&gt;
</code></pre>
<p><strong>Hibernate RegionFactory</strong></p>
<ul>
<li><p><em>HazelcastCacheRegionFactory</em></p>
<p><code>HazelcastCacheRegionFactory</code> uses Hazelcast Distributed Map to cache the data, so all cache operations go through the wire.</p>
<pre><code class="lang-xml">&lt;property name=&quot;hibernate.cache.region.factory_class&quot;&gt;
  com.hazelcast.hibernate.HazelcastCacheRegionFactory
&lt;/property&gt;
</code></pre>
</li>
<li><p><em>HazelcastLocalCacheRegionFactory</em></p>
<p>You can use <code>HazelcastLocalCacheRegionFactory</code> which stores data in local node and sends invalidation messages when an entry is updated/deleted on local.</p>
<pre><code class="lang-xml">&lt;property name=&quot;hibernate.cache.region.factory_class&quot;&gt;
  com.hazelcast.hibernate.HazelcastLocalCacheRegionFactory
&lt;/property&gt;
</code></pre>
</li>
</ul>
<p><strong>Optional Settings</strong></p>
<ul>
<li><p>To enable use of query cache:</p>
<pre><code class="lang-xml">&lt;property name=&quot;hibernate.cache.use_query_cache&quot;&gt;true&lt;/property&gt;
</code></pre>
</li>
<li><p>And to force minimal puts into cache:</p>
<pre><code class="lang-xml">&lt;property name=&quot;hibernate.cache.use_minimal_puts&quot;&gt;true&lt;/property&gt;
</code></pre>
</li>
</ul>
<p><img src="images/NoteSmall.jpg" alt="image"> <strong><em>NOTE:</em></strong> <em>QueryCache is always LOCAL to the node and never distributed across Hazelcast Cluster.</em></p>
<h3 id="hazelcast-configuration">Hazelcast Configuration</h3>
<ul>
<li><p>To configure Hazelcast for Hibernate, it is enough to put configuration file named <code>hazelcast.xml</code> into root of your classpath. If Hazelcast cannot find <code>hazelcast.xml</code>, then it will use the default configuration from <code>hazelcast.jar</code>.</p>
</li>
<li><p>You can define custom named Hazelcast configuration XML file with one of these Hibernate configuration properties.</p>
</li>
</ul>
<pre><code class="lang-xml">&lt;property name=&quot;hibernate.cache.provider_configuration_file_resource_path&quot;&gt;
  hazelcast-custom-config.xml
&lt;/property&gt;
</code></pre>
<pre><code class="lang-xml">&lt;property name=&quot;hibernate.cache.hazelcast.configuration_file_path&quot;&gt;
  hazelcast-custom-config.xml
&lt;/property&gt;
</code></pre>
<p>Hazelcast creates a separate distributed map for each Hibernate cache region. So, these regions can be configured easily via Hazelcast map configuration. You can define <strong>backup</strong>, <strong>eviction</strong>, <strong>TTL</strong> and <strong>Near Cache</strong> properties.</p>
<ul>
<li><p><a href="#map-backups">Backup Configuration</a></p>
</li>
<li><p><a href="#eviction">Eviction And TTL Configuration</a></p>
</li>
<li><p><a href="#near-cache">Near Cache Configuration</a></p>
</li>
</ul>
<h3 id="regionfactory-options">RegionFactory Options</h3>
<h5 id="hazelcastcacheregionfactory">HazelcastCacheRegionFactory</h5>
<p>HazelcastCacheRegionFactory uses standard Hazelcast Distributed Maps. Therefore, all operations like get, put and remove will be performed using the Distributed Map logic. The only downside of using HazelcastCacheRegionFactory may be the lower performance compared to HazelcastLocalCacheRegionFactory since operations are handled as distributed calls.</p>
<p><img src="images/NoteSmall.jpg" alt="image"> <strong><em>NOTE:</em></strong> <em>If you use HazelcastCacheRegionFactory, you can see your maps on <a href="#management-center">Management Center</a>.</em></p>
<p>With HazelcastCacheRegionFactory, all of the following caches are distributed across Hazelcast Cluster.</p>
<ul>
<li>Entity Cache</li>
<li>Collection Cache</li>
<li>Timestamp Cache</li>
</ul>
<h5 id="hazelcastlocalcacheregionfactory">HazelcastLocalCacheRegionFactory</h5>
<p>In this option, each cluster member has a local map and each of them is registered to a Hazelcast Topic (ITopic). Whenever a <code>put</code> or <code>remove</code> operation is performed on a member, an invalidation message is generated on the ITopic and sent to other members. And those other members also remove the related key, value pair on their local maps as soon as they get these invalidation messages. New value is only updated on this member when <code>get</code> operation is run for that key. In the case of <code>get</code> operations, invalidation messages are not generated and reads are performed on the local map.</p>
<p>An illustration of the above logic is shown below.</p>
<p><img src="images/HZLocalCacheRgnFactory.jpg" alt="image"></p>
<p>If your operations are mostly read ones, then this option is a better one regarding performance.</p>
<p><img src="images/NoteSmall.jpg" alt="image"> <strong><em>NOTE:</em></strong> <em>If you use HazelcastLocalCacheRegionFactory, you cannot see your maps on <a href="#management-center">Management Center</a>.</em></p>
<p>With HazelcastLocalCacheRegionFactory, all of the following caches are not distributed and kept locally in the Hazelcast Node.</p>
<ul>
<li>Entity Cache</li>
<li>Collection Cache</li>
<li>Timestamp Cache</li>
</ul>
<p>Entity and Collection are invalidated on update. When they are updated on a node, an invalidation message is sent to all other nodes in order to remove the entity from their local cache. When needed, Each node reads that data from underlying DB. </p>
<p>Timestamp cache is replicated. On every update, a replication message is sent to all other nodes.</p>
<h3 id="hazelcast-modes-for-hibernate-usage">Hazelcast Modes for Hibernate Usage</h3>
<p>Hibernate 2nd Level Cache can use Hazelcast in two modes: P2P and Client/Server</p>
<h5 id="p2p-peer-to-peer-">P2P (Peer-to-Peer)</h5>
<p>With P2P mode, each Hibernate deployment launches its own Hazelcast Instance. You can also configure Hibernate to use an existing instance so instead of creating a new <code>HazelcastInstance</code> for each <code>SessionFactory</code>, an existing instance can be used by setting <code>hibernate.cache.hazelcast.instance_name</code> Hibernate property to <code>HazelcastInstance</code>&#39;s name. For more information see <a href="#named-hazelcastinstance">Named HazelcastInstance</a>.</p>
<p><strong>Disabling shutdown during SessionFactory.close()</strong></p>
<p>Shutting down <code>HazelcastInstance</code> can be disabled during <code>SessionFactory.close()</code>. To achieve this set the Hibernate property <code>hibernate.cache.hazelcast.shutdown_on_session_factory_close</code> to false. <em>(In this case Hazelcast property <code>hazelcast.shutdownhook.enabled</code> should not be set to false.)</em> Default value is <code>true</code>.</p>
<h5 id="client-server">Client/Server</h5>
<ul>
<li>You can set up Hazelcast to connect to the cluster as Native Client. Native client is not a member; it connects to one of the cluster members and delegates all cluster wide operations to it. When the relied cluster member dies, client will transparently switch to another live member.</li>
</ul>
<pre><code class="lang-xml">&lt;property name=&quot;hibernate.cache.hazelcast.use_native_client&quot;&gt;true&lt;/property&gt;
</code></pre>
<p>To setup Native Client properly, you should add Hazelcast <strong>group-name</strong>, <strong>group-password</strong> and <strong>cluster member address</strong> properties. Native Client will connect to defined member and will get addresses of all members in the cluster. If the connected member dies or leaves the cluster, client will automatically switch to another member in the cluster.</p>
<pre><code class="lang-xml">&lt;property name=&quot;hibernate.cache.hazelcast.native_client_address&quot;&gt;10.34.22.15&lt;/property&gt;
&lt;property name=&quot;hibernate.cache.hazelcast.native_client_group&quot;&gt;dev&lt;/property&gt;
&lt;property name=&quot;hibernate.cache.hazelcast.native_client_password&quot;&gt;dev-pass&lt;/property&gt;
</code></pre>
<p><img src="images/NoteSmall.jpg" alt="image"> <strong><em>NOTE</em></strong>: <em>To use Native Client, you should add <code>hazelcast-client-&lt;version&gt;.jar</code> into your classpath. Refer to <a href="#native-client">Native Clients</a> for more information.</em></p>
<h3 id="hibernate-concurrency-strategies">Hibernate Concurrency Strategies</h3>
<p>Hibernate has four cache concurrency strategies: <em>read-only</em>, <em>read-write</em>, <em>nonstrict-read-write</em> and <em>transactional</em>. But, Hibernate does not force cache providers to support all strategies. Hazelcast supports first three (<strong>read-only</strong>, <strong>read-write</strong>, <strong>nonstrict-read-write</strong>) of these strategies. It has no support for <em>transactional</em> strategy yet.</p>
<ul>
<li>If you are using XML based class configurations, you should add a <em>cache</em> element into your configuration with <em>usage</em> attribute with one of <em>read-only</em>, <em>read-write</em>, <em>nonstrict-read-write</em>.</li>
</ul>
<pre><code class="lang-xml">&lt;class name=&quot;eg.Immutable&quot; mutable=&quot;false&quot;&gt;
  &lt;cache usage=&quot;read-only&quot;/&gt;
  .... 
&lt;/class&gt;

&lt;class name=&quot;eg.Cat&quot; .... &gt;
  &lt;cache usage=&quot;read-write&quot;/&gt;
  ....
  &lt;set name=&quot;kittens&quot; ... &gt;
    &lt;cache usage=&quot;read-write&quot;/&gt;
    ....
  &lt;/set&gt;
&lt;/class&gt;
</code></pre>
<ul>
<li>If you are using Hibernate-Annotations, then you can add <em>class-cache</em> or <em>collection-cache</em> element into your Hibernate configuration file with <em>usage</em> attribute with one of <em>read only</em>, <em>read/write</em>, <em>nonstrict read/write</em>.</li>
</ul>
<pre><code class="lang-xml">&lt;class-cache usage=&quot;read-only&quot; class=&quot;eg.Immutable&quot;/&gt;
&lt;class-cache usage=&quot;read-write&quot; class=&quot;eg.Cat&quot;/&gt;
&lt;collection-cache collection=&quot;eg.Cat.kittens&quot; usage=&quot;read-write&quot;/&gt;
</code></pre>
<p>OR</p>
<ul>
<li>Alternatively, you can put Hibernate Annotation&#39;s <em>@Cache</em> annotation on your entities and collections.</li>
</ul>
<pre><code class="lang-java">@Cache(usage = CacheConcurrencyStrategy.READ_WRITE)
public class Cat implements Serializable {
  ...
}
</code></pre>
<h3 id="advanced-settings">Advanced Settings</h3>
<p><strong>Accessing underlying HazelcastInstance</strong></p>
<p>Using <code>com.hazelcast.hibernate.instance.HazelcastAccessor</code> you can access the underlying <code>HazelcastInstance</code> used by Hibernate SessionFactory.</p>
<pre><code class="lang-java">SessionFactory sessionFactory = ...;
HazelcastInstance hazelcastInstance = HazelcastAccessor
    .getHazelcastInstance(sessionFactory);
</code></pre>
<p><strong>Changing/setting lock timeout value of <em>read-write</em> strategy</strong></p>
<p>Lock timeout value can be set using <code>hibernate.cache.hazelcast.lock_timeout_in_seconds</code> Hibernate property. Value should be in seconds and default value is 300 seconds.</p>
<p><br></br></p>
<h2 id="web-session-replication">Web Session Replication</h2>
<p>If you are using Tomcat as your web container, please see our <a href="#tomcat-based-web-session-replication">Tomcat based Web Session Replication</a>.</p>
<h3 id="filter-based-web-session-replication">Filter Based Web Session Replication</h3>
<p><strong>*Sample Code</strong>: Please see our sample application for <a href="https://github.com/hazelcast/hazelcast-code-samples/tree/master/hazelcast-integration/filter-based-session-replication">Filter Based Web Session Replication</a>.*</p>
<p>Assume that you have more than one web servers (A, B, C) with a load balancer in front of them. If server A goes down, your users on that server will be directed to one of the live servers (B or C), but their sessions will be lost.</p>
<p>So we have to have all these sessions backed up somewhere if we do not want to lose the sessions upon server crashes. Hazelcast Web Manager (WM) allows you to cluster user HTTP sessions automatically. The following are required for enabling Hazelcast Session Clustering:</p>
<ul>
<li><p>Target application or web server should support Java 1.6 or higher</p>
</li>
<li><p>Target application or web server should support Servlet 3.0 or higher spec</p>
</li>
<li><p>Session objects that need to be clustered have to be Serializable</p>
</li>
</ul>
<p>Here are the steps to setup Hazelcast Session Clustering:</p>
<ul>
<li><p>Put the <code>hazelcast</code> and <code>hazelcast-wm</code> jars in your <code>WEB-INF/lib</code> directory. Optionally, if you wish to connect to a cluster as a client, add <code>hazelcast-client</code> as well.</p>
</li>
<li><p>Put the following XML into <code>web.xml</code> file. Make sure Hazelcast filter is placed before all the other filters if any; put it at the top for example.</p>
</li>
</ul>
<pre><code class="lang-xml">&lt;filter&gt;
  &lt;filter-name&gt;hazelcast-filter&lt;/filter-name&gt;
  &lt;filter-class&gt;com.hazelcast.web.WebFilter&lt;/filter-class&gt;
  &lt;!--
    Name of the distributed map storing
    your web session objects
  --&gt;
  &lt;init-param&gt;
    &lt;param-name&gt;map-name&lt;/param-name&gt;
    &lt;param-value&gt;my-sessions&lt;/param-value&gt;
  &lt;/init-param&gt;
  &lt;!--
    TTL value of the distributed map storing
    your web session objects.
    Any integer between 0 and Integer.MAX_VALUE.
    Default is 0 which is infinite.
  --&gt;
  &lt;init-param&gt;
    &lt;param-name&gt;session-ttl-seconds&lt;/param-name&gt;
    &lt;param-value&gt;0&lt;/param-value&gt;
  &lt;/init-param&gt;
  &lt;!--
    How is your load-balancer configured?
    sticky-session means all requests of a session
    is routed to the node where the session is first created.
    This is excellent for performance.
    If sticky-session is set to false, when a session is updated
    on a node, entry for this session on all other nodes is invalidated.
    You have to know how your load-balancer is configured before
    setting this parameter. Default is true.
  --&gt;
  &lt;init-param&gt;
    &lt;param-name&gt;sticky-session&lt;/param-name&gt;
    &lt;param-value&gt;true&lt;/param-value&gt;
  &lt;/init-param&gt;
  &lt;!--
    Name of session id cookie
  --&gt;
  &lt;init-param&gt;
    &lt;param-name&gt;cookie-name&lt;/param-name&gt;
    &lt;param-value&gt;hazelcast.sessionId&lt;/param-value&gt;
  &lt;/init-param&gt;
  &lt;!--
    Domain of session id cookie. Default is based on incoming request.
  --&gt;
  &lt;init-param&gt;
    &lt;param-name&gt;cookie-domain&lt;/param-name&gt;
    &lt;param-value&gt;.mywebsite.com&lt;/param-value&gt;
  &lt;/init-param&gt;
  &lt;!--
    Should cookie only be sent using a secure protocol? Default is false.
  --&gt;
  &lt;init-param&gt;
    &lt;param-name&gt;cookie-secure&lt;/param-name&gt;
    &lt;param-value&gt;false&lt;/param-value&gt;
  &lt;/init-param&gt;
  &lt;!--
    Should HttpOnly attribute be set on cookie ? Default is false.
  --&gt;
  &lt;init-param&gt;
    &lt;param-name&gt;cookie-http-only&lt;/param-name&gt;
    &lt;param-value&gt;false&lt;/param-value&gt;
  &lt;/init-param&gt;
  &lt;!--
    Are you debugging? Default is false.
  --&gt;
  &lt;init-param&gt;
    &lt;param-name&gt;debug&lt;/param-name&gt;
    &lt;param-value&gt;true&lt;/param-value&gt;
  &lt;/init-param&gt;
  &lt;!--
    Configuration xml location;
      * as servlet resource OR
      * as classpath resource OR
      * as URL
    Default is one of hazelcast-default.xml
    or hazelcast.xml in classpath.
  --&gt;
  &lt;init-param&gt;
    &lt;param-name&gt;config-location&lt;/param-name&gt;
    &lt;param-value&gt;/WEB-INF/hazelcast.xml&lt;/param-value&gt;
  &lt;/init-param&gt;
  &lt;!--
    Do you want to use an existing HazelcastInstance?
    Default is null.
  --&gt;
  &lt;init-param&gt;
    &lt;param-name&gt;instance-name&lt;/param-name&gt;
    &lt;param-value&gt;default&lt;/param-value&gt;
  &lt;/init-param&gt;
  &lt;!--
    Do you want to connect as a client to an existing cluster?
    Default is false.
  --&gt;
  &lt;init-param&gt;
    &lt;param-name&gt;use-client&lt;/param-name&gt;
    &lt;param-value&gt;false&lt;/param-value&gt;
  &lt;/init-param&gt;
  &lt;!--
    Client configuration location;
      * as servlet resource OR
      * as classpath resource OR
      * as URL
    Default is null.
  --&gt;
  &lt;init-param&gt;
    &lt;param-name&gt;client-config-location&lt;/param-name&gt;
    &lt;param-value&gt;/WEB-INF/hazelcast-client.properties&lt;/param-value&gt;
  &lt;/init-param&gt;
  &lt;!--
    Do you want to shutdown HazelcastInstance during
    web application undeploy process?
    Default is true.
  --&gt;
  &lt;init-param&gt;
    &lt;param-name&gt;shutdown-on-destroy&lt;/param-name&gt;
    &lt;param-value&gt;true&lt;/param-value&gt;
  &lt;/init-param&gt;
  &lt;!--
    Do you want to cache sessions locally in each instance?
    Default is false.
  --&gt;
  &lt;init-param&gt;
    &lt;param-name&gt;deferred-write&lt;/param-name&gt;
    &lt;param-value&gt;false&lt;/param-value&gt;
  &lt;/init-param&gt;
&lt;/filter&gt;
&lt;filter-mapping&gt;
  &lt;filter-name&gt;hazelcast-filter&lt;/filter-name&gt;
  &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
  &lt;dispatcher&gt;FORWARD&lt;/dispatcher&gt;
  &lt;dispatcher&gt;INCLUDE&lt;/dispatcher&gt;
  &lt;dispatcher&gt;REQUEST&lt;/dispatcher&gt;
&lt;/filter-mapping&gt;

&lt;listener&gt;
  &lt;listener-class&gt;com.hazelcast.web.SessionListener&lt;/listener-class&gt;
&lt;/listener&gt;
</code></pre>
<ul>
<li>Package and deploy your <code>war</code> file as you would normally do.</li>
</ul>
<p>It is that easy. All HTTP requests will go through Hazelcast <code>WebFilter</code> and it will put the session objects into Hazelcast distributed map if needed.</p>
<h3 id="spring-security-support">Spring Security Support</h3>
<p><strong>*Sample Code</strong>: Please see our sample application for <a href="https://github.com/hazelcast/hazelcast-code-samples/tree/master/hazelcast-integration/spring-security">Spring Security Support</a>.*</p>
<p>If Spring based security is used for application, you should use <code>com.hazelcast.web.spring.SpringAwareWebFilter</code> instead of <code>com.hazelcast.web.WebFilter</code> in your filter definition.</p>
<pre><code class="lang-xml">...

&lt;filter&gt;
  &lt;filter-name&gt;hazelcast-filter&lt;/filter-name&gt;
  &lt;filter-class&gt;com.hazelcast.web.spring.SpringAwareWebFilter&lt;/filter-class&gt;
    ...
&lt;/filter&gt; 

...
</code></pre>
<p><code>SpringAwareWebFilter</code> notifies Spring by publishing events to Spring context and these events are used by <code>org.springframework.security.core.session.SessionRegistry</code> instance. </p>
<p>As like before, you must also define <code>com.hazelcast.web.SessionListener</code> in your <code>web.xml</code>. However, it is not needed to define <code>org.springframework.security.web.session.HttpSessionEventPublisher</code> in your <code>web.xml</code> as before, since <code>SpringAwareWebFilter</code> already informs Spring about session based events like create or destroy. </p>
<h4 id="client-mode-vs-p2p-mode">Client Mode vs. P2P Mode</h4>
<p>Hazelcast Session Replication works as P2P by default. You need to set <code>use-client</code> parameter to <strong>true</strong> to switch to Client/Server architecture. P2P mode is more flexible and requires no configuration in advance while in Client/Server architecture, clients need to connect to an existing Hazelcast Cluster. In case of connection problems, clients will try to reconnect to the cluster. Default retry count is 3.</p>
<h4 id="caching-locally-with-deferred-write-">Caching Locally with <code>deferred-write</code></h4>
<p>If the value for <code>deferred-write</code> is set as <strong>true</strong>, Hazelcast will cache the session locally and will update the local session on set or deletion of an attribute. Only at the end of request, it will update the distributed map with all the updates. So, it will not be updating the distributed map on each attribute update. It will only call it once at the end of request. It will be also caching it, i.e. whenever there is a read for the attribute, it will read it from the cache. </p>
<p><strong>Important note about <code>deferred-write=false</code> setting</strong>:</p>
<p>If <code>deferred-write</code> is <strong>false</strong>, you will not have local attribute cache as mentioned above. In this case, any update (i.e. <code>setAttribute</code>) on the session will directly be available in the cluster. One exception to this behavior is the changes to the session attribute objects. To update an attribute cluster wide, <code>setAttribute</code> has to be called after making changes to the attribute object.</p>
<p>Following example explains how to update an attribute in the case of <code>deferred-write=false</code> setting: </p>
<pre><code>session.setAttribute(&quot;myKey&quot;, new ArrayList());
List list1 = session.getAttribute(&quot;myKey&quot;);
list1.add(&quot;myValue&quot;); 
session.setAttribute(&quot;myKey&quot;, list1); // changes updated in the cluster
</code></pre><h4 id="sessionid-generation">SessionId Generation</h4>
<p>SessionId generation is done by Hazelcast Web Session Module if session replication is configured in the web application. Default cookie name for the sessionId is <code>hazelcast.sessionId</code> and this is configurable with <code>cookie-name</code> parameter in the <code>web.xml</code> file of the application.
<code>hazelcast.sessionId</code> is just a UUID prefixed with “HZ” character and without “-“ character, e.g. <code>HZ6F2D036789E4404893E99C05D8CA70C7</code>.</p>
<p>When called by the target application, the value of <code>HttpSession.getId()</code> is the same as the value of <code>hazelcast.sessionId</code>.</p>
<h4 id="session-expiry">Session Expiry</h4>
<p>Hazelcast automatically removes sessions from the cluster if session is expired on the Web Container. This removal is done by <code>com.hazelcast.web.SessionListener</code> which is an implementation of <code>javax.servlet.http.HttpSessionListener</code>. </p>
<p>Default session expiration configuration depends on Servlet Container that is being used. You can also define it in your web.xml.</p>
<pre><code class="lang-xml">    &lt;session-config&gt;
        &lt;session-timeout&gt;60&lt;/session-timeout&gt;
    &lt;/session-config&gt;
</code></pre>
<p>If you want to override session expiry configuration with Hazelcast specific configuration, <code>session-ttl-seconds</code> can be used to specify TTL on Hazelcast Session Replication Distributed Map.</p>
<h4 id="sticky-session">sticky-session</h4>
<p>Hazelcast holds whole session attributes in a distributed map and in local HTTP session. Local session is required for fast access to data and distributed map is needed for fail-safety.</p>
<ul>
<li><p>If <code>sticky-session</code> is not used, whenever a session attribute is updated in a node (in both node local session and clustered cache), that attribute should be invalidated in all other nodes&#39; local sessions, because now they have dirty value. So, when a request arrives to one of those other nodes, that attribute value is fetched from clustered cache.</p>
</li>
<li><p>To overcome performance penalty of sending invalidation messages during updates, sticky sessions can be used. If Hazelcast knows sessions are sticky, invalidation will not be sent, because Hazelcast assumes there is no other local session at the moment. When a server is down, requests belonging to a session hold in that server will routed to other one and that server will fetch session data from clustered cache. That means, using sticky sessions, one will not suffer performance penalty of accessing clustered data and can benefit recover from a server failure.</p>
</li>
</ul>
<p><br></br></p>
<h3 id="tomcat-based-web-session-replication">Tomcat Based Web Session Replication</h3>
<p><img src="images/NoteSmall.jpg" alt="image"> <strong><em>NOTE:</em></strong> <em>This feature is supported for Hazelcast Enterprise 3.3 or higher.</em></p>
<p><img src="images/enterprise-onlycopy.jpg" alt=""></p>
<p><strong>*Sample Code</strong>: Please see our sample application for <a href="https://github.com/hazelcast/hazelcast-code-samples/tree/master/hazelcast-integration/tomcat-session-replication">Tomcat Based Web Session Replication</a>.*</p>
<h4 id="overview">Overview</h4>
<p>Session Replication with Hazelcast Enterprise is a container specific module where no application change is required to enable session replication for JEE Web Applications. </p>
<p><strong><em>Features</em></strong></p>
<ol>
<li>Seamless Tomcat 6 &amp; 7 integration</li>
<li>Support for sticky and non-sticky sessions</li>
<li>Tomcat failover</li>
<li>Deferred write for performance boost
<br></br></li>
</ol>
<p><strong><em>Supported Containers</em></strong></p>
<p>Tomcat Web Session Replication Module has been tested against following containers.</p>
<ul>
<li>Tomcat 6.0.x - It can be downloaded <a href="http://tomcat.apache.org/download-60.cgi">here</a>.</li>
<li>Tomcat 7.0.x - It can be downloaded <a href="http://tomcat.apache.org/download-70.cgi">here</a>.</li>
</ul>
<p>Latest tested versions are <strong>6.0.39</strong> and <strong>7.0.40</strong>.
<br></br></p>
<p><strong><em>Requirements</em></strong></p>
<ul>
<li>Tomcat instance must be running with Java 1.6 or higher.</li>
<li>Session objects that need to be clustered have to be Serializable.</li>
</ul>
<h4 id="how-tomcat-session-replication-works">How Tomcat Session Replication works</h4>
<p>Tomcat Session Replication in Hazelcast Enterprise is a Hazelcast Module where each created <code>HttpSession</code> Object is kept in Hazelcast Distributed Map. Additionally, if configured with Sticky Sessions, each Tomcat Instance has its own local copy of Session for performance boost. </p>
<p>As the sessions are in Hazelcast Distributed Map, you can use all the available features offered by Hazelcast Distributed Map implementation such as MapStore and WAN Replication.</p>
<p>Tomcat Web Sessions run in two different modes:</p>
<ul>
<li><strong>P2P</strong> where all Tomcat instances launch its own Hazelcast Instance and join to the Hazelcast Cluster and,</li>
<li><strong>Client/Server</strong> mode where all Tomcat instances put/retrieve the session data to/from an existing Hazelcast Cluster.</li>
</ul>
<h4 id="p2p-peer-to-peer-deployment">P2P (Peer-to-Peer) Deployment</h4>
<p>This launches embedded Hazelcast Node in each server instance.</p>
<p><strong><em>Features</em></strong></p>
<p>This type of deployment is the simplest approach. You can just configure your Tomcat and launch. There is no need for an  external Hazelcast cluster.</p>
<p><strong><em>Sample P2P Configuration to use Hazelcast Session Replication</em></strong></p>
<ul>
<li>Go to <a href="http://www.hazelcast.com/products/hazelcast-enterprise/">hazelcast.com</a> and download the latest Hazelcast Enterprise.</li>
<li>Unzip the Hazelcast Enterprise zip file into the folder <code>$HAZELCAST_ENTERPRISE_ROOT</code>.</li>
<li>Update <code>$HAZELCAST_ENTERPRISE_ROOT/bin/hazelcast.xml</code> with the provided Hazelcast Enterprise License Key. </li>
<li><p>Put <code>$HAZELCAST_ENTERPRISE_ROOT/lib/hazelcast-enterprise-all-</code>&lt;<em>version</em>&gt;<code>.jar</code>,    <code>$HAZELCAST_ENTERPRISE_ROOT/lib/hazelcast-enterprise-</code>&lt;<em>tomcatversion</em>&gt;<code>-</code>&lt;<em>version</em>&gt;<code>.jar</code> and <code>hazelcast.xml</code> to the folder <code>$CATALINA_HOME/lib/</code>.</p>
</li>
<li><p>Put <code>&lt;Listener&gt;</code> tag into the file <code>$CATALINA_HOME$/conf/server.xml</code> as shown below.</p>
</li>
</ul>
<pre><code class="lang-xml">&lt;Server&gt;
    ...
    &lt;Listener className=&quot;com.hazelcast.session.P2PLifecycleListener&quot;/&gt;
    ...
&lt;/Server&gt;
</code></pre>
<ul>
<li>Put <code>&lt;Manager&gt;</code> tag into the file <code>$CATALINA_HOME$/conf/context.xml</code> as shown below.</li>
</ul>
<pre><code class="lang-xml">&lt;Context&gt;
    ...
    &lt;Manager className=&quot;com.hazelcast.session.HazelcastSessionManager&quot;/&gt;
    ...
&lt;/Context&gt;
</code></pre>
<ul>
<li>Start Tomcat instances with a configured load balancer and deploy web application.</li>
</ul>
<p><strong><em>Optional Listener Tag Parameters</em></strong></p>
<ul>
<li>Add <code>configLocation</code> attribute into <code>&lt;Listener&gt;</code> tag. It is optional. If not provided, <code>hazelcast.xml</code> in the classpath is used by default. URL or full filesystem path as a <code>configLocation</code> value is also supported.</li>
</ul>
<p><br></br></p>
<h4 id="client-server-deployment">Client/Server Deployment</h4>
<p>In this deployment type, Tomcat instances work as clients to an existing Hazelcast Cluster.</p>
<p><strong><em>Features</em></strong></p>
<ul>
<li>Existing Hazelcast cluster is used as the Session Replication Cluster.</li>
<li>Offload Session Cache from Tomcat to Hazelcast Cluster.</li>
<li>The architecture is completely independent. Complete reboot of Tomcat instances.
<br></br></li>
</ul>
<p><strong><em>Sample Client/Server Configuration to use Hazelcast Session Replication</em></strong></p>
<ul>
<li>Go to <a href="http://www.hazelcast.com/products/hazelcast-enterprise/">hazelcast.com</a> and download the latest Hazelcast Enterprise.</li>
<li>Unzip the Hazelcast Enterprise zip file into the folder <code>$HAZELCAST_ENTERPRISE_ROOT</code>.</li>
<li><p>Put <code>$HAZELCAST_ENTERPRISE_ROOT/lib/hazelcast-client-</code>&lt;<em>version</em>&gt;<code>.jar</code>,            <code>$HAZELCAST_ENTERPRISE_ROOT/lib/hazelcast-enterprise-</code>&lt;<em>version</em>&gt;<code>.jar</code> and           <code>$HAZELCAST_ENTERPRISE_ROOT/lib/hazelcast-enterprise-</code>&lt;<em>tomcatversion</em>&gt;<code>-</code>&lt;<em>version</em>&gt;<code>.jar</code> to the folder <code>$CATALINA_HOME/lib/</code>.</p>
</li>
<li><p>Put <code>&lt;Listener&gt;</code> tag into the <code>$CATALINA_HOME$/conf/server.xml</code> as shown below.</p>
</li>
</ul>
<pre><code class="lang-xml">&lt;Server&gt;
    ...
    &lt;Listener className=&quot;com.hazelcast.session.ClientServerLifecycleListener&quot;/&gt;
    ...
&lt;/Server&gt;
</code></pre>
<ul>
<li>Update <code>&lt;Manager&gt;</code> tag in the <code>$CATALINA_HOME$/conf/context.xml</code> as shown below.</li>
</ul>
<pre><code class="lang-xml">&lt;Context&gt;
     &lt;Manager className=&quot;com.hazelcast.session.HazelcastSessionManager&quot;
      clientOnly=&quot;true&quot;/&gt;
&lt;/Context&gt;
</code></pre>
<ul>
<li><p>Launch a Hazelcast Instance using <code>$HAZELCAST_ENTERPRISE_ROOT/bin/server.sh</code> or <code>$HAZELCAST_ENTERPRISE_ROOT/bin/server.bat</code>.</p>
</li>
<li><p>Start Tomcat instances with a configured load balancer and deploy web application.</p>
</li>
</ul>
<p><strong><em>Optional Listener Tag Parameters</em></strong></p>
<ul>
<li>Add <code>configLocation</code> attribute into <code>&lt;Listener&gt;</code> tag. It is optional. If not provided, <code>hazelcast-client-default.xml</code> in <code>hazelcast-client-</code>&lt;<em>version</em>&gt;<code>.jar</code> file is used by default. Any client XML file in the classpath, URL or full filesystem path as a <code>configLocation</code> value is also supported.</li>
</ul>
<h4 id="optional-manager-tag-parameters">Optional Manager Tag Parameters</h4>
<p><code>&lt;Manager&gt;</code> tag is used both in P2P and Client/Server mode. Following parameters are used to configure Tomcat Session Replication Module to better serve your needs.</p>
<ul>
<li>Add <code>mapName</code> attribute into <code>&lt;Manager&gt;</code> tag. Its default value is <em>default Hazelcast Distributed Map</em>. Use this attribute if you have specially configured map for special cases like WAN Replication, Eviction, MapStore, etc.</li>
<li>Add <code>sticky</code> attribute into <code>&lt;Manager&gt;</code> tag. Its default value is <em>true</em>.</li>
<li>Add <code>processExpiresFrequency</code> attribute into <code>&lt;Manager&gt;</code> tag. It specifies the frequency of session validity check, in seconds. Its default value is <em>6</em> and minimum value that can be set is <em>1</em>.</li>
<li>Add <code>deferredWrite</code> attribute into <code>&lt;Manager&gt;</code> tag. Its default value is <em>true</em>.</li>
</ul>
<p><br></br></p>
<h4 id="session-caching-and-deferredwrite-parameter">Session Caching and deferredWrite parameter</h4>
<p>Tomcat Web Session Replication Module has its own nature of caching. Attribute changes during the HTTP Request/HTTP Response cycle is cached by default. Distributing those changes to the Hazelcast Cluster is costly. Because of that, Session Replication is only done at the end of each request for updated and deleted attributes. The risk in this approach is to lose data in case a Tomcat crash happens in the middle of HTTP Request operation.</p>
<p>You can change that behavior by setting <code>deferredWrite=false</code> in your <code>&lt;Manager&gt;</code> tag configuration. By disabling it, all updates that are done on session objects are directly distributed into Hazelcast Cluster.</p>
<h4 id="session-expiry">Session Expiry</h4>
<p>Based on Tomcat configuration or <code>sessionTimeout</code> setting in <code>web.xml</code>, sessions are expired over time. This requires a cleanup on Hazelcast Cluster as there is no need to keep expired sessions in the cluster. </p>
<p><code>processExpiresFrequency</code> which is defined in <code>&lt;Manager&gt;</code> is the only setting to control the behavior of session expiry policy in Tomcat Web Session Replication Module. By setting this, you can set the frequency of the session expiration checks in the Tomcat Instance.</p>
<h4 id="enabling-session-replication-in-multi-app-environment">Enabling Session Replication in Multi-App environment</h4>
<p>Tomcat can be configured in two ways to enable Session Replication for deployed applications.</p>
<ul>
<li>Server Context.xml Configuration</li>
<li>Application Context.xml Configuration</li>
</ul>
<p><strong><em>Server Context.xml Configuration</em></strong></p>
<p>By configuring <code>$CATALINA_HOME$/conf/context.xml</code>, you can enable session replication for all applications deployed in the Tomcat Instance. </p>
<p><strong><em>Application Context.xml Configuration</em></strong></p>
<p>By configuring <code>$CATALINA_HOME/conf/[enginename]/[hostname]/[applicationName].xml</code>, you can enable Session Replication per deployed application. </p>
<h4 id="session-affinity">Session Affinity</h4>
<p><strong><em>Sticky Sessions (default)</em></strong></p>
<p>Sticky Sessions are used to improve the performance since the sessions do not move around the cluster.</p>
<p>Request goes always to the same instance where the session was firstly created. By using a sticky session, you eliminate session replication problems mostly, except for the failover cases. In case of failovers, Hazelcast helps you not lose existing sessions.</p>
<p><strong><em>Non-Sticky Sessions</em></strong></p>
<p>Non-Sticky Sessions are not good for performance because you need to move session data all over the cluster every time a new request comes in.</p>
<p>However, load balancing might be super easy with Non-Sticky caches. In case of heavy load, you can distribute the request to the least used Tomcat instance. Hazelcast supports Non-Sticky Sessions as well. </p>
<h4 id="tomcat-failover-and-jvmroute-parameter">Tomcat Failover and jvmRoute Parameter</h4>
<p>Each HTTP Request is redirected to the same Tomcat instance if sticky sessions are enabled. The parameter <code>jvmRoute</code> is added to the end of session ID as a suffix, to make Load Balancer aware of the target Tomcat instance. </p>
<p>When Tomcat Failure happens and Load Balancer cannot redirect the request to the owning instance, it sends request to one of the available Tomcat instances. As <code>jvmRoute</code> parameter of session ID is different than that of target Tomcat instance, Hazelcast Session Replication Module updates the session ID of the session with the new <code>jvmRoute</code> parameter. That actually means that, Session is moved to another Tomcat instance and Load Balancer will redirect all subsequent HTTP Requests to the new Tomcat Instance.</p>
<p><img src="images/NoteSmall.jpg" alt="image"> <strong><em>NOTE:</em></strong> <em>If stickySession is enabled, <code>jvmRoute</code> parameter must be set in <code>$CATALINA_HOME$/conf/server.xml</code> and unique among Tomcat instances in the cluster.</em></p>
<pre><code class="lang-xml"> &lt;Engine name=&quot;Catalina&quot; defaultHost=&quot;localhost&quot; jvmRoute=&quot;tomcat-8080&quot;&gt;
</code></pre>
<p><br></br></p>
<h2 id="spring-integration">Spring Integration</h2>
<h3 id="supported-versions">Supported Versions</h3>
<ul>
<li>Spring 2.5+</li>
</ul>
<h3 id="spring-configuration">Spring Configuration</h3>
<p>Please see our sample application for <a href="https://github.com/hazelcast/hazelcast-code-samples/tree/master/hazelcast-integration/spring-configuration">Spring Configuration</a>.</p>
<h4 id="bean-declaration-by-spring-beans-namespace">Bean Declaration by Spring <em>beans</em> Namespace</h4>
<p><strong><em>Classpath Configuration</em></strong> </p>
<p>This configuration requires following jar file in the classpath:</p>
<ul>
<li><code>hazelcast-</code>&lt;<em>version</em>&gt;<code>.jar</code></li>
</ul>
<p><strong><em>Bean Declaration</em></strong> </p>
<p>You can declare Hazelcast Objects using the default Spring <em>beans</em> namespace. You can find an example usage of Hazelcast Instance declaration as follows:</p>
<pre><code class="lang-xml">&lt;bean id=&quot;instance&quot; class=&quot;com.hazelcast.core.Hazelcast&quot; factory-method=&quot;newHazelcastInstance&quot;&gt;
  &lt;constructor-arg&gt;
    &lt;bean class=&quot;com.hazelcast.config.Config&quot;&gt;
      &lt;property name=&quot;groupConfig&quot;&gt;
        &lt;bean class=&quot;com.hazelcast.config.GroupConfig&quot;&gt;
          &lt;property name=&quot;name&quot; value=&quot;dev&quot;/&gt;
          &lt;property name=&quot;password&quot; value=&quot;pwd&quot;/&gt;
        &lt;/bean&gt;
      &lt;/property&gt;
      &lt;!-- and so on ... --&gt;
    &lt;/bean&gt;
  &lt;/constructor-arg&gt;
&lt;/bean&gt;

&lt;bean id=&quot;map&quot; factory-bean=&quot;instance&quot; factory-method=&quot;getMap&quot;&gt;
  &lt;constructor-arg value=&quot;map&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<h4 id="bean-declaration-by-hazelcast-namespace">Bean Declaration by <em>hazelcast</em> Namespace</h4>
<p><strong><em>Classpath Configuration</em></strong> </p>
<p>Hazelcast-Spring integration requires following jar files in the classpath:</p>
<ul>
<li><code>hazelcast-spring-</code>&lt;<em>version</em>&gt;<code>.jar</code></li>
<li><code>hazelcast-</code>&lt;<em>version</em>&gt;<code>.jar</code></li>
</ul>
<p>or</p>
<ul>
<li><code>hazelcast-all-</code>&lt;<em>version</em>&gt;<code>.jar</code></li>
</ul>
<p><strong><em>Bean Declaration</em></strong> </p>
<p>Hazelcast has its own namespace <strong>hazelcast</strong> for bean definitions. You can easily add namespace declaration <em>xmlns:hz=&quot;<a href="http://www.hazelcast.com/schema/spring">http://www.hazelcast.com/schema/spring</a>&quot;</em> to <code>beans</code> tag in context file so that <em>hz</em> namespace shortcut can be used as a bean declaration.</p>
<p>Here is an example schema definition for Hazelcast 3.3.x:</p>
<pre><code class="lang-xml">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:hz=&quot;http://www.hazelcast.com/schema/spring&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
                http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
                http://www.hazelcast.com/schema/spring
                http://www.hazelcast.com/schema/spring/hazelcast-spring.xsd&quot;&gt;
</code></pre>
<h4 id="supported-configurations-with-hazelcast-namespace">Supported Configurations with <em>hazelcast</em> Namespace</h4>
<ul>
<li><strong>Hazelcast Instance Configuration</strong></li>
</ul>
<pre><code class="lang-xml">&lt;hz:hazelcast id=&quot;instance&quot;&gt;
  &lt;hz:config&gt;
    &lt;hz:group name=&quot;dev&quot; password=&quot;password&quot;/&gt;
    &lt;hz:network port=&quot;5701&quot; port-auto-increment=&quot;false&quot;&gt;
      &lt;hz:join&gt;
        &lt;hz:multicast enabled=&quot;false&quot;
                      multicast-group=&quot;224.2.2.3&quot;
                      multicast-port=&quot;54327&quot;/&gt;
        &lt;hz:tcp-ip enabled=&quot;true&quot;&gt;
          &lt;hz:members&gt;10.10.1.2, 10.10.1.3&lt;/hz:members&gt;
        &lt;/hz:tcp-ip&gt;
      &lt;/hz:join&gt;
    &lt;/hz:network&gt;
    &lt;hz:map name=&quot;map&quot;
            backup-count=&quot;2&quot;
            max-size=&quot;0&quot;
            eviction-percentage=&quot;30&quot;
            read-backup-data=&quot;true&quot;
            eviction-policy=&quot;NONE&quot;
            merge-policy=&quot;com.hazelcast.map.merge.PassThroughMergePolicy&quot;/&gt;
  &lt;/hz:config&gt;
&lt;/hz:hazelcast&gt;
</code></pre>
<ul>
<li><strong>Hazelcast Client Configuration</strong></li>
</ul>
<pre><code class="lang-xml">&lt;hz:client id=&quot;client&quot;&gt;
  &lt;hz:group name=&quot;${cluster.group.name}&quot; password=&quot;${cluster.group.password}&quot; /&gt;
  &lt;hz:network connection-attempt-limit=&quot;3&quot;
              connection-attempt-period=&quot;3000&quot;
              connection-timeout=&quot;1000&quot;
              redo-operation=&quot;true&quot;
              smart-routing=&quot;true&quot;&gt;
    &lt;hz:member&gt;10.10.1.2:5701&lt;/hz:member&gt;
    &lt;hz:member&gt;10.10.1.3:5701&lt;/hz:member&gt;
  &lt;/hz:network&gt;
&lt;/hz:client&gt;
</code></pre>
<ul>
<li><p><strong>Hazelcast Supported Type Configurations and Examples</strong></p>
<ul>
<li><code>map</code></li>
<li><code>multiMap</code></li>
<li><code>replicatedmap</code></li>
<li><code>queue</code></li>
<li><code>topic</code></li>
<li><code>set</code></li>
<li><code>list</code></li>
<li><code>executorService</code></li>
<li><code>idGenerator</code></li>
<li><code>atomicLong</code></li>
<li><code>atomicReference</code></li>
<li><code>semaphore</code></li>
<li><code>countDownLatch</code></li>
<li><code>lock</code></li>
</ul>
</li>
</ul>
<pre><code class="lang-xml">&lt;hz:map id=&quot;map&quot; instance-ref=&quot;client&quot; name=&quot;map&quot; lazy-init=&quot;true&quot; /&gt;
&lt;hz:multiMap id=&quot;multiMap&quot; instance-ref=&quot;instance&quot; name=&quot;multiMap&quot;
    lazy-init=&quot;false&quot; /&gt;
&lt;hz:replicatedmap id=&quot;replicatedmap&quot; instance-ref=&quot;instance&quot; 
    name=&quot;replicatedmap&quot; lazy-init=&quot;false&quot; /&gt;
&lt;hz:queue id=&quot;queue&quot; instance-ref=&quot;client&quot; name=&quot;queue&quot; 
    lazy-init=&quot;true&quot; depends-on=&quot;instance&quot;/&gt;
&lt;hz:topic id=&quot;topic&quot; instance-ref=&quot;instance&quot; name=&quot;topic&quot; 
    depends-on=&quot;instance, client&quot;/&gt;
&lt;hz:set id=&quot;set&quot; instance-ref=&quot;instance&quot; name=&quot;set&quot; /&gt;
&lt;hz:list id=&quot;list&quot; instance-ref=&quot;instance&quot; name=&quot;list&quot;/&gt;
&lt;hz:executorService id=&quot;executorService&quot; instance-ref=&quot;client&quot; 
    name=&quot;executorService&quot;/&gt;
&lt;hz:idGenerator id=&quot;idGenerator&quot; instance-ref=&quot;instance&quot; 
    name=&quot;idGenerator&quot;/&gt;
&lt;hz:atomicLong id=&quot;atomicLong&quot; instance-ref=&quot;instance&quot; name=&quot;atomicLong&quot;/&gt;
&lt;hz:atomicReference id=&quot;atomicReference&quot; instance-ref=&quot;instance&quot; 
    name=&quot;atomicReference&quot;/&gt;
&lt;hz:semaphore id=&quot;semaphore&quot; instance-ref=&quot;instance&quot; name=&quot;semaphore&quot;/&gt;
&lt;hz:countDownLatch id=&quot;countDownLatch&quot; instance-ref=&quot;instance&quot; 
    name=&quot;countDownLatch&quot;/&gt;
&lt;hz:lock id=&quot;lock&quot; instance-ref=&quot;instance&quot; name=&quot;lock&quot;/&gt;
</code></pre>
<ul>
<li><strong>Supported Spring Bean Attributes</strong></li>
</ul>
<p>Hazelcast also supports <code>lazy-init</code>, <code>scope</code> and <code>depends-on</code> bean attributes.</p>
<pre><code class="lang-xml">&lt;hz:hazelcast id=&quot;instance&quot; lazy-init=&quot;true&quot; scope=&quot;singleton&quot;&gt;
  ...
&lt;/hz:hazelcast&gt;
&lt;hz:client id=&quot;client&quot; scope=&quot;prototype&quot; depends-on=&quot;instance&quot;&gt;
  ...
&lt;/hz:client&gt;
</code></pre>
<ul>
<li><strong>MapStore and NearCache Configuration</strong></li>
</ul>
<p>For map-store, you should set either <em>class-name</em> or <em>implementation</em> attribute</p>
<pre><code class="lang-xml">&lt;hz:config&gt;
  &lt;hz:map name=&quot;map1&quot;&gt;
    &lt;hz:near-cache time-to-live-seconds=&quot;0&quot; max-idle-seconds=&quot;60&quot;
        eviction-policy=&quot;LRU&quot; max-size=&quot;5000&quot;  invalidate-on-change=&quot;true&quot;/&gt;

    &lt;hz:map-store enabled=&quot;true&quot; class-name=&quot;com.foo.DummyStore&quot;
        write-delay-seconds=&quot;0&quot;/&gt;
  &lt;/hz:map&gt;

  &lt;hz:map name=&quot;map2&quot;&gt;
    &lt;hz:map-store enabled=&quot;true&quot; implementation=&quot;dummyMapStore&quot;
        write-delay-seconds=&quot;0&quot;/&gt;
  &lt;/hz:map&gt;

  &lt;bean id=&quot;dummyMapStore&quot; class=&quot;com.foo.DummyStore&quot; /&gt;
&lt;/hz:config&gt;
</code></pre>
<h3 id="spring-managed-context-with-springaware">Spring Managed Context with @SpringAware</h3>
<p>Hazelcast Distributed Objects could be marked with @SpringAware if the object wants</p>
<ul>
<li>to apply bean properties,</li>
<li>to apply factory callbacks such as <code>ApplicationContextAware</code>, <code>BeanNameAware</code>,</li>
<li>to apply bean post-processing annotations such as <code>InitializingBean</code>, <code>@PostConstruct</code>.</li>
</ul>
<p>Hazelcast Distributed <code>ExecutorService</code> or more generally any Hazelcast managed object can benefit from these features. To enable SpringAware objects, you have to first configure HazelcastInstance as explained in <a href="#spring-configuration">Spring Configuration</a> section.</p>
<h4 id="springaware-examples">SpringAware Examples</h4>
<ul>
<li>Configure a Hazelcast Instance (3.3.x) via Spring Configuration and define <em>someBean</em> as Spring Bean.</li>
</ul>
<pre><code class="lang-xml">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xmlns:hz=&quot;http://www.hazelcast.com/schema/spring&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
                http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
                http://www.springframework.org/schema/context
                http://www.springframework.org/schema/context/spring-context-3.0.xsd
                http://www.hazelcast.com/schema/spring
                http://www.hazelcast.com/schema/spring/hazelcast-spring.xsd&quot;&gt;

  &lt;context:annotation-config /&gt;

  &lt;hz:hazelcast id=&quot;instance&quot;&gt;
    &lt;hz:config&gt;
      &lt;hz:group name=&quot;dev&quot; password=&quot;password&quot;/&gt;
      &lt;hz:network port=&quot;5701&quot; port-auto-increment=&quot;false&quot;&gt;
        &lt;hz:join&gt;
          &lt;hz:multicast enabled=&quot;false&quot; /&gt;
          &lt;hz:tcp-ip enabled=&quot;true&quot;&gt;
            &lt;hz:members&gt;10.10.1.2, 10.10.1.3&lt;/hz:members&gt;
          &lt;/hz:tcp-ip&gt;
        &lt;/hz:join&gt;
      &lt;/hz:network&gt;
      ...
    &lt;/hz:config&gt;
  &lt;/hz:hazelcast&gt;

  &lt;bean id=&quot;someBean&quot; class=&quot;com.hazelcast.examples.spring.SomeBean&quot;
      scope=&quot;singleton&quot; /&gt;
  ...
&lt;/beans&gt;
</code></pre>
<p><strong>Distributed Map Example:</strong></p>
<ul>
<li>Create a class called SomeValue which contains Spring Bean definitions like ApplicationContext, SomeBean.</li>
</ul>
<pre><code class="lang-java">@SpringAware
@Component(&quot;someValue&quot;)
@Scope(&quot;prototype&quot;)
public class SomeValue implements Serializable, ApplicationContextAware {

  private transient ApplicationContext context;

  private transient SomeBean someBean;

  private transient boolean init = false;

  public void setApplicationContext( ApplicationContext applicationContext )
    throws BeansException {
    context = applicationContext;
  }

  @Autowired
  public void setSomeBean( SomeBean someBean)  {
    this.someBean = someBean;
  }

  @PostConstruct
  public void init() {
    someBean.doSomethingUseful();
    init = true;
  }
  ...
}
</code></pre>
<ul>
<li>Get SomeValue Object from Context and put it into Hazelcast Distributed Map on Node-1.</li>
</ul>
<pre><code class="lang-java">HazelcastInstance hazelcastInstance = 
    (HazelcastInstance) context.getBean( &quot;hazelcast&quot; );
SomeValue value = (SomeValue) context.getBean( &quot;someValue&quot; )
IMap&lt;String, SomeValue&gt; map = hazelcastInstance.getMap( &quot;values&quot; );
map.put( &quot;key&quot;, value );
</code></pre>
<ul>
<li>Read SomeValue Object from Hazelcast Distributed Map and assert that init method is called as it is annotated with <code>@PostConstruct</code>.</li>
</ul>
<pre><code class="lang-java">HazelcastInstance hazelcastInstance = 
    (HazelcastInstance) context.getBean( &quot;hazelcast&quot; );
IMap&lt;String, SomeValue&gt; map = hazelcastInstance.getMap( &quot;values&quot; );
SomeValue value = map.get( &quot;key&quot; );
Assert.assertTrue( value.init );
</code></pre>
<p><strong>ExecutorService Example:</strong></p>
<ul>
<li>Create a Callable Class called SomeTask which contains Spring Bean definitions like ApplicationContext, SomeBean.</li>
</ul>
<pre><code class="lang-java">@SpringAware
public class SomeTask
    implements Callable&lt;Long&gt;, ApplicationContextAware, Serializable {

  private transient ApplicationContext context;

  private transient SomeBean someBean;

  public Long call() throws Exception {
    return someBean.value;
  }

  public void setApplicationContext( ApplicationContext applicationContext )
      throws BeansException {
    context = applicationContext;
  }

  @Autowired
  public void setSomeBean( SomeBean someBean ) {
    this.someBean = someBean;
  }
}
</code></pre>
<ul>
<li>Submit SomeTask to two Hazelcast Members and assert that <code>someBean</code> is autowired.</li>
</ul>
<pre><code class="lang-java">HazelcastInstance hazelcastInstance =
    (HazelcastInstance) context.getBean( &quot;hazelcast&quot; );
SomeBean bean = (SomeBean) context.getBean( &quot;someBean&quot; );

Future&lt;Long&gt; f = hazelcastInstance.getExecutorService().submit(new SomeTask());
Assert.assertEquals(bean.value, f.get().longValue());

// choose a member
Member member = hazelcastInstance.getCluster().getMembers().iterator().next();

Future&lt;Long&gt; f2 = (Future&lt;Long&gt;) hazelcast.getExecutorService()
    .submitToMember(new SomeTask(), member);
Assert.assertEquals(bean.value, f2.get().longValue());
</code></pre>
<p><img src="images/NoteSmall.jpg" alt="image"> <strong><em>NOTE:</em></strong> <em>Spring managed properties/fields are marked as <code>transient</code>.</em></p>
<h3 id="spring-cache">Spring Cache</h3>
<p>Please see our sample application for <a href="https://github.com/hazelcast/hazelcast-code-samples/tree/master/hazelcast-integration/spring-cache-manager">Spring Cache</a>.</p>
<p>As of version 3.1, Spring Framework provides support for adding caching into an existing Spring application. </p>
<h4 id="declarative-spring-cache-configuration">Declarative Spring Cache Configuration</h4>
<pre><code class="lang-xml">&lt;cache:annotation-driven cache-manager=&quot;cacheManager&quot; /&gt;

&lt;hz:hazelcast id=&quot;hazelcast&quot;&gt;
  ...
&lt;/hz:hazelcast&gt;

&lt;bean id=&quot;cacheManager&quot; class=&quot;com.hazelcast.spring.cache.HazelcastCacheManager&quot;&gt;
  &lt;constructor-arg ref=&quot;instance&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<h4 id="annotation-based-spring-cache-configuration">Annotation Based Spring Cache Configuration</h4>
<p>Annotation Based Configuration does not require any XML definition.</p>
<ul>
<li>Implement a <code>CachingConfiguration</code> class with related Annotations.</li>
</ul>
<pre><code class="lang-java">@Configuration
@EnableCaching
public class CachingConfiguration implements CachingConfigurer{
    @Bean
    public CacheManager cacheManager() {
        ClientConfig config = new ClientConfig();
        HazelcastInstance client = HazelcastClient.newHazelcastClient(config);
        return new HazelcastCacheManager(client);
    }
    @Bean
    public KeyGenerator keyGenerator() {
        return null;
    }
</code></pre>
<ul>
<li>Launch Application Context and register <code>CachingConfiguration</code>.</li>
</ul>
<pre><code class="lang-java">AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext();
context.register(CachingConfiguration.class);
context.refresh();
</code></pre>
<p>For more information about Spring Cache, please see <a href="http://static.springsource.org/spring/docs/3.1.x/spring-framework-reference/html/cache.html">Spring Cache Abstraction</a>.</p>
<h3 id="hibernate-2nd-level-cache-config">Hibernate 2nd Level Cache Config</h3>
<p>Please see our sample application for <a href="https://github.com/hazelcast/hazelcast-code-samples/tree/master/hazelcast-integration/spring-hibernate-2ndlevel-cache">Hibernate 2nd Level Cache Config</a>.</p>
<p>If you are using Hibernate with Hazelcast as 2nd level cache provider, you can easily create <code>RegionFactory</code> instances within Spring configuration (by Spring version 3.1). That way, it is possible to use same <code>HazelcastInstance</code> as Hibernate L2 cache instance.</p>
<pre><code class="lang-xml">&lt;hz:hibernate-region-factory id=&quot;regionFactory&quot; instance-ref=&quot;instance&quot;
    mode=&quot;LOCAL&quot; /&gt;
...
&lt;bean id=&quot;sessionFactory&quot; 
      class=&quot;org.springframework.orm.hibernate3.LocalSessionFactoryBean&quot; 
      scope=&quot;singleton&quot;&gt;
  &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;
  &lt;property name=&quot;cacheRegionFactory&quot; ref=&quot;regionFactory&quot; /&gt;
  ...
&lt;/bean&gt;
</code></pre>
<p><strong>Hibernate RegionFactory Modes</strong></p>
<ul>
<li>LOCAL</li>
<li>DISTRIBUTED </li>
</ul>
<p>Please refer to Hibernate <a href="#regionfactory-options">RegionFactory Options</a> section for more information.</p>
<h3 id="best-practices">Best Practices</h3>
<h4 id="avoid-out-of-memory-error-with-large-distributed-data-structures">Avoid Out of Memory Error with Large Distributed Data Structures</h4>
<p>Spring tries to create a new <code>Map</code>/<code>Collection</code> instance and fill the new instance by iterating and converting values of the original <code>Map</code>/<code>Collection</code> (<code>IMap</code>, <code>IQueue</code>, etc.) to required types when generic type parameters of the original <code>Map</code>/<code>Collection</code> and the target property/attribute do not match.</p>
<p>Since Hazelcast <code>Map</code>s/<code>Collection</code>s are designed to hold very large data which a single machine cannot carry, iterating through whole values can cause out of memory errors.</p>
<p>To avoid this issue, either target property/attribute can be declared as un-typed <code>Map</code>/<code>Collection</code> as shown below.</p>
<pre><code class="lang-java">public class SomeBean {
  @Autowired
  IMap map; // instead of IMap&lt;K, V&gt; map

  @Autowired
  IQueue queue; // instead of IQueue&lt;E&gt; queue

  ...
}
</code></pre>
<p>Or, parameters of injection methods (constructor, setter) can be un-typed as shown below.</p>
<pre><code class="lang-java">public class SomeBean {

  IMap&lt;K, V&gt; map;

  IQueue&lt;E&gt; queue;

  // Instead of IMap&lt;K, V&gt; map
  public SomeBean(IMap map) {
    this.map = map;
  }

  ...

  // Instead of IQueue&lt;E&gt; queue
  public void setQueue(IQueue queue) {
    this.queue = queue;
  }
  ...
}
</code></pre>
<p><br> </br></p>
<p><strong><em>RELATED INFORMATION</em></strong></p>
<p><em>For more information please see <a href="https://jira.springsource.org/browse/SPR-3407">Spring issue-3407</a>.</em></p>
<h1 id="storage">Storage</h1>
<h2 id="off-heap">Off-Heap</h2>
<p><img src="images/enterprise-onlycopy.jpg" alt=""></p>
<p>By default, Hazelcast stores your distributed data (map entries, queue items) into Java heap which is subject to garbage collection (GC). As your heap gets bigger, garbage collection might cause your application to pause tens of seconds, badly effecting your application performance and response times. Elastic Memory is Hazelcast with off-heap (direct) memory storage to avoid GC pauses. Even if you have terabytes of cache in-memory with lots of updates, GC will have almost no effect; resulting in more predictable latency and throughput.</p>
<p>Here are the steps to enable Elastic Memory:</p>
<ul>
<li><p>Set the maximum direct memory JVM can allocate, e.g. <code>java -XX:MaxDirectMemorySize=60G</code></p>
</li>
<li><p>Enable Elastic Memory by setting <code>hazelcast.elastic.memory.enabled</code> Hazelcast configuration property to true.</p>
</li>
<li><p>Set the total direct memory size for HazelcastInstance by setting <code>hazelcast.elastic.memory.total.size</code> Hazelcast configuration property. Size can be in MB or GB and abbreviation can be used, such as 60G and 500M.</p>
</li>
<li><p>Set the chunk size by setting <code>hazelcast.elastic.memory.chunk.size</code> Hazelcast configuration property. Hazelcast will partition the entire off-heap memory into chunks. Default chunk size is 1K.</p>
</li>
<li><p>You can enable <code>sun.misc.Unsafe</code> based off-heap storage implementation instead of <code>java.nio.DirectByteBuffer</code> based one, by setting <code>hazelcast.elastic.memory.unsafe.enabled property</code> to <strong>true</strong>. Default value is <strong>false</strong>.</p>
</li>
<li><p>Configure maps that will use Elastic Memory by setting <code>InMemoryFormat</code> to <strong>OFFHEAP</strong>. Default value is <strong>BINARY</strong>.</p>
</li>
</ul>
<p>Below is the declarative configuration.</p>
<pre><code class="lang-xml">&lt;hazelcast&gt;
  ...
  &lt;map name=&quot;default&quot;&gt;
    ...
    &lt;in-memory-format&gt;OFFHEAP&lt;/in-memory-format&gt;
  &lt;/map&gt;
&lt;/hazelcast&gt;
</code></pre>
<p>And, the programmatic configuration:</p>
<pre><code class="lang-java">MapConfig mapConfig = new MapConfig();
mapConfig.setInMemoryFormat( InMemoryFormat.OFFHEAP );
</code></pre>
<p><br> </br></p>
<h1 id="clients">Clients</h1>
<p>There are currently three ways to connect to a running Hazelcast cluster:</p>
<ul>
<li><p><a href="#native-clients">Native Clients</a></p>
</li>
<li><p><a href="#memcache-client">Memcache Clients</a></p>
</li>
<li><p><a href="#rest-client">REST Client</a></p>
</li>
</ul>
<p>Native Clients enable you to perform almost all Hazelcast operations without being a member of the cluster. It connects to one of the cluster members and delegates all cluster wide operations to it (<em>dummy client</em>) or connects to all of them and delegate operations smartly (<em>smart client</em>). When the relied cluster member dies, client will transparently switch to another live member.</p>
<p>There can be hundreds, even thousands of clients connected to the cluster. But, by default there are <strong><em>core count</em></strong> * <strong><em>10</em></strong> threads on the server side that will handle all the requests (e.g. if the server has 4 cores, it will be 40).</p>
<p>Imagine a trading application where all the trading data stored and managed in a Hazelcast cluster with tens of nodes. Swing/Web applications at traders&#39; desktops can use Native  Clients to access and modify the data in the Hazelcast cluster.</p>
<p>Currently, Hazelcast has Native Java, C++ and .NET Clients available.</p>
<h2 id="java-client">Java Client</h2>
<h3 id="java-client-overview">Java Client Overview</h3>
<p>Java client is the most full featured client. It is offered both with Hazelcast and Hazelcast Enterprise. Main idea behind the Java client is to provide the same Hazelcast functionality by proxying each operation through a Hazelcast node. 
It can be used to access and change distributed data or listen distributed events of an already established Hazelcast cluster from another Java application. </p>
<h3 id="java-client-dependencies">Java Client Dependencies</h3>
<p>There are two dependencies that you should include in your classpath to start using Hazelcast client: <code>hazelcast.jar</code> and <code>hazelcast-client.jar</code>.</p>
<p>After adding these dependencies, you can start using Hazelcast client as if you are using Hazelcast API. The differences will be extracted throughout the below sections.</p>
<p>If you prefer to use maven, simply add below lines to your <code>pom.xml</code>.</p>
<pre><code class="lang-xml">&lt;dependency&gt;
    &lt;groupId&gt;com.hazelcast&lt;/groupId&gt;
    &lt;artifactId&gt;hazelcast-client&lt;/artifactId&gt;
    &lt;version&gt;$LATEST_VERSION$&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.hazelcast&lt;/groupId&gt;
    &lt;artifactId&gt;hazelcast&lt;/artifactId&gt;
    &lt;version&gt;$LATEST_VERSION$&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<h3 id="getting-started-with-client-api">Getting Started with Client API</h3>
<p>First step is configuration. Java client can be configured declaratively or programmatically. We will use the programmatic approach throughout this tutorial. Please refer to <a href="#java-client-declarative-configuration">Java Client Declarative Configuration</a> for details.</p>
<pre><code class="lang-java">ClientConfig clientConfig = new ClientConfig();
clientConfig.getGroupConfig().setName(&quot;dev&quot;).setPassword(&quot;dev-pass&quot;);
clientConfig.getNetworkConfig().addAddress(&quot;10.90.0.1&quot;, &quot;10.90.0.2:5702&quot;);
</code></pre>
<p>Second step is the initialization of HazelcastInstance to be connected to the cluster.</p>
<pre><code class="lang-java">HazelcastInstance client = HazelcastClient.newHazelcastClient(clientConfig);
</code></pre>
<p><em>This client interface is your gateway to access all Hazelcast distributed objects.</em></p>
<p>Let&#39;s create a map and populate with some data;</p>
<pre><code class="lang-java">
IMap&lt;String, Customer&gt; mapCustomers = client.getMap(&quot;customers&quot;);//creates the map proxy

mapCustomers.put(&quot;1&quot;, new Customer(&quot;Joe&quot;, &quot;Smith&quot;)); 
mapCustomers.put(&quot;2&quot;, new Customer(&quot;Ali&quot;, &quot;Selam&quot;)); 
mapCustomers.put(&quot;3&quot;, new Customer(&quot;Avi&quot;, &quot;Noyan&quot;));
</code></pre>
<p>As a final step, if you are done with your client, you can just shut it down as shown below. This will release all used resources and close connections to cluster.</p>
<pre><code class="lang-java">
client.shutdown();
</code></pre>
<h3 id="java-client-operation-modes">Java Client Operation modes</h3>
<p>Client has two operation modes because of the distributed nature of the data and cluster. </p>
<h4 id="smart-client">Smart Client</h4>
<p>In this mode, clients connect to each cluster node. As each data partition uses the well known consistent hashing algorithm, each client can send operation to the relevant cluster node which will increase the overall throughput and efficiency. This mode is the default.</p>
<h4 id="dummy-client">Dummy Client</h4>
<p>For some cases, the clients can be required to connect to a single node instead of each node in the cluster. Firewalls, security or some custom networking issues can be the reason for that. </p>
<p>In this mode, client will only connect to one of the configured addresses. This single node will behave as a gateway to other nodes. For any operation requested from the client, it will redirect the request to the relevant node and return the response back to the client returned from this node.</p>
<h3 id="fail-case-handling">Fail Case Handling</h3>
<p>There are two main failure cases to be aware of and configured to achieve a proper behavior.</p>
<h4 id="client-connection-failure">Client Connection Failure</h4>
<p>While client is trying to connect initially to one of the members in the <code>ClientNetworkConfig.addressList</code>, all members might be not available. Instead of giving up, throwing an exception and stopping the client, it will attempt to retry as much as <code>connectionAttemptLimit</code> times. Please see <a href="#connection-attempt-limit">Connection Attempt Limit</a>.</p>
<p>Client executes each operation through the already established connection to cluster. If this connection(s) disconnects or drops, client will try to reconnect as configured. </p>
<h4 id="retry-able-operation-failure">Retry-able Operation Failure</h4>
<p>While sending the requests to related nodes, it is possible that operation fails due to various reasons. For any read only operations, you can have your client retrying to send the operation by enabling <code>redoOperation</code>. Please see <a href="#redo-operation">Redo Operation</a>.</p>
<p>And, the number of retries is given with the property  <code>hazelcast.client.request.retry.count</code> in <code>ClientProperties</code>. It will resend the request as many as RETRY-COUNT then it will throw an exception. Please see <a href="#client-properties">Client Properties</a>.</p>
<h3 id="supported-distributed-data-structures">Supported Distributed Data Structures</h3>
<p>Most of the Distributed Data Structures are supported by the client. Please check for the exceptions for the clients in other languages.</p>
<p>As a general rule, these data structures are configured on the server side and simply accessed through a proxy on the client side.</p>
<h4 id="map">Map</h4>
<p>You can use any <a href="#map">Distributed Map</a> object with client as shown below.</p>
<pre><code class="lang-java">Imap&lt;Integer, String&gt; map = client.getMap(“myMap”);

map.put(1, “Ali”);
String value= map.get(1);
map.remove(1);
</code></pre>
<p>As Locality is ambiguous for the client, <code>addEntryListener</code> and <code>localKeySet</code> are not supported. Please see <a href="#map">Distributed Map</a> for more information.</p>
<h4 id="multimap">MultiMap</h4>
<p>A sample usage is shown below.</p>
<pre><code class="lang-java">MultiMap&lt;Integer, String&gt; multiMap = client.getMultiMap(&quot;myMultiMap&quot;);

multiMap.put(1,”ali”);
multiMap.put(1,”veli”);

Collection&lt;String&gt; values = multiMap.get(1);
</code></pre>
<p>As Locality is ambiguous for the client, <code>addEntryListener</code>, <code>localKeySet</code> and  <code>getLocalMultiMapStats</code> are not supported. Please see <a href="#multimap">Distributed MultiMap</a> for more information.</p>
<h4 id="queue">Queue</h4>
<p>A sample usage is shown below.</p>
<pre><code class="lang-java">IQueue&lt;String&gt; myQueue = client.getQueue(“theQueue”);
myQueue.offer(“ali”)
</code></pre>
<p><code>getLocalQueueStats</code> is not supported as locality is ambiguous for the client. Please see <a href="#queue">Distributed Queue</a> for more information.</p>
<h4 id="topic">Topic</h4>
<p><code>getLocalTopicStats</code> is not supported as locality is ambiguous for the client.</p>
<h4 id="other-supported-distributed-structures">Other Supported Distributed Structures</h4>
<p>Below distributed data structures are also supported by the client. Since their logic is the same in both the node side and client side, you can refer to their sections as listed below.</p>
<ul>
<li><a href="#replicated-map-beta">Replicated Map</a></li>
<li><a href="#mapreduce">MapReduce</a></li>
<li><a href="#list">List</a></li>
<li><a href="#set">Set</a></li>
<li><a href="#iatomiclong">IAtomicLong</a></li>
<li><a href="#iatomicreference">IAtomicReference</a></li>
<li><a href="#icountdownlatch">ICountDownLatch</a></li>
<li><a href="#isemaphore">ISemaphore</a></li>
<li><a href="#idgenerator">IdGenerator</a></li>
<li><a href="#lock">Lock</a></li>
</ul>
<h3 id="client-services">Client Services</h3>
<p>Below services are provided for some common functionalities on the client side.</p>
<h4 id="distributed-executor-service">Distributed Executor Service</h4>
<p>This service is for distributed computing. It can be used to execute tasks on the cluster on designated partition or even on all partitions. It can also be used to process entries.  Please see <a href="#executor-service">Distributed Executor Service</a> for more information.</p>
<pre><code class="lang-java">IExecutorService executorService = client.getExecutorService(&quot;default&quot;);
</code></pre>
<p>After getting an instance of <code>IExecutorService</code>, it can be used as the interface with the one provided on the server side. Please see <a href="#distributed-computing">Distributed Computing</a> chapter for detailed usage.</p>
<p><img src="images/NoteSmall.jpg" alt="image"> <strong><em>NOTE:</em></strong> <em>This service is only supported by the Java client.</em></p>
<h4 id="client-service">Client Service</h4>
<p>If you need to track clients and want to listen their connection events, see the below code.</p>
<pre><code class="lang-java">final ClientService clientService = client.getClientService();
final Collection&lt;Client&gt; connectedClients = clientService.getConnectedClients();

clientService.addClientListener(new ClientListener() {
    @Override
    public void clientConnected(Client client) {
    //Handle client connected event
    }

    @Override
    public void clientDisconnected(Client client) {
      //Handle client disconnected event
    }
});
</code></pre>
<h4 id="partition-service">Partition Service</h4>
<p>Partition service is used to find the partition of a key. It will return all partitions. See the below code.</p>
<pre><code class="lang-java">PartitionService partitionService = client.getPartitionService();

//partition of a key
Partition partition = partitionService.getPartition(key);

//all partitions
Set&lt;Partition&gt; partitions = partitionService.getPartitions();
</code></pre>
<h4 id="lifecycle-service">Lifecycle Service</h4>
<p>Lifecycle handling is to;</p>
<ul>
<li>check the client is running,</li>
<li>shutdown the client gracefully,</li>
<li>terminate the client ungracefully (forced shutdown), and</li>
<li>add/remove lifecycle listeners.</li>
</ul>
<pre><code class="lang-java">LifecycleService lifecycleService = client.getLifecycleService();

if(lifecycleService.isRunning()){
    //it is running
}

//shutdown client gracefully        
lifecycleService.shutdown();
</code></pre>
<h3 id="client-listeners">Client Listeners</h3>
<p>Listeners can be configured to listen to various event types on the client side. Global events not relating to any distributed object can be configured through <a href="#listenerconfig">ListenerConfig</a>. Whereas, distributed object listeners like map entry listeners or list item listeners should be configured through their proxies. You can refer to the related sections under each distributed data structure in this reference manual.</p>
<h3 id="client-transactions">Client Transactions</h3>
<p>Transactional distributed objects are supported on the client side. Please see <a href="#transactions">Transactions</a> chapter on how to use them.</p>
<h3 id="network-configuration-options">Network Configuration Options</h3>
<pre><code class="lang-java">ClientConfig clientConfig = new ClientConfig();
ClientNetworkConfig networkConfig = clientConfig.getNetworkConfig();
</code></pre>
<h4 id="address-list">Address List</h4>
<p>Address List is the initial list of cluster addresses to which the client will connect. Client uses this list to find an alive node. Although it may be enough to give only one address of a node in the cluster (since all nodes communicate with each other), it is recommended to give all nodes’ addresses.</p>
<p>If the port part is omitted then 5701, 5702, and 5703 will be tried in a random order.</p>
<pre><code class="lang-java">clientConfig.getNetworkConfig().addAddress(&quot;10.1.1.21&quot;, &quot;10.1.1.22:5703&quot;);
</code></pre>
<p>You can provide multiple addresses with ports provided or not as seen above. The provided list is shuffled to try them in a random order.</p>
<p>Default value is <em>localhost</em>.</p>
<h4 id="smart-routing">Smart Routing</h4>
<p>This parameter defines whether the client is smart or a dummy one.</p>
<pre><code class="lang-java">//sets client to dummy client mode
clientConfig.getNetworkConfig().setSmartRouting(false);
</code></pre>
<p>Default is <em>smart client</em> mode.</p>
<h4 id="redo-operation">Redo Operation</h4>
<p>Enables/disables redo-able operations as described in <a href="#retry-able-operation-failure">Retry-able Operation Failure</a>.</p>
<pre><code class="lang-java">//enables redo 
clientConfig.getNetworkConfig().setRedoOperation(true);
</code></pre>
<p>Default is <em>disabled</em>.</p>
<h4 id="connection-timeout">Connection Timeout</h4>
<p>Timeout value in milliseconds for nodes to accept client connection requests. </p>
<pre><code class="lang-java">//enables redo 
clientConfig.getNetworkConfig().setConnectionTimeout(1000);
</code></pre>
<p>Default value is <em>5000</em> milliseconds.</p>
<h4 id="connection-attempt-limit">Connection Attempt Limit</h4>
<p>While client is trying to connect initially to one of the members in the <code>ClientNetworkConfig.addressList</code>, all might be not available. Instead of giving up, throwing exception and stopping the client, it will attempt to retry as much as <code>ClientNetworkConfig.connectionAttemptLimit</code> times.</p>
<pre><code class="lang-java">//enables redo 
clientConfig.getNetworkConfig().setConnectionAttemptLimit(5);
</code></pre>
<p>Default value is <em>2</em>.</p>
<h4 id="connection-attempt-period">Connection Attempt Period</h4>
<p>The duration in milliseconds between connection attempts defined by <code>ClientNetworkConfig.connectionAttemptLimit</code>.</p>
<pre><code class="lang-java">//enables redo 
clientConfig.getNetworkConfig().setConnectionAttemptPeriod(5000);
</code></pre>
<p>Default value is <em>3000</em>.</p>
<h4 id="socket-interceptor">Socket Interceptor</h4>
<p><img src="images/enterprise-onlycopy.jpg" alt=""></p>
<p>Client configuration to set a socket intercepter. Any class implementing <code>com.hazelcast.nio.SocketInterceptor</code> is a socket Interceptor.</p>
<pre><code class="lang-java">public interface SocketInterceptor {

    void init(Properties properties);

    void onConnect(Socket connectedSocket) throws IOException;
}
</code></pre>
<p>Socket interceptor has two steps. First, it will be initialized by the configured properties. Second, it will be informed just after socket is connected using <code>onConnect</code>.</p>
<pre><code class="lang-java">SocketInterceptorConfig socketInterceptorConfig = clientConfig
               .getNetworkConfig().getSocketInterceptorConfig();

MyClientSocketInterceptor myClientSocketInterceptor = new MyClientSocketInterceptor();

socketInterceptorConfig.setEnabled(true);
socketInterceptorConfig.setImplementation(myClientSocketInterceptor);
</code></pre>
<p>If you want to configure it with a class name instead of an instance;</p>
<pre><code class="lang-java">SocketInterceptorConfig socketInterceptorConfig = clientConfig
            .getNetworkConfig().getSocketInterceptorConfig();

MyClientSocketInterceptor myClientSocketInterceptor = new MyClientSocketInterceptor();

socketInterceptorConfig.setEnabled(true);

//These properties are provided to interceptor during init
socketInterceptorConfig.setProperty(&quot;kerberos-host&quot;,&quot;kerb-host-name&quot;);
socketInterceptorConfig.setProperty(&quot;kerberos-config-file&quot;,&quot;kerb.conf&quot;);

socketInterceptorConfig.setClassName(myClientSocketInterceptor);
</code></pre>
<p>Please see <a href="#socket-interceptor">Socket Interceptor</a> section for more information.</p>
<h4 id="socket-options">Socket Options</h4>
<p>Network socket options can be configured using <code>SocketOptions</code>. It has below methods.</p>
<ul>
<li><p><code>socketOptions.setKeepAlive(x)</code>: Enables/disables <em>SO_KEEPALIVE</em> socket option. Default is <code>true</code>.</p>
</li>
<li><p><code>socketOptions.setTcpNoDelay(x)</code>: Enables/disables <em>TCP_NODELAY</em> socket option. Default is <code>true</code>.</p>
</li>
<li><p><code>socketOptions.setReuseAddress(x)</code>: Enables/disables <em>SO_REUSEADDR</em> socket option. Default is <code>true</code>.</p>
</li>
<li><p><code>socketOptions.setLingerSeconds(x)</code>: Enables/disables <em>SO_LINGER</em> with the specified linger time in seconds. Default is <code>3</code>.</p>
</li>
<li><p><code>socketOptions.setBufferSize(x)</code>: Sets the <em>SO_SNDBUF</em> and <em>SO_RCVBUF</em> options to the specified value in KB for this Socket. Default is <code>32</code>.</p>
</li>
</ul>
<pre><code class="lang-java">SocketOptions socketOptions = clientConfig.getNetworkConfig().getSocketOptions();
socketOptions.setBufferSize(32);
socketOptions.setKeepAlive(true);
socketOptions.setTcpNoDelay(true);
socketOptions.setReuseAddress(true);
socketOptions.setLingerSeconds(3);
</code></pre>
<h4 id="ssl">SSL</h4>
<p><img src="images/enterprise-onlycopy.jpg" alt=""></p>
<p>SSL can be used to secure the connection between client and the nodes. Please see  <a href="#sslconfig">SSLConfig</a> section on how to configure it.</p>
<h4 id="configuration-for-aws">Configuration for AWS</h4>
<p>Below sample declarative and programmatic configurations show how to configure a Java client for connecting to a Hazelcast cluster in AWS. </p>
<p>Declarative Configuration:</p>
<pre><code class="lang-xml">&lt;aws enabled=&quot;true&quot;&gt;
  &lt;!-- optional default value is false --&gt;
  &lt;inside-aws&gt;false&lt;/inside-aws&gt;
  &lt;access-key&gt;my-access-key&lt;/access-key&gt;
  &lt;secret-key&gt;my-secret-key&lt;/secret-key&gt;
  &lt;!-- optional, default is us-east-1 --&gt;
  &lt;region&gt;us-west-1&lt;/region&gt;
  &lt;!-- optional, default is ec2.amazonaws.com. If set, region shouldn&#39;t be set
    as it will override this property
  --&gt;
  &lt;host-header&gt;ec2.amazonaws.com&lt;/host-header&gt;
  &lt;!-- optional --&gt;
  &lt;security-group-name&gt;hazelcast-sg&lt;/security-group-name&gt;
  &lt;!-- optional --&gt;
  &lt;tag-key&gt;type&lt;/tag-key&gt;
  &lt;!-- optional --&gt;
  &lt;tag-value&gt;hz-nodes&lt;/tag-value&gt;
&lt;/aws&gt;
</code></pre>
<p>Programmatic Configuration:</p>
<pre><code class="lang-java">ClientConfig clientConfig = new ClientConfig();
ClientAwsConfig clientAwsConfig = new ClientAwsConfig();
clientAwsConfig.setInsideAws( false )
               .setAccessKey( &quot;my-access-key&quot; )
               .setSecretKey( &quot;my-secret-key&quot; )
               .setRegion( &quot;us-west-1&quot; )
               .setHostHeader( &quot;ec2.amazonaws.com&quot; )
               .setSecurityGroupName( &quot;&gt;hazelcast-sg&quot; )
               .setTagKey( &quot;type&quot; )
               .setTagValue( &quot;hz-nodes&quot; );
clientConfig.getNetworkConfig().setAwsConfig( clientAwsConfig );
HazelcastInstance client = HazelcastClient.newHazelcastClient( clientConfig );
</code></pre>
<p><img src="images/NoteSmall.jpg" alt="image"> <strong><em>NOTE:</em></strong> <em>If </em><code>inside-aws</code><em> parameter is not set, private addresses of nodes will always be converted to public addresses. And, client will use public addresses to connect to nodes. In order to use private addresses, you should set it to </em><code>true</code><em>. Also note that, when connecting outside from AWS, setting </em><code>inside-aws</code><em> parameter to </em><code>true</code><em> will cause the client not to be able to reach to the nodes.</em></p>
<h4 id="load-balancer">Load Balancer</h4>
<p><code>LoadBalancer</code> allows you to send operations to one of a number of endpoints(Members). Its main purpose is to determine the next <code>Member</code> if queried.  It is up to the implementation to use different load balancing policies. The interface <code>com.hazelcast.client.LoadBalancer</code> should be implemented for that purpose.</p>
<p>If the client is configured as a smart one, only the operations that are not key based will be routed to the endpoint returned by the LoadBalancer. If it is not a smart client, <code>LoadBalancer</code> will be ignored.</p>
<p>For the configuration of a client load balancer, please see  <a href="#loadbalancerconfig">Load Balancer Config</a> and <a href="#java-client-declarative-configuration">Java Client Declarative Configuration</a>.</p>
<p>```</p>
<h3 id="client-near-cache">Client Near Cache</h3>
<p>Hazelcast distributed map has a Near Cache feature to reduce network latencies. As the client always requests data from the cluster nodes, it can be helpful for some use cases to configure a near cache on the client side.
The client supports the exact same near cache used in Hazelcast distributed map. </p>
<h3 id="client-sslconfig">Client SSLConfig</h3>
<p><img src="images/enterprise-onlycopy.jpg" alt=""></p>
<p>If SSL is desired to be enabled for the client-cluster connection, this parameter should be set. Once set, the connection (socket) is established out of an SSL factory defined either by a factory class name or factory implementation. Please see SSLConfig class in <code>com.hazelcast.config</code> package at the JavaDocs page of <a href="http://www.hazelcast.org/documentation/">Hazelcast Documentation</a> web page.</p>
<h3 id="java-client-configuration">Java Client Configuration</h3>
<p>Hazelcast Java client can be configured in two ways, declaratively or programmatically.</p>
<h4 id="java-client-declarative-configuration">Java Client Declarative Configuration</h4>
<p>Java client can be configured using an XML configuration file. 
Below is a generic template of a declarative configuration.</p>
<pre><code class="lang-xml">
&lt;hazelcast-client xsi:schemaLocation=
    &quot;http://www.hazelcast.com/schema/client-config hazelcast-client-config-3.3.xsd&quot;
                  xmlns=&quot;http://www.hazelcast.com/schema/client-config&quot;
                  xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&gt;

    &lt;!--Cluster name to connect--&gt;
    &lt;group&gt;
        &lt;name&gt;GROUP_NAME&lt;/name&gt;
        &lt;password&gt;GROUP_PASS&lt;/password&gt;
    &lt;/group&gt;

    &lt;!--client properties--&gt;
    &lt;properties&gt;
        &lt;property name=&quot;hazelcast.client.connection.timeout&quot;&gt;10000&lt;/property&gt;
        &lt;property name=&quot;hazelcast.client.retry.count&quot;&gt;6&lt;/property&gt;
    &lt;/properties&gt;

    &lt;!--Network configuration details--&gt;
    &lt;network&gt;
        &lt;cluster-members&gt;
            &lt;!--initial cluster members to connect--&gt;
            &lt;address&gt;127.0.0.1&lt;/address&gt;
            &lt;address&gt;127.0.0.2&lt;/address&gt;
        &lt;/cluster-members&gt;

        &lt;smart-routing&gt;true&lt;/smart-routing&gt;
        &lt;redo-operation&gt;true&lt;/redo-operation&gt;

        &lt;socket-interceptor enabled=&quot;true&quot;&gt;
            &lt;!--socket-interceptor configuration details--&gt;
        &lt;/socket-interceptor&gt;

        &lt;aws enabled=&quot;true&quot; connection-timeout-seconds=&quot;11&quot;&gt;
            &lt;!--AWS configuration details--&gt;
        &lt;/aws&gt;
    &lt;/network&gt;

    &lt;!--local executor pool size--&gt;
    &lt;executor-pool-size&gt;40&lt;/executor-pool-size&gt;

    &lt;!--security credentials configuration--&gt;
    &lt;security&gt;
        &lt;credentials&gt;com.hazelcast.security.UsernamePasswordCredentials&lt;/credentials&gt;
    &lt;/security&gt;

    &lt;listeners&gt;
        &lt;!--listeners--&gt;
    &lt;/listeners&gt;

    &lt;serialization&gt;
        &lt;!--serialization configuration details--&gt;
    &lt;/serialization&gt;

    &lt;proxy-factories&gt;
        &lt;!--ProxyFactory configuration details--&gt;
    &lt;/proxy-factories&gt;

    &lt;!--load balancer configuration--&gt;
    &lt;!-- type can be &quot;round-robin&quot; or &quot;random&quot; --&gt;
    &lt;load-balancer type=&quot;random&quot;/&gt;

    &lt;near-cache name=&quot;mapName&quot;&gt;
        &lt;!--near cache configuration details of a map--&gt;
    &lt;/near-cache&gt;

&lt;/hazelcast-client&gt;
</code></pre>
<h4 id="java-client-programmatic-configuration">Java Client Programmatic Configuration</h4>
<p>Using the configuration API, a <code>ClientConfig</code> configured as required. Please refer to the related sections and JavaDocs for more information.</p>
<h5 id="clientnetworkconfig">ClientNetworkConfig</h5>
<p>ClientNetworkConfig includes the below listed configuration options, which are explained under <a href="#network-configuration-options">Network Configuration Options</a> section.</p>
<ul>
<li>addressList</li>
<li>smartRouting</li>
<li>redoOperation</li>
<li>connectionTimeout</li>
<li>connectionAttemptLimit</li>
<li>connectionAttemptPeriod</li>
<li>SocketInterceptorConfig</li>
<li>SocketOptions</li>
<li>SSLConfig</li>
<li>ClientAwsConfig</li>
</ul>
<h5 id="groupconfig">GroupConfig</h5>
<p>Clients should provide group name and password in order to connect to the cluster.
It can be configured using <code>GroupConfig</code>, as shown below.</p>
<pre><code class="lang-java">clientConfig.setGroupConfig(new GroupConfig(&quot;dev&quot;,&quot;dev-pass&quot;));
</code></pre>
<h4 id="loadbalancerconfig">LoadBalancerConfig</h4>
<p>The following code snippet shows the programmatic configuration of the load balancer. </p>
<pre><code class="lang-java">clientConfig.setLoadBalancer(yourLoadBalancer);
</code></pre>
<h5 id="clientsecurityconfig">ClientSecurityConfig</h5>
<p>In the cases where the security established with <code>GroupConfig</code> is not enough and you want your clients connecting securely to the cluster, <code>ClientSecurityConfig</code> can be used. This configuration has a <code>credentials</code> parameter with which IP address and UID are set. Please see <code>ClientSecurityConfig.java</code> in our code.</p>
<h5 id="serializationconfig">SerializationConfig</h5>
<p>For the client side serialization, Hazelcast configuration is used. Please refer to <a href="#serialization">Serialization</a> chapter.</p>
<h5 id="listenerconfig">ListenerConfig</h5>
<p>Global event listeners can be configured using <code>ListenerConfig</code> as shown below.</p>
<pre><code class="lang-java">ClientConfig clientConfig = new ClientConfig();
ListenerConfig listenerConfig = new ListenerConfig(LifecycleListenerImpl);
clientConfig.addListenerConfig(listenerConfig);
</code></pre>
<pre><code class="lang-java">ClientConfig clientConfig = new ClientConfig();
ListenerConfig listenerConfig = new ListenerConfig(&quot;com.hazelcast.example.MembershipListenerImpl&quot;);
clientConfig.addListenerConfig(listenerConfig);
</code></pre>
<p>There are three types of event listeners that can be added.</p>
<ul>
<li>LifecycleListener</li>
<li>MembershipListener</li>
<li>DistributedObjectListener</li>
</ul>
<p><strong><em>RELATED INFORMATION</em></strong></p>
<p><em>Please refer to Hazelcast JavaDocs and see LifecycleListener, MembershipListener and DistributedObjectListener in <code>com.hazelcast.core</code> package.</em>
<br></br></p>
<h5 id="nearcacheconfig">NearCacheConfig</h5>
<p>A near cache on the client side can be configured by providing a configuration per map name, as shown below.</p>
<pre><code class="lang-java">ClientConfig clientConfig = new ClientConfig();
CacheConfig nearCacheConfig = new NearCacheConfig();
nearCacheConfig.setName(&quot;mapName&quot;);
clientConfig.addNearCacheConfig(nearCacheConfig);
</code></pre>
<p>Wildcards can be used for the map name. See below samples.</p>
<pre><code class="lang-java">nearCacheConfig.setName(&quot;map*&quot;);
nearCacheConfig.setName(&quot;*map&quot;);
</code></pre>
<h5 id="classloader">ClassLoader</h5>
<p>A custom <code>classLoader</code> can be configured. It will be used by serialization service and to load any class configured in configuration like event listeners or ProxyFactories.</p>
<h5 id="executorpoolsize">ExecutorPoolSize</h5>
<p>Hazelcast has an internal executor service (different from the data structure <em>Executor Service</em>) that has threads and queues to perform internal operations such as handling responses. This parameter specifies the size of the pool of threads which perform these operations laying in the executor&#39;s queue. If not configured, this parameter has the value as <strong>5 * <em>core size of the client</em></strong> (i.e. it is 20 for a machine that has 4 cores).</p>
<h5 id="client-properties">Client Properties</h5>
<p>There are some advanced client configuration properties to tune some aspects of Hazelcast Client. These can be set as property name and value pairs through declarative configuration, programmatic configuration or JVM system property. Please see <a href="#advanced-configuration-properties">Advanced Configuration Properties</a> section to learn how to set these properties.</p>
<p>Below table lists the client configuration properties with their descriptions.</p>
<table>
<thead>
<tr>
<th style="text-align:left">Property Name</th>
<th style="text-align:left">Default Value</th>
<th style="text-align:left">Type</th>
<th style="text-align:left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>hazelcast.client.heartbeat.timeout</code></td>
<td style="text-align:left">300000</td>
<td style="text-align:left">string</td>
<td style="text-align:left">Timeout for the heartbeat messages sent by the client to members. If there is no any message passing between client and member within the given time via this property in milliseconds the connection will be closed.</td>
</tr>
<tr>
<td style="text-align:left"><code>hazelcast.client.heartbeat.interval</code></td>
<td style="text-align:left">10000</td>
<td style="text-align:left">string</td>
<td style="text-align:left">The frequency of heartbeat messages sent by the clients to members.</td>
</tr>
<tr>
<td style="text-align:left"><code>hazelcast.client.max.failed.heartbeat.count</code></td>
<td style="text-align:left">3</td>
<td style="text-align:left">string</td>
<td style="text-align:left">When the count of failed heartbeats sent to members reaches this value, the cluster is deemed as dead by the client.</td>
</tr>
<tr>
<td style="text-align:left"><code>hazelcast.client.request.retry.count</code></td>
<td style="text-align:left">20</td>
<td style="text-align:left">string</td>
<td style="text-align:left">The retry count of the connection requests by the client to the members.</td>
</tr>
<tr>
<td style="text-align:left"><code>hazelcast.client.request.retry.wait.time</code></td>
<td style="text-align:left">250</td>
<td style="text-align:left">string</td>
<td style="text-align:left">The frequency of the connection retries.</td>
</tr>
<tr>
<td style="text-align:left"><code>hazelcast.client.event.thread.count</code></td>
<td style="text-align:left">5</td>
<td style="text-align:left">string</td>
<td style="text-align:left">Thread count for handling incoming event packets.</td>
</tr>
<tr>
<td style="text-align:left"><code>hazelcast.client.event.queue.capacity</code></td>
<td style="text-align:left">1000000</td>
<td style="text-align:left">string</td>
<td style="text-align:left">Default value of the capacity of executor that handles incoming event packets.</td>
</tr>
</tbody>
</table>
<h3 id="sample-codes-for-client">Sample Codes for Client</h3>
<p>Please refer to <a href="https://github.com/hazelcast/hazelcast-code-samples/tree/master/clients">Client Code Samples</a>.</p>
<h2 id="c-client">C++ Client</h2>
<p><img src="images/enterprise-onlycopy.jpg" alt=""></p>
<p>You can use Native C++ Client to connect to Hazelcast nodes and perform almost all operations that a node can perform. Different from nodes, clients do not hold data. It is by default a smart client, i.e. it knows where the data is and asks directly to the correct node. This feature can be disabled (using <code>ClientConfig::setSmart</code> method) if you do not want the clients to connect every node.</p>
<p>Features of C++ Clients are:</p>
<ul>
<li>Access to distributed data structures (IMap, IQueue, MultiMap, ITopic, etc.).</li>
<li>Access to transactional distributed data structures (TransactionalMap, TransactionalQueue, etc.).</li>
<li>Ability to add cluster listeners to a cluster and entry/item listeners to distributed data structures.</li>
<li>Distributed synchronization mechanisms with ILock, ISemaphore and ICountDownLatch.</li>
</ul>
<h3 id="how-to-setup">How to Setup</h3>
<p>Hazelcast C++ Client is shipped with 32/64 bit, shared and static libraries. Compiled static libraries of dependencies are also available in the release. Dependencies are <strong>zlib</strong> and <strong>shared_ptr</strong> from the boost libraries. </p>
<p>Downloaded release folder consists of:</p>
<ul>
<li>Mac_64/</li>
<li>Windows_32/</li>
<li>Windows_64/</li>
<li>Linux_32/</li>
<li>Linux_64/</li>
<li>docs/ <em>(HTML Doxygen documents are here)</em></li>
</ul>
<p>And each of the folders above contains the following:</p>
<ul>
<li><p>examples/</p>
<ul>
<li>testApp.exe =&gt; example command line client tool to connect hazelcast servers.</li>
<li>TestApp.cpp =&gt; code of the example command line tool.</li>
</ul>
</li>
<li><p>hazelcast/</p>
<ul>
<li>lib/ =&gt; Contains both shared and static library of hazelcast.</li>
<li>include/ =&gt; Contains headers of client</li>
</ul>
</li>
<li><p>external/</p>
<ul>
<li>lib/ =&gt; Contains compiled static libraries of zlib.</li>
<li>include/ =&gt; Contains headers of dependencies.(zlib and boost::shared_ptr)</li>
</ul>
</li>
</ul>
<h3 id="platform-specific-installation-guides">Platform Specific Installation Guides</h3>
<p>C++ Client is tested on Linux 32/64, Mac 64 and Windows 32/64 bit machines. For each of the headers above, it is assumed that you are in the correct folder for your platform. Folders are Mac_64, Windows_32, Windows_64, Linux_32 or Linux_64.</p>
<h4 id="linux">Linux</h4>
<p>For Linux, there are two distributions; 32 bit and 64 bit.</p>
<p>Sample script to build with static library:</p>
<p><code>g++ main.cpp -pthread -I./external/include -I./hazelcast/include 
     ./hazelcast/lib/libHazelcastClientStatic_64.a 
     ./external/lib/libz.a</code></p>
<p>Sample script to build with shared library:</p>
<p><code>g++ main.cpp -lpthread -Wl,–no-as-needed -lrt -I./external/include -I./hazelcast/include -L./hazelcast/lib -lHazelcastClientShared_64 ./external/lib/libz.a</code></p>
<h4 id="mac">Mac</h4>
<p>For Mac, there is only one distribution which is 64 bit.</p>
<p>Sample script to build with static library:</p>
<p><code>g++ main.cpp -I./external/include -I./hazelcast/include ./hazelcast/lib/libHazelcastClientStatic_64.a ./external/lib/darwin/libz.a</code></p>
<p>Sample script to build with shared library:</p>
<p><code>g++ main.cpp -I./external/include -I./hazelcast/include -L./hazelcast/lib -lHazelcastClientShared_64 ./external/lib/darwin/libz.a</code></p>
<h4 id="windows">Windows</h4>
<p>For Windows, there are two distributions; 32 bit and 64 bit. Current release have only Visual Studio 2010 compatible libraries. For others, please contact with <a href="support@hazelcast.com">support@hazelcast.com</a>.</p>
<h3 id="code-examples">Code Examples</h3>
<p>A Hazelcast node should be running to make below sample codes work.</p>
<h4 id="map-example">Map Example</h4>
<pre><code class="lang-cpp">#include &lt;hazelcast/client/HazelcastAll.h&gt;
#include &lt;iostream&gt;

using namespace hazelcast::client;

int main() {
  ClientConfig clientConfig;
  Address address( &quot;localhost&quot;, 5701 );
  clientConfig.addAddress( address );

  HazelcastClient hazelcastClient( clientConfig );

  IMap&lt;int,int&gt; myMap = hazelcastClient.getMap&lt;int ,int&gt;( &quot;myIntMap&quot; );
  myMap.put( 1,3 );
  boost::shared_ptr&lt;int&gt; value = myMap.get( 1 );
  if( value.get() != NULL ) {
    //process the item
  }

  return 0;
}
</code></pre>
<h4 id="queue-example">Queue Example</h4>
<pre><code class="lang-cpp">#include &lt;hazelcast/client/HazelcastAll.h&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;

using namespace hazelcast::client;

int main() {
  ClientConfig clientConfig;
  Address address( &quot;localhost&quot;, 5701 );
  clientConfig.addAddress( address );

  HazelcastClient hazelcastClient( clientConfig );

  IQueue&lt;std::string&gt; queue = hazelcastClient.getQueue&lt;std::string&gt;( &quot;q&quot; );
  queue.offer( &quot;sample&quot; );
  boost::shared_ptr&lt;std::string&gt; value = queue.poll();
  if( value.get() != NULL ) {
    //process the item
  }
  return 0;
}
</code></pre>
<h4 id="entry-listener-example">Entry Listener Example</h4>
<pre><code class="lang-cpp">#include &quot;hazelcast/client/ClientConfig.h&quot;
#include &quot;hazelcast/client/EntryEvent.h&quot;
#include &quot;hazelcast/client/IMap.h&quot;
#include &quot;hazelcast/client/Address.h&quot;
#include &quot;hazelcast/client/HazelcastClient.h&quot;
#include &lt;iostream&gt;
#include &lt;string&gt;

using namespace hazelcast::client;

class SampleEntryListener {
  public:

  void entryAdded( EntryEvent&lt;std::string, std::string&gt; &amp;event ) {
    std::cout &lt;&lt; &quot;entry added &quot; &lt;&lt;  event.getKey() &lt;&lt; &quot; &quot;
        &lt;&lt; event.getValue() &lt;&lt; std::endl;
  };

  void entryRemoved( EntryEvent&lt;std::string, std::string&gt; &amp;event ) {
    std::cout &lt;&lt; &quot;entry added &quot; &lt;&lt;  event.getKey() &lt;&lt; &quot; &quot; 
        &lt;&lt; event.getValue() &lt;&lt; std::endl;
  }

  void entryUpdated( EntryEvent&lt;std::string, std::string&gt; &amp;event ) {
    std::cout &lt;&lt; &quot;entry added &quot; &lt;&lt;  event.getKey() &lt;&lt; &quot; &quot; 
        &lt;&lt; event.getValue() &lt;&lt; std::endl;
  }

  void entryEvicted( EntryEvent&lt;std::string, std::string&gt; &amp;event ) {
    std::cout &lt;&lt; &quot;entry added &quot; &lt;&lt;  event.getKey() &lt;&lt; &quot; &quot; 
        &lt;&lt; event.getValue() &lt;&lt; std::endl;
  }
};


int main( int argc, char **argv ) {
  ClientConfig clientConfig;
  Address address( &quot;localhost&quot;, 5701 );
  clientConfig.addAddress( address );

  HazelcastClient hazelcastClient( clientConfig );

  IMap&lt;std::string,std::string&gt; myMap = hazelcastClient
      .getMap&lt;std::string ,std::string&gt;( &quot;myIntMap&quot; );
  SampleEntryListener *  listener = new SampleEntryListener();

  std::string id = myMap.addEntryListener( *listener, true );
  // Prints entryAdded
  myMap.put( &quot;key1&quot;, &quot;value1&quot; );
  // Prints updated
  myMap.put( &quot;key1&quot;, &quot;value2&quot; );
  // Prints entryRemoved
  myMap.remove( &quot;key1&quot; );
  // Prints entryEvicted after 1 second
  myMap.put( &quot;key2&quot;, &quot;value2&quot;, 1000 );

  // WARNING: deleting listener before removing it from hazelcast leads to crashes.
  myMap.removeEntryListener( id );
  // Delete listener after remove it from hazelcast.
  delete listener;               
  return 0;
};
</code></pre>
<h4 id="serialization-example">Serialization Example</h4>
<p>Assume that you have the following two classes in Java and you want to use it with C++ client. </p>
<pre><code class="lang-java">class Foo implements Serializable {
  private int age;
  private String name;
}

class Bar implements Serializable {
  private float x;
  private float y;
}
</code></pre>
<p><strong>First</strong>, let them implement <code>Portable</code> or <code>IdentifiedDataSerializable</code> as shown below.</p>
<pre><code class="lang-java">class Foo implements Portable {
  private int age;
  private String name;

  public int getFactoryId() {
    // a positive id that you choose
    return 123;
  }

  public int getClassId() {
    // a positive id that you choose
    return 2;     
  }

  public void writePortable( PortableWriter writer ) throws IOException {
    writer.writeUTF( &quot;n&quot;, name );
    writer.writeInt( &quot;a&quot;, age );
  }

  public void readPortable( PortableReader reader ) throws IOException {
    name = reader.readUTF( &quot;n&quot; );
    age = reader.readInt( &quot;a&quot; );
  }
}

class Bar implements IdentifiedDataSerializable {
  private float x;
  private float y;

  public int getFactoryId() {
    // a positive id that you choose
    return 4;     
  }

  public int getId() {
    // a positive id that you choose
    return 5;    
  }

  public void writeData( ObjectDataOutput out ) throws IOException {
    out.writeFloat( x );
    out.writeFloat( y );
  }

  public void readData( ObjectDataInput in ) throws IOException {
    x = in.readFloat();
    y = in.readFloat();
  }
}
</code></pre>
<p><strong>Then</strong>, implement the corresponding classes in C++ with same factory and class ID as shown below:</p>
<pre><code class="lang-cpp">class Foo : public Portable {
  public:
  int getFactoryId() const {
    return 123;
  };

  int getClassId() const {
    return 2;
  };

  void writePortable( serialization::PortableWriter &amp;writer ) const {
    writer.writeUTF( &quot;n&quot;, name );
    writer.writeInt( &quot;a&quot;, age );
  };

  void readPortable( serialization::PortableReader &amp;reader ) {
    name = reader.readUTF( &quot;n&quot; );
    age = reader.readInt( &quot;a&quot; );
  };

  private:
  int age;
  std::string name;
};

class Bar : public IdentifiedDataSerializable {
  public:
  int getFactoryId() const {
    return 4;
  };

  int getClassId() const {
    return 2;
  };

  void writeData( serialization::ObjectDataOutput&amp; out ) const {
    out.writeFloat(x);
    out.writeFloat(y);
  };

  void readData( serialization::ObjectDataInput&amp; in ) {
    x = in.readFloat();
    y = in.readFloat();
  };

  private:
  float x;
  float y;
};
</code></pre>
<p>Now, you can use class <code>Foo</code> and <code>Bar</code> in distributed structures. For example as Key or Value of <code>IMap</code> or as an Item in <code>IQueue</code>.</p>
<h2 id="-net-client">.NET Client</h2>
<p><img src="images/enterprise-onlycopy.jpg" alt=""></p>
<p>You can use native .NET client to connect to Hazelcast nodes. All you need is to add <code>HazelcastClient3x.dll</code> into your .NET project references. The API is very similar to Java native client. </p>
<p>.NET Client has following distributed objects:</p>
<ul>
<li><code>IMap&lt;K,V&gt;</code></li>
<li><code>IMultiMap&lt;K,V&gt;</code></li>
<li><code>IQueue&lt;E&gt;</code></li>
<li><code>ITopic&lt;E&gt;</code></li>
<li><code>IHList&lt;E&gt;</code></li>
<li><code>IHSet&lt;E&gt;</code></li>
<li><code>IIdGenerator</code></li>
<li><code>ILock</code></li>
<li><code>ISemaphore</code></li>
<li><code>ICountDownLatch</code></li>
<li><code>IAtomicLong</code></li>
<li><code>ITransactionContext</code></li>
</ul>
<p>ITransactionContext can be used to obtain;</p>
<ul>
<li><code>ITransactionalMap&lt;K,V&gt;</code></li>
<li><code>ITransactionalMultiMap&lt;K,V&gt;</code></li>
<li><code>ITransactionalList&lt;E&gt;</code></li>
<li><code>ITransactionalSet&lt;E&gt;</code></li>
</ul>
<p>Sample code is shown below.</p>
<pre><code class="lang-csharp">using Hazelcast.Config;
using Hazelcast.Client;
using Hazelcast.Core;
using Hazelcast.IO.Serialization;

using System.Collections.Generic;

namespace Hazelcast.Client.Example
{
  public class SimpleExample
  {

    public static void Test()
    {
      var clientConfig = new ClientConfig();
      clientConfig.GetNetworkConfig().AddAddress( &quot;10.0.0.1&quot; );
      clientConfig.GetNetworkConfig().AddAddress( &quot;10.0.0.2:5702&quot; );

      // Portable Serialization setup up for Customer Class
      clientConfig.GetSerializationConfig()
          .AddPortableFactory( MyPortableFactory.FactoryId, new MyPortableFactory() );

      IHazelcastInstance client = HazelcastClient.NewHazelcastClient( clientConfig );
      // All cluster operations that you can do with ordinary HazelcastInstance
      IMap&lt;string, Customer&gt; mapCustomers = client.GetMap&lt;string, Customer&gt;( &quot;customers&quot; );
      mapCustomers.Put( &quot;1&quot;, new Customer( &quot;Joe&quot;, &quot;Smith&quot; ) );
      mapCustomers.Put( &quot;2&quot;, new Customer( &quot;Ali&quot;, &quot;Selam&quot; ) );
      mapCustomers.Put( &quot;3&quot;, new Customer( &quot;Avi&quot;, &quot;Noyan&quot; ) );

      ICollection&lt;Customer&gt; customers = mapCustomers.Values();
      foreach (var customer in customers)
      {
        //process customer
      }
    }
  }

  public class MyPortableFactory : IPortableFactory
  {
    public const int FactoryId = 1;

    public IPortable Create( int classId ) {
      if ( Customer.Id == classId )
        return new Customer();
      else
        return null;
    }
  }

  public class Customer : IPortable
  {
    private string name;
    private string surname;

    public const int Id = 5;

    public Customer( string name, string surname )
    {
      this.name = name;
      this.surname = surname;
    }

    public Customer() {}

    public int GetFactoryId()
    {
      return MyPortableFactory.FactoryId;
    }

    public int GetClassId()
    {
      return Id;
    }

    public void WritePortable( IPortableWriter writer )
    {
      writer.WriteUTF( &quot;n&quot;, name );
      writer.WriteUTF( &quot;s&quot;, surname );
    }

    public void ReadPortable( IPortableReader reader )
    {
      name = reader.ReadUTF( &quot;n&quot; );
      surname = reader.ReadUTF( &quot;s&quot; );
    }
  }
}
</code></pre>
<h3 id="client-configuration">Client Configuration</h3>
<p>Hazelcast .NET client can be configured via API or XML. To start the client, a configuration can be passed or can be left empty to use default values.</p>
<p><img src="images/NoteSmall.jpg" alt="image"> <strong><em>NOTE</em></strong>: <em>.NET and Java clients are similar in terms of configuration. Therefore, you can refer to <a href="#java-client">Java Client</a> section for configuration aspects. For information on .NET API documentation, please refer to the API document provided along with the Hazelcast Enterprise license</em>.</p>
<h3 id="client-startup">Client Startup</h3>
<p>After configuration, one can obtain a client using one of the static methods of Hazelcast like as shown below.</p>
<pre><code class="lang-csharp">IHazelcastInstance client = HazelcastClient.NewHazelcastClient(clientConfig);

...


IHazelcastInstance defaultClient = HazelcastClient.NewHazelcastClient();

...

IHazelcastInstance xmlConfClient = Hazelcast
    .NewHazelcastClient(@&quot;..\Hazelcast.Net\Resources\hazelcast-client.xml&quot;);
</code></pre>
<p>IHazelcastInstance interface is the starting point where all distributed objects can be obtained using it.</p>
<pre><code class="lang-csharp">var map = client.GetMap&lt;int,string&gt;(&quot;mapName&quot;);

...

var lock= client.GetLock(&quot;thelock&quot;);
</code></pre>
<h2 id="rest-client">REST Client</h2>
<p>Hazelcast provides REST interface, i.e. it provides an HTTP service in each node so that your <code>map</code> and <code>queue</code> can be accessed using HTTP protocol. Assuming <code>mapName</code> and <code>queueName</code> are already configured in your Hazelcast, its structure is shown below:</p>
<p><code>http://node IP address:port/hazelcast/rest/maps/mapName/key</code></p>
<p><code>http://node IP address:port/hazelcast/rest/queues/queueName</code></p>
<p>For the operations to be performed, standard REST conventions for HTTP calls are used.</p>
<p>Assume that your cluster members are as shown below.</p>
<pre><code class="lang-plain">Members [5] {
  Member [10.20.17.1:5701]
  Member [10.20.17.2:5701]
  Member [10.20.17.4:5701]
  Member [10.20.17.3:5701]
  Member [10.20.17.5:5701]
}
</code></pre>
<hr>
<p><img src="images/NoteSmall.jpg" alt="image"> <strong><em>NOTE</em></strong>: <em>All of the requests below can return one of the following two in case of a failure</em></p>
<ul>
<li>If HTTP request syntax is not known, the following will be returned as response.</li>
</ul>
<pre><code class="lang-plain">HTTP/1.1 400 Bad Request
Content-Length: 0
</code></pre>
<ul>
<li>In case of an unexpected exception, it will return:</li>
</ul>
<pre><code class="lang-plain">&lt; HTTP/1.1 500 Internal Server Error
&lt; Content-Length: 0
</code></pre>
<hr>
<p><strong>Creating/Updating Entries in a Map</strong></p>
<p>You can put a new <code>key1/value1</code> entry into a map by using POST call to 
<code>http://10.20.17.1:5701/hazelcast/rest/maps/mapName/key1</code> URL. This call&#39;s content body should contain the value of the key. Also, if the call contains the MIME type, Hazelcast stores this information, too. </p>
<p>A sample POST call is shown below.</p>
<pre><code class="lang-plain">$ curl -v -X POST -H &quot;Content-Type: text/plain&quot; -d &quot;bar&quot; 
    http://10.20.17.1:5701/hazelcast/rest/maps/mapName/foo
</code></pre>
<p>It will return the following if successful:</p>
<pre><code class="lang-plain">&lt; HTTP/1.1 200 OK
&lt; Content-Type: text/plain
&lt; Content-Length: 0
</code></pre>
<p><strong>Retrieving Entries from a Map</strong></p>
<p>If you want to retrieve an entry, you can use GET call to <code>http://10.20.17.1:5701/hazelcast/rest/maps/mapName/key1</code>. You can also retrieve this entry from another member of your cluster such as 
<code>http://10.20.17.3:5701/hazelcast/rest/maps/mapName/key1</code>.</p>
<p>A sample GET call is shown below.</p>
<pre><code class="lang-plain">$ curl -X GET http://10.20.17.3:5701/hazelcast/rest/maps/mapName/foo
</code></pre>
<p>It will return the following if there is a corresponding value:</p>
<pre><code class="lang-plain">&lt; HTTP/1.1 200 OK
&lt; Content-Type: text/plain
&lt; Content-Length: 3
bar
</code></pre>
<p>As you can see, GET call returned value, its length and also the MIME type (<code>text/plain</code>) since POST call sample shown above included the MIME type.</p>
<p>It will return the following if there is no mapping for the given key:</p>
<pre><code class="lang-plain">&lt; HTTP/1.1 204 No Content
&lt; Content-Length: 0
</code></pre>
<p><strong>Removing Entries from a Map</strong></p>
<p>You can use DELETE call to remove an entry. A sample DELETE call is shown below with its returns.</p>
<pre><code class="lang-plain">$ curl -v -X DELETE http://10.20.17.1:5701/hazelcast/rest/maps/mapName/foo
</code></pre>
<pre><code>&lt; HTTP/1.1 200 OK
&lt; Content-Type: text/plain
&lt; Content-Length: 0
</code></pre><p>If you leave key empty as follows, it will delete all entries from map.</p>
<pre><code class="lang-plain">$ curl -v -X DELETE http://10.20.17.1:5701/hazelcast/rest/maps/mapName
</code></pre>
<pre><code class="lang-plain">&lt; HTTP/1.1 200 OK
&lt; Content-Type: text/plain
&lt; Content-Length: 0
</code></pre>
<p><strong>Offering Items on a Queue</strong></p>
<p>You can use POST call to create an item on the queue. A sample is shown below.</p>
<pre><code class="lang-plain">$ curl -v -X POST -H &quot;Content-Type: text/plain&quot; -d &quot;foo&quot; 
    http://10.20.17.1:5701/hazelcast/rest/queues/myEvents
</code></pre>
<p>Above call is equivalent to <code>HazelcastInstance#getQueue(&quot;myEvents&quot;).offer(&quot;foo&quot;);</code>.</p>
<p>It will return the following if successful:</p>
<pre><code class="lang-plain">&lt; HTTP/1.1 200 OK
&lt; Content-Type: text/plain
&lt; Content-Length: 0
</code></pre>
<p>It will return the following if queue is full and item is not be able to offered to queue:</p>
<pre><code class="lang-plain">&lt; HTTP/1.1 503 Service Unavailable
&lt; Content-Length: 0
</code></pre>
<p><strong>Retrieving Items from a Queue</strong></p>
<p>DELETE call can be used for retrieving. Note that, poll timeout should be stated while polling for queue events by an extra path parameter. </p>
<p>A sample is shown below (<strong>10</strong> being the timeout value).</p>
<pre><code class="lang-plain">$ curl -v -X DELETE \http://10.20.17.1:5701/hazelcast/rest/queues/myEvents/10
</code></pre>
<p>Above call is equivalent to <code>HazelcastInstance#getQueue(&quot;myEvents&quot;).poll(10, SECONDS);</code>. Below is the returns of above call.</p>
<pre><code class="lang-plain">&lt; HTTP/1.1 200 OK
&lt; Content-Type: text/plain
&lt; Content-Length: 3
foo
</code></pre>
<p>When the timeout is reached, the return will be <code>No Content</code> success, i.e. there is no item on the queue to be returned.</p>
<pre><code class="lang-plain">&lt; HTTP/1.1 204 No Content
&lt; Content-Length: 0
</code></pre>
<p><strong>Getting the size of the queue</strong></p>
<pre><code class="lang-plain">$ curl -v -X GET \http://10.20.17.1:5701/hazelcast/rest/queues/myEvents/size
</code></pre>
<p>Above call is equivalent to <code>HazelcastInstance#getQueue(&quot;myEvents&quot;).size();</code>. Below is a sample return of above call.</p>
<pre><code class="lang-plain">&lt; HTTP/1.1 200 OK
&lt; Content-Type: text/plain
&lt; Content-Length: 1
5
</code></pre>
<hr>
<p>Besides the above operations, you can check the status of your cluster, a sample of which is shown below.</p>
<pre><code class="lang-plain">$ curl -v http://127.0.0.1:5701/hazelcast/rest/cluster
</code></pre>
<p>The return will be similar to the following:</p>
<pre><code class="lang-plain">&lt; HTTP/1.1 200 OK
&lt; Content-Length: 119

Members [5] {
  Member [10.20.17.1:5701] this
  Member [10.20.17.2:5701]
  Member [10.20.17.4:5701]
  Member [10.20.17.3:5701]
  Member [10.20.17.5:5701]
}

ConnectionCount: 5
AllConnectionCount: 20
</code></pre>
<hr>
<p>RESTful access is provided through any member of your cluster. So you can even put an HTTP load-balancer in front of your cluster members for load balancing and fault tolerance.</p>
<p><img src="images/NoteSmall.jpg" alt="image"> <strong><em>NOTE</em></strong>: <em>You need to handle the failures on REST polls as there is no transactional guarantee.</em></p>
<h2 id="memcache-client">Memcache Client</h2>
<p><img src="images/NoteSmall.jpg" alt="image"> <strong><em>NOTE:</em></strong> <em>Hazelcast Memcache Client only supports ASCII protocol. Binary Protocol is not supported.</em></p>
<p>A Memcache client written in any language can talk directly to Hazelcast cluster. No additional configuration is required. Assume that your cluster members are as below.</p>
<pre><code class="lang-plain">Members [5] {
  Member [10.20.17.1:5701]
  Member [10.20.17.2:5701]
  Member [10.20.17.4:5701]
  Member [10.20.17.3:5701]
  Member [10.20.17.5:5701]
}
</code></pre>
<p>And you have a PHP application that uses PHP Memcache client to cache things in Hazelcast. All you need to do is have your PHP Memcache client connect to one of these members. It does not matter which member the client connects to because Hazelcast cluster looks as one giant machine (Single System Image). PHP client code sample:</p>
<pre><code class="lang-php">&lt;?php
  $memcache = new Memcache;
  $memcache-&gt;connect( &#39;10.20.17.1&#39;, 5701 ) or die ( &quot;Could not connect&quot; );
  $memcache-&gt;set( &#39;key1&#39;, &#39;value1&#39;, 0, 3600 );
  $get_result = $memcache-&gt;get( &#39;key1&#39; ); // retrieve your data
  var_dump( $get_result ); // show it
?&gt;
</code></pre>
<p>Notice that Memcache client is connecting to <code>10.20.17.1</code> and using port<code>5701</code>. Java client code sample with SpyMemcached client:</p>
<pre><code class="lang-java">MemcachedClient client = new MemcachedClient(
    AddrUtil.getAddresses( &quot;10.20.17.1:5701 10.20.17.2:5701&quot; ) );
client.set( &quot;key1&quot;, 3600, &quot;value1&quot; );
System.out.println( client.get( &quot;key1&quot; ) );
</code></pre>
<p>If you want your data to be stored in different maps (e.g. to utilize per map configuration), you can do that with a map name prefix as following:</p>
<pre><code class="lang-java">MemcachedClient client = new MemcachedClient(
    AddrUtil.getAddresses( &quot;10.20.17.1:5701 10.20.17.2:5701&quot; ) );
client.set( &quot;map1:key1&quot;, 3600, &quot;value1&quot; ); // store to *hz_memcache_map1
client.set( &quot;map2:key1&quot;, 3600, &quot;value1&quot; ); // store to hz_memcache_map2
System.out.println( client.get( &quot;key1&quot; ) ); // get from hz_memcache_map1
System.out.println( client.get( &quot;key2&quot; ) ); // get from hz_memcache_map2
</code></pre>
<p><em>hz_memcache prefix_</em> is to separate Memcache maps from Hazelcast maps. If no map name is given, it will be stored
in default map named as <em>hz_memcache_default</em>.</p>
<p>An entry written with a Memcache client can be read by another Memcache client written in another language.</p>
<h3 id="unsupported-operations">Unsupported Operations</h3>
<ul>
<li><p>CAS operations are not supported. In operations getting CAS parameters like append, CAS values are ignored.</p>
</li>
<li><p>Only a subset of statistics are supported. Below is the list of supported statistic values.</p>
<ul>
<li>cmd_set</li>
<li>cmd_get</li>
<li>incr_hits</li>
<li>incr_misses</li>
<li>decr_hits</li>
<li>decr_misses</li>
</ul>
</li>
</ul>
<p><br> </br></p>
<h1 id="serialization">Serialization</h1>
<h2 id="serialization-overview">Serialization Overview</h2>
<p>Java objects that you put into Hazelcast need to be serialized since Hazelcast is a distributed system. The data and its replicas are stored in different partitions on multiple nodes. The data you need may not be present on the local machine and Hazelcast retrieves that data from another machine. And this requires serialization.</p>
<p>Hazelcast serializes all your objects into an instance of <code>com.hazelcast.nio.serialization.Data</code>. <code>Data</code> is the binary representation of an object. </p>
<p>Serialization is used when;</p>
<ul>
<li>key/value objects are added to a map,</li>
<li>items are put in a queue/set/list,</li>
<li>a runnable is sent using an executor service,</li>
<li>an entry processing is performed within a map,</li>
<li>an object is locked,and</li>
<li>a message is sent to a topic</li>
</ul>
<p>Hazelcast optimizes the serialization for the below types, and the user cannot override this behavior:</p>
<p><img src="images/OptimizedTypes.jpg" alt="image"></p>
<p>Hazelcast also optimizes the following types. However, you can override them by creating a custom serializer and registering it. See <a href="#custom-serialization">Custom Serialization</a> for more information.</p>
<p><img src="images/OptimizedTypesII.jpg" alt="image"></p>
<p>As we have said, Hazelcast optimizes all of the above object types and you do not need to worry about their (de)serializations.</p>
<h2 id="serialization-interfaces">Serialization Interfaces</h2>
<p>When it comes to complex objects, below interfaces are used for serialization and deserialization.</p>
<ul>
<li><p><code>java.io.Serializable</code></p>
</li>
<li><p><code>java.io.Externalizable</code></p>
</li>
<li><p><code>com.hazelcast.nio.serialization.DataSerializable</code></p>
</li>
<li><p><code>com.hazelcast.nio.serialization.IdentifiedDataSerializable</code></p>
</li>
<li><p><code>com.hazelcast.nio.serialization.Portable</code>, and</p>
</li>
<li>Custom Serialization (using <code>StreamSerializer</code>, <code>ByteArraySerializer</code>)</li>
</ul>
<p>When Hazelcast serializes an object into <code>Data</code>:</p>
<p><strong>(1)</strong> It first checks whether the object is an instance of <code>com.hazelcast.nio.serialization.DataSerializable</code>, </p>
<p><strong>(2)</strong> If above fails, then it checks if it is an instance of <code>com.hazelcast.nio.serialization.Portable</code>,</p>
<p><strong>(3)</strong> If above fails, then it checks whether the object is of a well-known type like String, Long, Integer, etc. and user specified types like ByteArraySerializer or StreamSerializer,</p>
<p><strong>(4)</strong> If above checks fail, Hazelcast will use Java serialization.</p>
<p>If all of the above checks do not work, then serialization will fail. When a class implements multiple interfaces, above steps are important to determine the serialization mechanism that Hazelcast will use. And when a class definition is required for any of these serializations, all the classes needed by the application should be on the classpath, Hazelcast does not download them automatically.</p>
<h2 id="comparison-table">Comparison Table</h2>
<p>Below table provides a comparison between the interfaces listed in the previous section to help you in deciding which interface to use in your applications.</p>
<table>
<thead>
<tr>
<th style="text-align:left"><em>Serialization Interface</em></th>
<th style="text-align:left"><em>Advantages</em></th>
<th style="text-align:left"><em>Drawbacks</em></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>Serializable</strong></td>
<td style="text-align:left">- A standard and basic Java interface <br> - No implementation is required</td>
<td style="text-align:left">- More time and CPU usage <br> - More space occupancy</td>
</tr>
<tr>
<td style="text-align:left"><strong>Externalizable</strong></td>
<td style="text-align:left">- A standard Java interface <br> - More efficient than Serializable when it comes to CPU and memory usage</td>
<td style="text-align:left">- Serialization interface must be implemented</td>
</tr>
<tr>
<td style="text-align:left"><strong>DataSerializable</strong></td>
<td style="text-align:left">- More efficient than Serializable when it comes to CPU and memory usage</td>
<td style="text-align:left">- Specific to Hazelcast</td>
</tr>
<tr>
<td style="text-align:left"><strong>IdentifiedDataSerializable</strong></td>
<td style="text-align:left">- More efficient than Serializable when it comes to CPU and memory usage <br> - Reflection is not used during deserialization</td>
<td style="text-align:left">- Specific to Hazelcast <br> - Serialization interface must be implemented <br> - A Factory and configuration must be implemented</td>
</tr>
<tr>
<td style="text-align:left"><strong>Portable</strong></td>
<td style="text-align:left">- More efficient than Serializable when it comes to CPU and memory usage <br> - Reflection is not used during deserialization <br> - Versioning is supported <br> Partial deserialization is supported during Queries</td>
<td style="text-align:left">- Specific to Hazelcast <br> - Serialization interface must be implemented <br> - A Factory and configuration must be implemented <br> - Class definition is also sent with data but stored only once per class</td>
</tr>
<tr>
<td style="text-align:left"><strong>Custom Serialization</strong></td>
<td style="text-align:left">- Does not require class to implement an interface <br> - Convenient and flexible <br> - Can be based on StreamSerializer ByteArraySerializer</td>
<td style="text-align:left">- Serialization interface must be implemented <br> - Plug in and configuration is required</td>
</tr>
</tbody>
</table>
<p>Let&#39;s dig into the details of the above serialization mechanisms in the following sections.</p>
<h2 id="serializable-externalizable">Serializable &amp; Externalizable</h2>
<p>Often, a class needs to implement <code>java.io.Serializable</code> interface and therefore native Java serialization is the easiest way for serialization. Let&#39;s take a look at the sample code below.</p>
<pre><code class="lang-java">public class Employee implements Serializable { 
  private static final long serialVersionUID = 1L;
  private String surname;

  public Employee( String surname ) { 
    this.surname = surname;
  } 
}
</code></pre>
<p>Here, the fields that are non-static and non-transient are automatically serialized. To eliminate class compatibility issues, it is recommended to add a <code>serialVersionUID</code>, as shown above. Also, when you are using methods that perform byte-content comparisons (e.g. <code>IMap.replace()</code>) and if byte-content of equal objects is different, you may face with unexpected behaviors. So, if the class relies on, for example a hash map, <code>replace</code> method may fail. The reason for this is the hash map, being a serialized data structure with unreliable byte-content.</p>
<p>Hazelcast also supports <code>java.io.Externalizable</code>. This interface offers more control on the way how the fields are serialized or deserialized. Compared to native Java serialization, it also can have a positive effect on the performance. There is no need for a <code>serialVersionUID</code>.</p>
<p>Let&#39;s take a look the sample code below.</p>
<pre><code class="lang-java">public class Employee implements Externalizable { 
  private String surname;
  public Employee(String surname) { 
        this.surname = surname;
  }

  @Override
  public void readExternal( ObjectInput in )
      throws IOException, ClassNotFoundException {
    this.surname = in.readUTF();
  }

  @Override
  public void writeExternal( ObjectOutput out )
      throws IOException {
    out.writeUTF(surname); 
  }
}
</code></pre>
<p>As can be seen, writing and reading of fields are written explicitly. Note that, reading should be performed in the same order as writing.</p>
<h2 id="dataserializable">DataSerializable</h2>
<p>As mentioned in the previous section, Java serialization is an easy mechanism. However, we do not have a control on the way of serialization or deserialization of the fields. Moreover, this mechanism can lead to excessive CPU loads since it keep tracks of objects to handle the cycles and streams class descriptors. These are performance decreasing factors and thus, serialized data may not have an optimal size.</p>
<p>DataSerializable interface of Hazelcast overcomes these issues. Here is an example of a class implementing <code>com.hazelcast.nio.serialization.DataSerializable</code> interface.</p>
<pre><code class="lang-java">public class Address implements DataSerializable {
  private String street;
  private int zipCode;
  private String city;
  private String state;

  public Address() {}

  //getters setters..

  public void writeData( ObjectDataOutput out ) throws IOException {
    out.writeUTF(street);
    out.writeInt(zipCode);
    out.writeUTF(city);
    out.writeUTF(state);
  }

  public void readData( ObjectDataInput in ) throws IOException {
    street = in.readUTF();
    zipCode = in.readInt();
    city = in.readUTF();
    state = in.readUTF();
  }
}
</code></pre>
<p>Let&#39;s take a look at another example which is encapsulating a <code>DataSerializable</code> field.</p>
<pre><code class="lang-java">public class Employee implements DataSerializable {
  private String firstName;
  private String lastName;
  private int age;
  private double salary;
  private Address address; //address itself is DataSerializable

  public Employee() {}

  //getters setters..

  public void writeData( ObjectDataOutput out ) throws IOException {
    out.writeUTF(firstName);
    out.writeUTF(lastName);
    out.writeInt(age);
    out.writeDouble (salary);
    address.writeData (out);
  }

  public void readData( ObjectDataInput in ) throws IOException {
    firstName = in.readUTF();
    lastName = in.readUTF();
    age = in.readInt();
    salary = in.readDouble();
    address = new Address();
    // since Address is DataSerializable let it read its own internal state
    address.readData(in);
  }
}
</code></pre>
<p>As you can see, since <code>address</code> field itself is <code>DataSerializable</code>, it is calling <code>address.writeData(out)</code> when writing and <code>address.readData(in)</code> when reading. Also note that, the order of writing and reading fields should be the same. While Hazelcast serializes a DataSerializable, it writes the <code>className</code> first and when de-serializes it, <code>className</code> is used to instantiate the object using reflection.</p>
<p><img src="images/NoteSmall.jpg" alt="image"> <strong><em>NOTE:</em></strong> <em>Since Hazelcast needs to create an instance during deserialization,<code>DataSerializable</code> class has a no-arg constructor.</em></p>
<p><img src="images/NoteSmall.jpg" alt="image"> <strong><em>NOTE:</em></strong> <em><code>DataSerializable</code> is a good option if serialization is only needed for in-cluster communication.</em></p>
<h3 id="identifieddataserializable">IdentifiedDataSerializable</h3>
<p>For a faster serialization of objects, avoiding reflection and long class names, Hazelcast recommends to implement <code>com.hazelcast.nio.serialization.IdentifiedDataSerializable</code> which is slightly better version of <code>DataSerializable</code>.</p>
<p><code>DataSerializable</code> uses reflection to create a class instance, as mentioned in above section. But, <code>IdentifiedDataSerializable</code> uses a factory for this purpose and it is faster during deserialization which requires new instance creations.</p>
<p><code>IdentifiedDataSerializable</code> extends <code>DataSerializable</code> and introduces two new methods.</p>
<ul>
<li><code>int getId();</code></li>
<li><code>int getFactoryId();</code></li>
</ul>
<p><code>IdentifiedDataSerializable</code> uses <code>getId()</code> instead of class name and uses <code>getFactoryId()</code> to load the class given the Id. To complete the implementation, a <code>com.hazelcast.nio.serialization.DataSerializableFactory</code> should also be implemented and registered into <code>SerializationConfig</code> which can be accessed from <code>Config.getSerializationConfig()</code>. Factory&#39;s responsibility is to return an instance of the right <code>IdentifiedDataSerializable</code> object, given the Id. So far this is the most efficient way of Serialization that Hazelcast supports off the shelf.</p>
<p>Let&#39;s take a look at the below example codes and configuration to see <code>IdentifiedDataSerializable</code> in action.</p>
<pre><code class="lang-java">public class Employee
    implements IdentifiedDataSerializable {

  private String surname;

  public Employee() {}

  public Employee( String surname ) { 
    this.surname = surname;
  }

  @Override
  public void readData( ObjectDataInput in ) 
      throws IOException {
    this.surname = in.readUTF();
  }

  @Override
  public void writeData( ObjectDataOutput out )
      throws IOException { 
    out.writeUTF( surname );
  }

  @Override
  public int getFactoryId() { 
    return EmployeeDataSerializableFactory.FACTORY_ID;
  }

  @Override
  public int getId() { 
    return EmployeeDataSerializableFactory.EMPLOYEE_TYPE;
  }

  @Override
  public String toString() {
    return String.format( &quot;Employee(surname=%s)&quot;, surname ); 
  }
}
</code></pre>
<p>Each of the methods <code>getId</code> and <code>getFactoryId</code> should return a unique positive number within the <code>EmployeeDataSerializableFactory</code>. Now, let&#39;s create an instance of this <code>EmployeeDataSerializableFactory</code>.</p>
<pre><code class="lang-java">public class EmployeeDataSerializableFactory 
    implements DataSerializableFactory{

  public static final int FACTORY_ID = 1;

  public static final int EMPLOYEE_TYPE = 1;

  @Override
  public IdentifiedDataSerializable create(int typeId) {
    if ( typeId == EMPLOYEE_TYPE ) { 
      return new Employee();
    } else {
      return null; 
    }
  }
}
</code></pre>
<p>Only method that should be implemented is <code>create</code>, as seen in the above sample. It is recommended to use <code>switch</code>-<code>`case</code> statement instead of multiple <code>if</code>-<code>else</code> lines if you have a lot of subclasses. Hazelcast throws an exception if null is returned for <code>typeId</code>.</p>
<p>Now, as the last step, you need to register <code>EmployeeDataSerializableFactory</code> declaratively (in the configuration file <code>hazelcast.xml</code>) as shown below. Note that, <code>factory-id</code> has the same value of <code>FACTORY_ID</code> in the above code. This is crucial to enable Hazelcast to find the correct factory.</p>
<pre><code class="lang-xml">&lt;hazelcast&gt; 
  ...
  &lt;serialization&gt;
    &lt;data-serializable-factories&gt;
      &lt;data-serializable-factory
        factory-id=&quot;1&quot;&gt;EmployeeDataSerializableFactory
      &lt;/data-serializable-factory&gt;
    &lt;/data-serializable-factories&gt;
  &lt;/serialization&gt;
  ...
&lt;/hazelcast&gt;
</code></pre>
<h2 id="portable">Portable</h2>
<p>As an alternative to the existing serialization methods, Hazelcast offers a language/platform independent Portable serialization that have the following advantages:</p>
<ul>
<li>Support multi-version of the same object type.</li>
<li>Fetching individual fields without having to rely on reflection.</li>
<li>Querying and indexing support without de-serialization and/or reflection.</li>
</ul>
<p>In order to support these features, a serialized Portable object is offered containing meta information like the version and the concrete location of the each field in the binary data. This way Hazelcast is able to navigate in the <code>byte[]</code> and de-serialize only the required field without actually de-serializing the whole object which improves the Query performance.</p>
<p>With multi-version support, you can have two nodes where each of them having different versions of the same object and Hazelcast will store both meta information and use the correct one to serialize and de-serialize Portable objects depending on the node. This is very helpful when you are doing a rolling upgrade without shutting down the cluster.</p>
<p>Also note that, Portable serialization is totally language independent and is used as the binary protocol between Hazelcast server and clients.</p>
<p>A sample Portable implementation of a Foo class would look like the following.</p>
<pre><code class="lang-java">public class Foo implements Portable{
  final static int ID = 5;

  private String foo;

  public String getFoo() {
    return foo;
  }

  public void setFoo( String foo ) {
    this.foo = foo;
  }

  @Override
  public int getFactoryId() {
    return 1;
  }

  @Override
  public int getClassId() {
    return ID;
  }

  @Override
  public void writePortable( PortableWriter writer ) throws IOException {
    writer.writeUTF( &quot;foo&quot;, foo );
  }

  @Override
  public void readPortable( PortableReader reader ) throws IOException {
    foo = reader.readUTF( &quot;foo&quot; );
  }
}
</code></pre>
<p>Similar to <code>IdentifiedDataSerializable</code>, a Portable Class must provide <code>classId</code> and<code>factoryId</code>. The Factory object will be used to create the Portable object given the <code>classId</code>.</p>
<p>A sample <code>Factory</code> could be implemented as following:</p>
<pre><code class="lang-java">public class MyPortableFactory implements PortableFactory {

  @Override
  public Portable create( int classId ) {
    if ( Foo.ID == classId )
      return new Foo();
    else
      return null;
  }
}
</code></pre>
<p>The last step is to register the <code>Factory</code> to the <code>SerializationConfig</code>. Below are the programmatic and declarative configurations for this step in order.</p>
<pre><code class="lang-java">Config config = new Config();
config.getSerializationConfig().addPortableFactory( 1, new MyPortableFactory() );
</code></pre>
<pre><code class="lang-xml">&lt;hazelcast&gt;
  &lt;serialization&gt;
    &lt;portable-version&gt;0&lt;/portable-version&gt;
    &lt;portable-factories&gt;
      &lt;portable-factory factory-id=&quot;1&quot;&gt;
          com.hazelcast.nio.serialization.MyPortableFactory
      &lt;/portable-factory&gt;
    &lt;/portable-factories&gt;
  &lt;/serialization&gt;
&lt;/hazelcast&gt;
</code></pre>
<p>Note that the <code>id</code> that is passed to the <code>SerializationConfig</code> is same as the <code>factoryId</code> that <code>Foo</code> class returns.</p>
<h3 id="versions">Versions</h3>
<p>More than one versions of the same class may need to be serialized and deserialized.  For example, a client may have an older version of a class, and the node to which it is connected can have a newer version of the same class. </p>
<p>Portable serialization supports versioning. Version can be provided declaratively in the configuration file <code>hazelcast.xml</code> using the <code>portable-version</code> tag, as shown below.</p>
<pre><code class="lang-xml">&lt;serialization&gt;
  &lt;portable-version&gt;1&lt;/portable-version&gt;
  &lt;portable-factories&gt;
    &lt;portable-factory factory-id=&quot;1&quot;&gt;
        PortableFactoryImpl
    &lt;/portable-factory&gt;
  &lt;/portable-factories&gt;
&lt;/serialization&gt;
</code></pre>
<p>Things to consider related to versioning is given below:</p>
<ul>
<li>It is important to change the version whenever an update is performed in the serialized fields of a class (e.g. increment the version).</li>
<li>Assume that, for example, a client performs a Portable deserialization on a field. If that Portable is updated by removing that field on the cluster side, this may lead to a problem.</li>
<li>Portable serialization does not use reflection and hence, fields in the class and in the serialized content are not automatically mapped. So, field renaming is a simpler process. Also, since the class ID is stored, renaming the Portable does not lead to problems.</li>
<li>Types of fields need to be updated carefully. Yet, Hazelcast performs basic type upgradings (e.g. <code>int</code> to <code>float</code>).</li>
</ul>
<h3 id="null-portable-serialization">Null Portable Serialization</h3>
<p>One needs to be careful when serializing null portables. Hazelcast lazily creates a class definition of portable internally
when the user first serializes. This class definition is stored and used later for deserializing that portable class. When
the user tries to serialize a null portable and if there is no class definition at the moment, Hazelcast throws an
exception saying that <code>com.hazelcast.nio.serialization.HazelcastSerializationException: Cannot write null portable
without explicitly registering class definition!</code>. </p>
<p>There are two solutions to get rid of this exception. First way, the user can put
a non-null portable class of the same type before any other operation. Second way, a class definition can be registered manually
in serialization config as shown below.</p>
<pre><code class="lang-java">Config config = new Config();
final ClassDefinition classDefinition = new ClassDefinitionBuilder(Foo.factoryId, Foo.getClassId)
                       .addUTFField(&quot;foo&quot;).build();
config.getSerializationConfig().addClassDefinition(classDefinition);
Hazelcast.newHazelcastInstance(config);
</code></pre>
<h3 id="distributedobject-serialization">DistributedObject Serialization</h3>
<p>Putting a DistributedObject (e.g. Hazelcast Semaphore, Queue, etc.) in a machine and getting it from another one is not a straightforward operation. For this case, passing the ID and type of the DistributedObject can be a solution. For deserialization, try to get the object from HazelcastInstance. For instance, if your distributed object is an instance of IQueue, you can either use <code>HazelcastInstance.getQueue(id)</code> or <code>Hazelcast.getDistributedObject</code>.</p>
<p>Also, <code>HazelcastInstanceAware</code> interface can be used in the case of a deserialization of a Portable DistributedObject and if it gets an ID to be looked up. HazelcastInstance is set after deserialization and hence, you first need to store the ID and then retrieve the DistributedObject using <code>setHazelcastInstance</code> method. </p>
<h2 id="custom-serialization">Custom Serialization</h2>
<p>Hazelcast lets you plug a custom serializer to be used for serialization of objects. <code>StreamSerializer</code> and <code>ByteArraySerializer</code> interfaces can be used for this purpose. Let&#39;s see the details in below subsections.</p>
<h3 id="streamserializer">StreamSerializer</h3>
<p>You can use a stream in order to serialize and deserialize data by means of <code>StreamSerializer</code>. It is a good option for your own implementations and it can also be adapted to external serialization libraries like Kryo, JSON and protocol buffers.</p>
<p>First, let&#39;s create a simple object.</p>
<pre><code class="lang-java">public class Employee {
  private String surname;

  public Employee( String surname ) {
    this.surname = surname;
  }
}
</code></pre>
<p>Now, let&#39;s implement StreamSerializer for <code>Employee</code> class.</p>
<pre><code class="lang-java">public class EmployeeStreamSerializer
    implements StreamSerializer&lt;Employee&gt; {

  @Override
  public int getTypeId () {
    return 1; 
  }

  @Override
  public void write( ObjectDataOutput out, Employee employee )
      throws IOException { 
    out.writeUTF(employee.getSurname());
  }

  @Override
  public Employee read( ObjectDataInput in ) 
      throws IOException { 
    String surname = in.readUTF();
    return new Employee(surname);
  }

  @Override
  public void destroy () { 
  }
}
</code></pre>
<p>Of course, in practice, classes may have many fields. Just make sure the fields are read in the same order as they are written. Another consideration should be the type ID. It must be unique and greater than or equal to <strong>1</strong>. Uniqueness of it enables Hazelcast to determine which serializer will be used during deserialization. </p>
<p>And now, as the last step, let&#39;s register the <code>EmployeeStreamSerializer</code> in the configuration file <code>hazelcast.xml</code>, as shown below.</p>
<pre><code class="lang-xml">&lt;serialization&gt;
  &lt;serializers&gt;
    &lt;serializer type-class=&quot;Employee&quot; class-name=&quot;EmployeeStreamSerializer&quot; /&gt;
  &lt;/serializers&gt;
&lt;/serialization&gt;
</code></pre>
<p><img src="images/NoteSmall.jpg" alt="image"> <strong><em>NOTE:</em></strong> <em><code>StreamSerializer</code> cannot be created for well-known types (e.g. Long, String) and primitive arrays. Hazelcast already registers these types.</em></p>
<p><br></br></p>
<p>Let&#39;s take a look at another example implementing StreamSerializer.</p>
<pre><code class="lang-java">public class Foo {
  private String foo;

  public String getFoo() {
    return foo;
  }

  public void setFoo( String foo ) {
    this.foo = foo;
  }
}
</code></pre>
<p>Assume that our custom serialization will serialize
Foo into XML. First we need to implement a
<code>com.hazelcast.nio.serialization.StreamSerializer</code>. A very simple one that uses XMLEncoder and XMLDecoder, would look like the following:</p>
<pre><code class="lang-java">public static class FooXmlSerializer implements StreamSerializer&lt;Foo&gt; {

  @Override
  public int getTypeId() {
    return 10;
  }

  @Override
  public void write( ObjectDataOutput out, Foo object ) throws IOException {
    ByteArrayOutputStream bos = new ByteArrayOutputStream();
    XMLEncoder encoder = new XMLEncoder( bos );
    encoder.writeObject( object );
    encoder.close();
    out.write( bos.toByteArray() );
  }

  @Override
  public Foo read( ObjectDataInput in ) throws IOException {
    InputStream inputStream = (InputStream) in;
    XMLDecoder decoder = new XMLDecoder( inputStream );
    return (Foo) decoder.readObject();
  }

  @Override
  public void destroy() {
  }
}
</code></pre>
<p>Note that <code>typeId</code> must be unique as Hazelcast will use it to lookup the StreamSerializer while it de-serializes the object. Now, the last required step is to register the StreamSerializer to the Configuration. Below are the programmatic and declarative configurations for this step in order.</p>
<pre><code class="lang-java">SerializerConfig sc = new SerializerConfig()
    .setImplementation(new FooXmlSerializer())
    .setTypeClass(Foo.class);
Config config = new Config();
config.getSerializationConfig().addSerializerConfig(sc);
</code></pre>
<pre><code class="lang-xml">&lt;hazelcast&gt;
  &lt;serialization&gt;
    &lt;serializers&gt;
      &lt;serializer type-class=&quot;com.www.Foo&quot;&gt;com.www.FooXmlSerializer&lt;/serializer&gt;
    &lt;/serializers&gt;
  &lt;/serialization&gt;
&lt;/hazelcast&gt;
</code></pre>
<p>From now on, Hazelcast will use <code>FooXmlSerializer</code>
to serialize Foo objects. This way one can write an adapter (StreamSerializer) for any Serialization framework and plug it into Hazelcast.</p>
<p><br> </br></p>
<h3 id="bytearrayserializer">ByteArraySerializer</h3>
<p><code>ByteArraySerializer</code> exposes the raw ByteArray used internally by Hazelcast. It is a good option if the serialization library you are using deals with ByteArrays instead of streams.</p>
<p>Let&#39;s implement ByteArraySerializer for the <code>Employee</code> class mentioned in previous sections.</p>
<pre><code class="lang-java">public class EmployeeByteArraySerializer
    implements ByteArraySerializer&lt;Employee&gt; {

  @Override
  public void destroy () { 
  }

  @Override
  public int getTypeId () {
    return 1; 
  }

  @Override
  public byte[] write( Employee object )
      throws IOException { 
    return object.getName().getBytes();
  }

  @Override
  public Employee read( byte[] buffer ) 
      throws IOException { 
    String surname = new String( buffer );
    return new Employee( surname );
  }
}
</code></pre>
<p>And, as usual, let&#39;s register the <code>EmployeeByteArraySerializer</code> in the configuration file <code>hazelcast.xml</code>, as shown below.</p>
<pre><code class="lang-xml">&lt;serialization&gt;
  &lt;serializers&gt;
    &lt;serializer type-class=&quot;Employee&quot;&gt;EmployeeByteArraySerializer&lt;/serializer&gt;
  &lt;/serializers&gt;
&lt;/serialization&gt;
</code></pre>
<p><br></br></p>
<h2 id="hazelcastinstanceaware-interface">HazelcastInstanceAware Interface</h2>
<p>You can implement <code>HazelcastInstanceAware</code> interface to access distributed objects for some cases where an object is deserialized and needs access to HazelcastInstance.</p>
<p>Let&#39;s implement it for the <code>Employee</code> class mentioned in previous sections.</p>
<pre><code class="lang-java">public class Employee
    implements Serializable, HazelcastInstanceAware { 

  private static final long serialVersionUID = 1L;
  private String surname;
  private transient HazelcastInstance hazelcastInstance;

  public Person( String surname ) { 
    this.surname = surname;
  }

  @Override
  public void setHazelcastInstance( HazelcastInstance hazelcastInstance ) {
    this.hazelcastInstance = hazelcastInstance;
    System.out.println( &quot;HazelcastInstance set&quot; ); 
  }

  @Override
  public String toString() {
    return String.format( &quot;Person(surname=%s)&quot;, surname ); 
  }
}
</code></pre>
<p>After deserialization, object is checked whether it implements <code>HazelcastInstanceAware</code> and the method <code>setHazelcastInstance</code> is called. Notice the <code>hazelcastInstance</code> being <code>transient</code>. It is because this field should not be serialized.</p>
<p>It may be a good practice to inject a HazelcastInstance into a domain object (e.g. <code>Employee</code> in the above sample) when used together with <code>Runnable</code>/<code>Callable</code> implementations. These runnables/callables are executed by IExecutorService which sends them to another machine. And after a task is deserialized, run/call method implementations need to access HazelcastInstance.</p>
<p>We recommend you only to set the HazelcastInstance field while using <code>setHazelcastInstance</code> method and not to execute operations on the HazelcastInstance. Because, when HazelcastInstance is injected for a <code>HazelcastInstanceAware</code> implementation, it may not be up and running at the injection time.</p>
<p><br></br></p>
<h1 id="management">Management</h1>
<h2 id="statistics-api-per-node">Statistics API per Node</h2>
<p>You can gather various statistics from your distributed data structures via Statistics API.
Since the data structures are distributed in the cluster, the Statistics API provides
statistics for the local portion (1/Number of Nodes) of data on each node. </p>
<h3 id="map-statistics">Map Statistics</h3>
<p>The <code>IMap</code> interface has a <code>getLocalMapStats()</code> method which returns a
<code>LocalMapStats</code> object that holds local map statistics.</p>
<pre><code class="lang-java">HazelcastInstance hazelcastInstance = Hazelcast.newHazelcastInstance();
IMap&lt;String, Customer&gt; customers = hazelcastInstance.getMap( &quot;customers&quot; );
LocalMapStats mapStatistics = customers.getLocalMapStats();
System.out.println( &quot;number of entries owned on this node = &quot;
    + mapStatistics.getOwnedEntryCount() );
</code></pre>
<p>Below is the list of metrics that can be accessed via <code>LocalMapStats</code> object.</p>
<pre><code class="lang-java">/**
 * Returns the number of entries owned by this member.
 */
long getOwnedEntryCount();

/**
 * Returns the number of backup entries hold by this member.
 */
long getBackupEntryCount();

/**
 * Returns the number of backups per entry.
 */
int getBackupCount();

/**
 * Returns memory cost (number of bytes) of owned entries in this member.
 */
long getOwnedEntryMemoryCost();

/**
 * Returns memory cost (number of bytes) of backup entries in this member.
 */
long getBackupEntryMemoryCost();

/**
 * Returns the creation time of this map on this member.
 */
long getCreationTime();

/**
 * Returns the last access (read) time of the locally owned entries.
 */
long getLastAccessTime();

/**
 * Returns the last update time of the locally owned entries.
 */
long getLastUpdateTime();

/**
 * Returns the number of hits (reads) of the locally owned entries.
 */
long getHits();

/**
 * Returns the number of currently locked locally owned keys.
 */
long getLockedEntryCount();

/**
 * Returns the number of entries that the member owns and are dirty (updated
 * but not persisted yet).
 * dirty entry count is meaningful when there is a persistence defined.
 */
long getDirtyEntryCount();

/**
 * Returns the number of put operations
 */
long getPutOperationCount();

/**
 * Returns the number of get operations
 */
long getGetOperationCount();

/**
 * Returns the number of Remove operations
 */
long getRemoveOperationCount();

/**
 * Returns the total latency of put operations. To get the average latency,
 * divide to number of puts
 */
long getTotalPutLatency();

/**
 * Returns the total latency of get operations. To get the average latency,
 * divide to number of gets
 */
long getTotalGetLatency();

/**
 * Returns the total latency of remove operations. To get the average latency,
 * divide to number of gets
 */
long getTotalRemoveLatency();

/**
 * Returns the maximum latency of put operations. To get the average latency,
 * divide to number of puts
 */
long getMaxPutLatency();

/**
 * Returns the maximum latency of get operations. To get the average latency,
 * divide to number of gets
 */
long getMaxGetLatency();

/**
 * Returns the maximum latency of remove operations. To get the average latency,
 * divide to number of gets
 */
long getMaxRemoveLatency();

/**
 * Returns the number of Events Received
 */
long getEventOperationCount();

/**
 * Returns the total number of Other Operations
 */
long getOtherOperationCount();

/**
 * Returns the total number of total operations
 */
long total();

/**
 * Cost of map &amp; near cache  &amp; backup in bytes
 * todo in object mode object size is zero.
 */
long getHeapCost();

/**
 * Returns statistics related to the Near Cache.
 */
NearCacheStats getNearCacheStats();
</code></pre>
<h4 id="near-cache-statistics">Near Cache Statistics</h4>
<p>Near Cache statistics can be accessed from <code>LocalMapStats</code> via
<code>getNearCacheStats()</code> method which will return a <code>NearCacheStats</code> object.</p>
<pre><code class="lang-java">HazelcastInstance node = Hazelcast.newHazelcastInstance();
IMap&lt;String, Customer&gt; customers = node.getMap( &quot;customers&quot; );
LocalMapStats mapStatistics = customers.getLocalMapStats();
NearCacheStats nearCacheStatistics = mapStatistics.getNearCacheStats();
System.out.println( &quot;near cache hit/miss ratio= &quot;
    + nearCacheStatistics.getRatio() );
</code></pre>
<p>Below is the list of metrics that can be accessed via <code>NearCacheStats</code> object.
This behavior applies to both client and node near caches.</p>
<pre><code class="lang-java">/**
 * Returns the creation time of this NearCache on this member
 */
long getCreationTime();

/**
 * Returns the number of entries owned by this member.
 */
long getOwnedEntryCount();

/**
 * Returns memory cost (number of bytes) of entries in this cache.
 */
long getOwnedEntryMemoryCost();

/**
 * Returns the number of hits (reads) of the locally owned entries.
 */
long getHits();

/**
 * Returns the number of misses  of the locally owned entries.
 */
long getMisses();

/**
 * Returns the hit/miss ratio  of the locally owned entries.
 */
double getRatio();
</code></pre>
<h3 id="multimap-statistics">Multimap Statistics</h3>
<p>The <code>MultiMap</code> interface has a <code>getLocalMultiMapStats()</code> method which returns a
<code>LocalMultiMapStats</code> object that holds local MultiMap statistics.</p>
<pre><code class="lang-java">HazelcastInstance node = Hazelcast.newHazelcastInstance();
MultiMap&lt;String, Customer&gt; customers = node.getMultiMap( &quot;customers&quot; );
LocalMultiMapStats multiMapStatistics = customers.getLocalMultiMapStats();
System.out.println( &quot;last update time =  &quot;
    + multiMapStatistics.getLastUpdateTime() );
</code></pre>
<p>Below is the list of metrics that can be accessed via <code>LocalMultiMapStats</code> object.</p>
<pre><code class="lang-java">/**
 * Returns the number of entries owned by this member.
 */
long getOwnedEntryCount();

/**
 * Returns the number of backup entries hold by this member.
 */
long getBackupEntryCount();

/**
 * Returns the number of backups per entry.
 */
int getBackupCount();

/**
 * Returns memory cost (number of bytes) of owned entries in this member.
 */
long getOwnedEntryMemoryCost();

/**
 * Returns memory cost (number of bytes) of backup entries in this member.
 */
long getBackupEntryMemoryCost();

/**
 * Returns the creation time of this map on this member.
 */
long getCreationTime();

/**
 * Returns the last access (read) time of the locally owned entries.
 */
long getLastAccessTime();

/**
 * Returns the last update time of the locally owned entries.
 */
long getLastUpdateTime();

/**
 * Returns the number of hits (reads) of the locally owned entries.
 */
long getHits();

/**
 * Returns the number of currently locked locally owned keys.
 */
long getLockedEntryCount();

/**
 * Returns the number of entries that the member owns and are dirty (updated
 * but not persisted yet).
 * dirty entry count is meaningful when there is a persistence defined.
 */
long getDirtyEntryCount();

/**
 * Returns the number of put operations
 */
long getPutOperationCount();

/**
 * Returns the number of get operations
 */
long getGetOperationCount();

/**
 * Returns the number of Remove operations
 */
long getRemoveOperationCount();

/**
 * Returns the total latency of put operations. To get the average latency,
 * divide to number of puts
 */
long getTotalPutLatency();

/**
 * Returns the total latency of get operations. To get the average latency,
 * divide to number of gets
 */
long getTotalGetLatency();

/**
 * Returns the total latency of remove operations. To get the average latency,
 * divide to number of gets
 */
long getTotalRemoveLatency();

/**
 * Returns the maximum latency of put operations. To get the average latency,
 * divide to number of puts
 */
long getMaxPutLatency();

/**
 * Returns the maximum latency of get operations. To get the average latency,
 * divide to number of gets
 */
long getMaxGetLatency();

/**
 * Returns the maximum latency of remove operations. To get the average latency,
 * divide to number of gets
 */
long getMaxRemoveLatency();

/**
 * Returns the number of Events Received
 */
long getEventOperationCount();

/**
 * Returns the total number of Other Operations
 */
long getOtherOperationCount();

/**
 * Returns the total number of total operations
 */
long total();

/**
 * Cost of map &amp; near cache  &amp; backup in bytes
 * todo in object mode object size is zero.
 */
long getHeapCost();
</code></pre>
<h3 id="queue-statistics">Queue Statistics</h3>
<p>The <code>IQueue</code> interface has a <code>getLocalQueueStats()</code> method which returns a
<code>LocalQueueStats</code> object that holds local queue statistics.</p>
<pre><code class="lang-java">HazelcastInstance node = Hazelcast.newHazelcastInstance();
IQueue&lt;Order&gt; orders = node.getQueue( &quot;orders&quot; );
LocalQueueStats queueStatistics = orders.getLocalQueueStats();
System.out.println( &quot;average age of items = &quot; 
    + queueStatistics.getAvgAge() );
</code></pre>
<p>Below is the list of metrics that can be accessed via <code>LocalQueueStats</code> object.</p>
<pre><code class="lang-java">/**
 * Returns the number of owned items in this member.
 */
long getOwnedItemCount();

/**
 * Returns the number of backup items in this member.
 */
long getBackupItemCount();

/**
 * Returns the min age of the items in this member.
 */
long getMinAge();

/**
 * Returns the max age of the items in this member.
 */
long getMaxAge();

/**
 * Returns the average age of the items in this member.
 */
long getAvgAge();

/**
 * Returns the number of offer/put/add operations.
 * Offers returning false will be included.
 * #getRejectedOfferOperationCount can be used
 * to get the rejected offers.
 */
long getOfferOperationCount();

/**
 * Returns the number of rejected offers. Offer
 * can be rejected because of max-size limit
 * on the queue.
 */
long getRejectedOfferOperationCount();

/**
 * Returns the number of poll/take/remove operations.
 * Polls returning null (empty) will be included.
 * #getEmptyPollOperationCount can be used to get the
 * number of polls returned null.
 */
long getPollOperationCount();

/**
 * Returns number of null returning poll operations.
 * Poll operation might return null, if the queue is empty.
 */
long getEmptyPollOperationCount();

/**
 * Returns number of other operations
 */
long getOtherOperationsCount();

/**
 * Returns number of event operations
 */
long getEventOperationCount();
</code></pre>
<h3 id="topic-statistics">Topic Statistics</h3>
<p>The <code>ITopic</code> interface has a <code>getLocalTopicStats()</code> method which returns a
<code>LocalTopicStats</code> object that holds local topic statistics.</p>
<pre><code class="lang-java">HazelcastInstance node = Hazelcast.newHazelcastInstance();
ITopic&lt;Object&gt; news = node.getTopic( &quot;news&quot; );
LocalTopicStats topicStatistics = news.getLocalTopicStats();
System.out.println( &quot;number of publish operations = &quot; 
    + topicStatistics.getPublishOperationCount() );
</code></pre>
<p>Below is the list of metrics that can be accessed via <code>LocalTopicStats</code> object.</p>
<pre><code class="lang-java">/**
 * Returns the creation time of this topic on this member
 */
long getCreationTime();

/**
 * Returns the total number of published messages of this topic on this member
 */
long getPublishOperationCount();

/**
 * Returns the total number of received messages of this topic on this member
 */
long getReceiveOperationCount();
</code></pre>
<h3 id="executor-statistics">Executor Statistics</h3>
<p>The <code>IExecutorService</code> interface has a <code>getLocalExecutorStats()</code> method which returns a
<code>LocalExecutorStats</code> object that holds local executor statistics.</p>
<pre><code class="lang-java">HazelcastInstance node = Hazelcast.newHazelcastInstance();
IExecutorService orderProcessor = node.getExecutorService( &quot;orderProcessor&quot; );
LocalExecutorStats executorStatistics = orderProcessor.getLocalExecutorStats();
System.out.println( &quot;completed task count = &quot; 
    + executorStatistics.getCompletedTaskCount() );
</code></pre>
<p>Below is the list of metrics that can be accessed via <code>LocalExecutorStats</code> object.</p>
<pre><code class="lang-java">/**
 * Returns the number of pending operations of the executor service
 */
long getPendingTaskCount();

/**
 * Returns the number of started operations of the executor service
 */
long getStartedTaskCount();

/**
 * Returns the number of completed operations of the executor service
 */
long getCompletedTaskCount();

/**
 * Returns the number of cancelled operations of the executor service
 */
long getCancelledTaskCount();

/**
 * Returns the total start latency of operations started
 */
long getTotalStartLatency();

/**
 * Returns the total execution time of operations finished
 */
long getTotalExecutionLatency();
</code></pre>
<h2 id="jmx-api-per-node">JMX API per Node</h2>
<p>Hazelcast members expose various management beans which includes statistics about distributed data structures and states of Hazelcast node internals.</p>
<p>The metrics are local to the nodes, i.e. they do not reflect cluster wide values.</p>
<p>You can find the JMX API definition below with descriptions and the API methods in parenthesis.</p>
<p><strong>Atomic Long (<code>IAtomicLong</code>)</strong></p>
<ul>
<li>Name ( <code>name</code> )</li>
<li>Current Value ( <code>currentValue</code> )</li>
<li>Set Value ( <code>set(v)</code> )</li>
<li>Add value and Get ( <code>addAndGet(v)</code> )</li>
<li>Compare and Set ( <code>compareAndSet(e,v)</code> )</li>
<li>Decrement and Get ( <code>decrementAndGet()</code> )</li>
<li>Get and Add ( <code>getAndAdd(v)</code> )</li>
<li>Get and Increment ( <code>getAndIncrement()</code> )</li>
<li>Get and Set ( <code>getAndSet(v)</code> )</li>
<li>Increment and Get ( <code>incrementAndGet()</code> )</li>
<li>Partition key ( <code>partitionKey</code> )</li>
</ul>
<p><strong>Atomic Reference ( <code>IAtomicReference</code> )</strong></p>
<ul>
<li>Name ( <code>name</code> )</li>
<li>Partition key  ( <code>partitionKey</code>)</li>
</ul>
<p><strong>Countdown Latch ( <code>ICountDownLatch</code> )</strong></p>
<ul>
<li>Name ( <code>name</code> )</li>
<li>Current count ( <code>count</code>)</li>
<li>Countdown ( <code>countDown()</code> )</li>
<li>Partition key  ( <code>partitionKey</code>)</li>
</ul>
<p><strong>Executor Service ( <code>IExecutorService</code> )</strong></p>
<ul>
<li>Local pending operation count ( <code>localPendingTaskCount</code> )</li>
<li>Local started operation count ( <code>localStartedTaskCount</code> )</li>
<li>Local completed operation count ( <code>localCompletedTaskCount</code> )</li>
<li>Local cancelled operation count ( <code>localCancelledTaskCount</code> )</li>
<li>Local total start latency ( <code>localTotalStartLatency</code> )</li>
<li>Local total execution latency ( <code>localTotalExecutionLatency</code> )</li>
</ul>
<p><strong>List ( <code>IList</code> )</strong></p>
<ul>
<li>Name ( <code>name</code> )</li>
<li>Clear list ( <code>clear</code> )</li>
<li>Total added item count ( <code>totalAddedItemCount</code> )</li>
<li>Total removed item count ( <code>totalRemovedItemCount</code> )</li>
</ul>
<p><strong>Lock ( <code>ILock</code> )</strong></p>
<ul>
<li>Name ( <code>name</code> )</li>
<li>Lock Object ( <code>lockObject</code> )</li>
<li>Partition key ( <code>partitionKey</code> )</li>
</ul>
<p><strong>Map ( <code>IMap</code> )</strong></p>
<ul>
<li>Name ( <code>name</code> )</li>
<li>Size ( <code>size</code> )</li>
<li>Config ( <code>config</code> )</li>
<li>Owned entry count ( <code>localOwnedEntryCount</code> )</li>
<li>Owned entry memory cost ( <code>localOwnedEntryMemoryCost</code> )</li>
<li>Backup entry count ( <code>localBackupEntryCount</code> )</li>
<li>Backup entry cost ( <code>localBackupEntryMemoryCost</code> )</li>
<li>Backup count ( <code>localBackupCount</code> )</li>
<li>Creation time ( <code>localCreationTime</code> )</li>
<li>Last access time ( <code>localLastAccessTime</code> )</li>
<li>Last update time ( <code>localLastUpdateTime</code> )</li>
<li>Hits ( <code>localHits</code> )</li>
<li>Locked entry count ( <code>localLockedEntryCount</code> )</li>
<li>Dirty entry count ( <code>localDirtyEntryCount</code> )</li>
<li>Put operation count ( <code>localPutOperationCount</code> )</li>
<li>Get operation count ( <code>localGetOperationCount</code> )</li>
<li>Remove operation count ( <code>localRemoveOperationCount</code> )</li>
<li>Total put latency ( <code>localTotalPutLatency</code> )</li>
<li>Total get latency ( <code>localTotalGetLatency</code> )</li>
<li>Total remove latency ( <code>localTotalRemoveLatency</code> )</li>
<li>Max put latency ( <code>localMaxPutLatency</code> )</li>
<li>Max get latency ( <code>localMaxGetLatency</code> )</li>
<li>Max remove latency ( <code>localMaxRemoveLatency</code> )</li>
<li>Event count ( <code>localEventOperationCount</code> )</li>
<li>Other (keySet,entrySet etc..) operation count ( <code>localOtherOperationCount</code> )</li>
<li>Total operation count ( <code>localTotal</code> )</li>
<li>Heap Cost ( <code>localHeapCost</code> )</li>
<li>Total added entry count ( <code>totalAddedEntryCount</code> )</li>
<li>Total removed entry count ( <code>totalRemovedEntryCount</code> )</li>
<li>Total updated entry count ( <code>totalUpdatedEntryCount</code> )</li>
<li>Total evicted entry count ( <code>totalEvictedEntryCount</code> )</li>
<li>Clear ( <code>clear()</code> )</li>
<li>Values ( <code>values(p)</code>)</li>
<li>Entry Set ( <code>entrySet(p)</code> )</li>
</ul>
<p><strong>MultiMap ( <code>MultiMap</code> )</strong></p>
<ul>
<li>Name ( <code>name</code> )</li>
<li>Size ( <code>size</code> )</li>
<li>Owned entry count ( <code>localOwnedEntryCount</code> )</li>
<li>Owned entry memory cost ( <code>localOwnedEntryMemoryCost</code> )</li>
<li>Backup entry count ( <code>localBackupEntryCount</code> )</li>
<li>Backup entry cost ( <code>localBackupEntryMemoryCost</code> )</li>
<li>Backup count ( <code>localBackupCount</code> )</li>
<li>Creation time ( <code>localCreationTime</code> )</li>
<li>Last access time ( <code>localLastAccessTime</code> )</li>
<li>Last update time ( <code>localLastUpdateTime</code> )</li>
<li>Hits ( <code>localHits</code> )</li>
<li>Locked entry count ( <code>localLockedEntryCount</code> )</li>
<li>Put operation count ( <code>localPutOperationCount</code> )</li>
<li>Get operation count ( <code>localGetOperationCount</code> )</li>
<li>Remove operation count ( <code>localRemoveOperationCount</code> )</li>
<li>Total put latency ( <code>localTotalPutLatency</code> )</li>
<li>Total get latency ( <code>localTotalGetLatency</code> )</li>
<li>Total remove latency ( <code>localTotalRemoveLatency</code> )</li>
<li>Max put latency ( <code>localMaxPutLatency</code> )</li>
<li>Max get latency ( <code>localMaxGetLatency</code> )</li>
<li>Max remove latency ( <code>localMaxRemoveLatency</code> )</li>
<li>Event count ( <code>localEventOperationCount</code> )</li>
<li>Other (keySet,entrySet etc..) operation count ( <code>localOtherOperationCount</code> )</li>
<li>Total operation count ( <code>localTotal</code> )</li>
<li>Clear ( <code>clear()</code> )</li>
</ul>
<p><strong>Replicated Map ( <code>ReplicatedMap</code> )</strong></p>
<ul>
<li>Name ( <code>name</code> )</li>
<li>Size ( <code>size</code> )</li>
<li>Config ( <code>config</code> )</li>
<li>Owned entry count ( <code>localOwnedEntryCount</code> )</li>
<li>Creation time ( <code>localCreationTime</code> )</li>
<li>Last access time ( <code>localLastAccessTime</code> )</li>
<li>Last update time ( <code>localLastUpdateTime</code> )</li>
<li>Hits ( <code>localHits</code> )</li>
<li>Put operation count ( <code>localPutOperationCount</code> )</li>
<li>Get operation count ( <code>localGetOperationCount</code> )</li>
<li>Remove operation count ( <code>localRemoveOperationCount</code> )</li>
<li>Total put latency ( <code>localTotalPutLatency</code> )</li>
<li>Total get latency ( <code>localTotalGetLatency</code> )</li>
<li>Total remove latency ( <code>localTotalRemoveLatency</code> )</li>
<li>Max put latency ( <code>localMaxPutLatency</code> )</li>
<li>Max get latency ( <code>localMaxGetLatency</code> )</li>
<li>Max remove latency ( <code>localMaxRemoveLatency</code> )</li>
<li>Event count ( <code>localEventOperationCount</code> )</li>
<li>Replication event count ( <code>localReplicationEventCount</code> )</li>
<li>Other (keySet,entrySet etc..) operation count ( <code>localOtherOperationCount</code> )</li>
<li>Total operation count ( <code>localTotal</code> )</li>
<li>Total added entry count ( <code>totalAddedEntryCount</code> )</li>
<li>Total removed entry count ( <code>totalRemovedEntryCount</code> )</li>
<li>Total updated entry count ( <code>totalUpdatedEntryCount</code> )</li>
<li>Clear ( <code>clear()</code> )</li>
<li>Values ( <code>values()</code>)</li>
<li>Entry Set ( <code>entrySet()</code> )</li>
</ul>
<p><strong>Queue ( <code>IQueue</code> )</strong></p>
<ul>
<li>Name ( <code>name</code> )</li>
<li>Config ( <code>QueueConfig</code> )</li>
<li>Partition key ( <code>partitionKey</code> )</li>
<li>Owned item count ( <code>localOwnedItemCount</code> )</li>
<li>Backup item count ( <code>localBackupItemCount</code> )</li>
<li>Minimum age ( <code>localMinAge</code> )</li>
<li>Maximum age ( <code>localMaxAge</code> )</li>
<li>Average age ( <code>localAveAge</code> )</li>
<li>Offer operation count ( <code>localOfferOperationCount</code> )</li>
<li>Rejected offer operation count ( <code>localRejectedOfferOperationCount</code> )</li>
<li>Poll operation count ( <code>localPollOperationCount</code> )</li>
<li>Empty poll operation count ( <code>localEmptyPollOperationCount</code> )</li>
<li>Other operation count ( <code>localOtherOperationsCount</code> )</li>
<li>Event operation count ( <code>localEventOperationCount</code> )</li>
<li>Total added item count ( <code>totalAddedItemCount</code> )</li>
<li>Total removed item count ( <code>totalRemovedItemCount</code> )</li>
<li>Clear ( <code>clear()</code> )</li>
</ul>
<p><strong>Semaphore ( <code>ISemaphore</code> )</strong></p>
<ul>
<li>Name ( <code>name</code> )</li>
<li>Available permits ( <code>available</code> )</li>
<li>Partition key ( <code>partitionKey</code> )</li>
<li>Drain ( <code>drain()</code>)</li>
<li>Shrink available permits by given number ( <code>reduce(v)</code> )</li>
<li>Release given number of permits ( <code>release(v)</code> )</li>
</ul>
<p><strong>Set ( <code>ISet</code> )</strong></p>
<ul>
<li>Name ( <code>name</code> )</li>
<li>Partition key ( <code>partitionKey</code> )</li>
<li>Total added item count ( <code>totalAddedItemCount</code> )</li>
<li>Total removed item count ( <code>totalRemovedItemCount</code> )</li>
<li>Clear ( <code>clear()</code> )</li>
</ul>
<p><strong>Topic ( <code>ITopic</code> )</strong></p>
<ul>
<li>Name ( <code>name</code> )</li>
<li>Config ( <code>config</code> )</li>
<li>Creation time ( <code>localCreationTime</code> )</li>
<li>Publish operation count ( <code>localPublishOperationCount</code> )</li>
<li>Receive operation count ( <code>localReceiveOperationCount</code> )</li>
<li>Total message count ( <code>totalMessageCount</code> )</li>
</ul>
<p><strong>Hazelcast Instance ( <code>HazelcastInstance</code> )</strong></p>
<ul>
<li>Name ( <code>name</code> )</li>
<li>Version ( <code>version</code> )</li>
<li>Build ( <code>build</code> )</li>
<li>Configuration ( <code>config</code> )</li>
<li>Configuration source ( <code>configSource</code> )</li>
<li>Group name ( <code>groupName</code> )</li>
<li>Network Port ( <code>port</code> )</li>
<li>Cluster-wide Time ( <code>clusterTime</code> )</li>
<li>Size of the cluster ( <code>memberCount</code> )</li>
<li>List of members ( <code>Members</code> )</li>
<li>Running state ( <code>running</code> )</li>
<li>Shutdown the member ( <code>shutdown()</code> )</li>
<li><strong>Node ( <code>HazelcastInstance.Node</code> )</strong><ul>
<li>Address ( <code>address</code> )</li>
<li>Master address ( <code>masterAddress</code> )</li>
</ul>
</li>
<li><strong>Event Service ( <code>HazelcastInstance.EventService</code> )</strong><ul>
<li>Event thread count  ( <code>eventThreadCount</code> )</li>
<li>Event queue size ( <code>eventQueueSize</code> )</li>
<li>Event queue capacity ( <code>eventQueueCapacity</code> )</li>
</ul>
</li>
<li><strong>Operation Service ( <code>HazelcastInstance.OperationService</code> )</strong><ul>
<li>Response queue size  ( <code>responseQueueSize</code> )</li>
<li>Operation executor queue size ( <code>operationExecutorQueueSize</code> )</li>
<li>Running operation count ( <code>runningOperationsCount</code> )</li>
<li>Remote operation count ( <code>remoteOperationCount</code> )</li>
<li>Executed operation count ( <code>executedOperationCount</code> )</li>
<li>Operation thread count ( <code>operationThreadCount</code> )</li>
</ul>
</li>
<li><strong>Proxy Service ( <code>HazelcastInstance.ProxyService</code> )</strong><ul>
<li>Proxy count ( <code>proxyCount</code> )</li>
</ul>
</li>
<li><strong>Partition Service ( <code>HazelcastInstance.PartitionService</code> )</strong><ul>
<li>Partition count ( <code>partitionCount</code> )</li>
<li>Active partition count ( <code>activePartitionCount</code> )</li>
</ul>
</li>
<li><strong>Connection Manager ( <code>HazelcastInstance.ConnectionManager</code> )</strong><ul>
<li>Client connection count ( <code>clientConnectionCount</code> )</li>
<li>Active connection count ( <code>activeConnectionCount</code> )</li>
<li>Connection count ( <code>connectionCount</code> )</li>
</ul>
</li>
<li><strong>Client Engine ( <code>HazelcastInstance.ClientEngine</code> )</strong><ul>
<li>Client endpoint count ( <code>clientEndpointCount</code> )</li>
</ul>
</li>
<li><strong>System Executor ( <code>HazelcastInstance.ManagedExecutorService</code> )</strong><ul>
<li>Name ( <code>name</code> )</li>
<li>Work queue size ( <code>queueSize</code> )</li>
<li>Thread count of the pool ( <code>poolSize</code> )</li>
<li>Maximum thread count of the pool ( <code>maximumPoolSize</code> )</li>
<li>Remaining capacity of the work queue ( <code>remainingQueueCapacity</code> )</li>
<li>Is shutdown ( <code>isShutdown</code> )</li>
<li>Is terminated ( <code>isTerminated</code> )</li>
<li>Completed task count ( <code>completedTaskCount</code> )</li>
</ul>
</li>
<li><strong>Operation Executor ( <code>HazelcastInstance.ManagedExecutorService</code> )</strong><ul>
<li>Name ( <code>name</code> )</li>
<li>Work queue size ( <code>queueSize</code> )</li>
<li>Thread count of the pool ( <code>poolSize</code> )</li>
<li>Maximum thread count of the pool ( <code>maximumPoolSize</code> )</li>
<li>Remaining capacity of the work queue ( <code>remainingQueueCapacity</code> )</li>
<li>Is shutdown ( <code>isShutdown</code> )</li>
<li>Is terminated ( <code>isTerminated</code> )</li>
<li>Completed task count ( <code>completedTaskCount</code> )</li>
</ul>
</li>
<li><strong>Async Executor (<code>HazelcastInstance.ManagedExecutorService</code>)</strong><ul>
<li>Name ( <code>name</code> )</li>
<li>Work queue size ( <code>queueSize</code> )</li>
<li>Thread count of the pool ( <code>poolSize</code> )</li>
<li>Maximum thread count of the pool ( <code>maximumPoolSize</code> )</li>
<li>Remaining capacity of the work queue ( <code>remainingQueueCapacity</code> )</li>
<li>Is shutdown ( <code>isShutdown</code> )</li>
<li>Is terminated ( <code>isTerminated</code> )</li>
<li>Completed task count ( <code>completedTaskCount</code> )</li>
</ul>
</li>
<li><strong>Scheduled Executor ( <code>HazelcastInstance.ManagedExecutorService</code> )</strong><ul>
<li>Name ( <code>name</code> )</li>
<li>Work queue size ( <code>queueSize</code> )</li>
<li>Thread count of the pool ( <code>poolSize</code> )</li>
<li>Maximum thread count of the pool ( <code>maximumPoolSize</code> )</li>
<li>Remaining capacity of the work queue ( <code>remainingQueueCapacity</code> )</li>
<li>Is shutdown ( <code>isShutdown</code> )</li>
<li>Is terminated ( <code>isTerminated</code> )</li>
<li>Completed task count ( <code>completedTaskCount</code> )</li>
</ul>
</li>
<li><strong>Client Executor ( <code>HazelcastInstance.ManagedExecutorService</code> )</strong><ul>
<li>Name ( <code>name</code> )</li>
<li>Work queue size ( <code>queueSize</code> )</li>
<li>Thread count of the pool ( <code>poolSize</code> )</li>
<li>Maximum thread count of the pool ( <code>maximumPoolSize</code> )</li>
<li>Remaining capacity of the work queue ( <code>remainingQueueCapacity</code> )</li>
<li>Is shutdown ( <code>isShutdown</code> )</li>
<li>Is terminated ( <code>isTerminated</code> )</li>
<li>Completed task count ( <code>completedTaskCount</code> )</li>
</ul>
</li>
<li><strong>Query Executor ( <code>HazelcastInstance.ManagedExecutorService</code> )</strong><ul>
<li>Name ( <code>name</code> )</li>
<li>Work queue size ( <code>queueSize</code> )</li>
<li>Thread count of the pool ( <code>poolSize</code> )</li>
<li>Maximum thread count of the pool ( <code>maximumPoolSize</code> )</li>
<li>Remaining capacity of the work queue ( <code>remainingQueueCapacity</code> )</li>
<li>Is shutdown ( <code>isShutdown</code> )</li>
<li>Is terminated ( <code>isTerminated</code> )</li>
<li>Completed task count ( <code>completedTaskCount</code> )</li>
</ul>
</li>
<li><strong>IO Executor ( <code>HazelcastInstance.ManagedExecutorService</code> )</strong><ul>
<li>Name ( <code>name</code> )</li>
<li>Work queue size ( <code>queueSize</code> )</li>
<li>Thread count of the pool ( <code>poolSize</code> )</li>
<li>Maximum thread count of the pool ( <code>maximumPoolSize</code> )</li>
<li>Remaining capacity of the work queue ( <code>remainingQueueCapacity</code> )</li>
<li>Is shutdown ( <code>isShutdown</code> )</li>
<li>Is terminated ( <code>isTerminated</code> )</li>
<li>Completed task count ( <code>completedTaskCount</code> )</li>
</ul>
</li>
</ul>
<h2 id="monitoring-with-jmx">Monitoring with JMX</h2>
<p>You can monitor your Hazelcast members via the JMX protocol.</p>
<ul>
<li><p>Add the following system properties to enable <a href="http://download.oracle.com/javase/1.5.0/docs/guide/management/agent.html">JMX agent</a>:</p>
<ul>
<li><code>-Dcom.sun.management.jmxremote</code></li>
<li><code>-Dcom.sun.management.jmxremote.port=\_portNo\_</code> (to specify JMX port) (<em>optional</em>)</li>
<li><code>-Dcom.sun.management.jmxremote.authenticate=false</code> (to disable JMX auth) (<em>optional</em>)</li>
</ul>
</li>
</ul>
<ul>
<li><p>Enable Hazelcast property <code>hazelcast.jmx</code> (please refer to <a href="#advanced-configuration-properties">Advanced Configuration Properties</a>);</p>
<ul>
<li>using Hazelcast configuration (API, XML, Spring)</li>
<li>or by setting system property <code>-Dhazelcast.jmx=true</code></li>
</ul>
</li>
<li><p>Use jconsole, jvisualvm (with mbean plugin) or another JMX compliant monitoring tool.</p>
</li>
</ul>
<h2 id="cluster-utilities">Cluster Utilities</h2>
<h3 id="cluster-interface">Cluster Interface</h3>
<p>Hazelcast allows you to register for membership events to get notified when members added or removed. You can also get the set of cluster members.</p>
<pre><code class="lang-java">import com.hazelcast.core.*;

HazelcastInstance hazelcastInstance = Hazelcast.newHazelcastInstance();
Cluster cluster = hazelcastInstance.getCluster();
cluster.addMembershipListener( new MembershipListener() {
  public void memberAdded( MembershipEvent membershipEvent ) {
    System.out.println( &quot;MemberAdded &quot; + membershipEvent );
  }

  public void memberRemoved( MembershipEvent membershipEvent ) {
    System.out.println( &quot;MemberRemoved &quot; + membershipEvent );
  }
} );

Member localMember  = cluster.getLocalMember();
System.out.println ( &quot;my inetAddress= &quot; + localMember.getInetAddress() );

Set setMembers  = cluster.getMembers();
for ( Member member : setMembers ) {
  System.out.println( &quot;isLocalMember &quot; + member.localMember() );
  System.out.println( &quot;member.inetaddress &quot; + member.getInetAddress() );
  System.out.println( &quot;member.port &quot; + member.getPort() );
}
</code></pre>
<h3 id="member-attributes">Member Attributes</h3>
<p>You can define various member attributes on your Hazelcast members. You can use member attributes to tag your members as your business logic requirements.</p>
<p>In order to define member attribute on a member you can either</p>
<ul>
<li><p>Provide <code>MemberAttributeConfig</code> to your <code>Config</code> object.</p>
</li>
<li><p>Provide member attributes at runtime via attribute setter methods on <code>Member</code> interface.</p>
</li>
</ul>
<p>For example, you can tag your members with their CPU characteristics and you can route CPU intensive tasks to those CPU-rich members.</p>
<pre><code class="lang-java">MemberAttributeConfig fourCore = new MemberAttributeConfig();
memberAttributeConfig.setIntAttribute( &quot;CPU_CORE_COUNT&quot;, 4 );
MemberAttributeConfig twelveCore = new MemberAttributeConfig();
memberAttributeConfig.setIntAttribute( &quot;CPU_CORE_COUNT&quot;, 12 );
MemberAttributeConfig twentyFourCore = new MemberAttributeConfig();
memberAttributeConfig.setIntAttribute( &quot;CPU_CORE_COUNT&quot;, 24 );

Config member1Config = new Config();
config.setMemberAttributeConfig( fourCore );
Config member2Config = new Config();
config.setMemberAttributeConfig( twelveCore );
Config member3Config = new Config();
config.setMemberAttributeConfig( twentyFourCore );

HazelcastInstance member1 = Hazelcast.newHazelcastInstance( member1Config );
HazelcastInstance member2 = Hazelcast.newHazelcastInstance( member2Config );
HazelcastInstance member3 = Hazelcast.newHazelcastInstance( member3Config );

IExecutorService executorService = member1.getExecutorService( &quot;processor&quot; );

executorService.execute( new CPUIntensiveTask(), new MemberSelector() {
  @Override
  public boolean select(Member member) {
    int coreCount = (int) member.getIntAttribute( &quot;CPU_CORE_COUNT&quot; );
    // Task will be executed at either member2 or member3
    if ( coreCount &gt; 8 ) { 
      return true;
    }
    return false;
  }
} );

HazelcastInstance member4 = Hazelcast.newHazelcastInstance();
// We can also set member attributes at runtime.
member4.setIntAttribute( &quot;CPU_CORE_COUNT&quot;, 2 );
</code></pre>
<h3 id="cluster-member-safety-check">Cluster-Member Safety Check</h3>
<p>To prevent data loss when shutting down a node, Hazelcast provides graceful shutdown feature. This is performed by calling the method <code>Hazelcast.shutdown</code>. Once it is called, it checks the below conditions to ensure the node is safe to shutdown:</p>
<ul>
<li>there is no active migration</li>
<li>at least one backups of partitions are synched with primary ones</li>
</ul>
<p>Even if the above conditions are not met, then they are forced to be completed by <code>Hazelcast.shutdown</code>. Eventually, when this method returns, it means node has been brought to a safe state and it can be shutdown without any data loss. </p>
<p>What if you want to be sure that your <strong>cluster</strong> is in a safe state? What does it mean that cluster is safe to shutdown without any data loss? </p>
<p>There may be some use cases like rolling upgrades, development/testing or any logic that requires a cluster/member to be safe. To provide this, Hazelcast offers <code>PartitionService</code> interface with the methods <code>isClusterSafe</code>, <code>isMemberSafe</code>, <code>isLocalMemberSafe</code> and <code>forceLocalMemberToBeSafe</code>. These methods can also be deemed as decoupled pieces from the method <code>Hazelcast.shutdown</code>. </p>
<pre><code class="lang-java">public interface PartitionService {
   ...
   ...
    boolean isClusterSafe();
    boolean isMemberSafe(Member member);
    boolean isLocalMemberSafe();
    boolean forceLocalMemberToBeSafe(long timeout, TimeUnit unit);
}
</code></pre>
<p>The method <code>isClusterSafe</code> checks whether the cluster is in a safe state. It returns <code>true</code> if there are no active partition migration and there are sufficient backups for each partition. Once it returns <code>true</code> it means the cluster is safe and a node can be shutdown without data loss.</p>
<p>The method <code>isMemberSafe</code> checks whether a specific node is in a safe state. This check controls if first backups of partitions of the given node are synched with the primary ones. Once it returns <code>true</code> it means the given node is safe and it can be shutdown without data loss. Similarly, the method <code>isLocalMemberSafe</code> does the same check for the local member. And, the method <code>forceLocalMemberToBeSafe</code> forces the owned and backup partitions to be synchronized to make the local member safe.</p>
<p><img src="images/NoteSmall.jpg" alt="image"> <strong><em>NOTE:</em></strong> <em>These methods are available from Hazelcast 3.3.</em></p>
<h4 id="sample-codes">Sample Codes</h4>
<pre><code class="lang-java">PartitionService partitionService = hazelcastInstance.getPartitionService().isClusterSafe()
if (partitionService().isClusterSafe()) {
  hazelcastInstance.shutdown(); // or terminate
}
</code></pre>
<p>OR </p>
<pre><code class="lang-java">PartitionService partitionService = hazelcastInstance.getPartitionService().isClusterSafe()
if (partitionService().isLocalMemberSafe()) {
  hazelcastInstance.shutdown(); // or terminate
}
</code></pre>
<p><br></br></p>
<p><strong><em>RELATED INFORMATION</em></strong></p>
<p><em>For more code samples please refer to <a href="https://github.com/hazelcast/hazelcast-code-samples/tree/master/monitoring/cluster/src/main/java">PartitionService Code Samples</a></em>.</p>
<h2 id="management-center">Management Center</h2>
<h3 id="introduction">Introduction</h3>
<p>Hazelcast Management Center enables you to monitor and manage your nodes running Hazelcast. In addition to monitoring overall state of your clusters, you can also analyze and browse your data structures in detail, update map configurations and take thread dump from nodes. With its scripting and console module, you can run scripts (JavaScript, Groovy, etc.) and commands on your nodes.</p>
<h4 id="installation">Installation</h4>
<p>There are two options for installing Hazelcast Management Center. You can either deploy <code>mancenter</code>-<em>version</em><code>.war</code> application into your Java application server/container or start Hazelcast Management Center directly from the command line and then have the Hazelcast nodes communicate with that web application. That means, your Hazelcast nodes should know the URL of <code>mancenter</code> application before they start.</p>
<p>Here are the steps:</p>
<ul>
<li>Download the latest Hazelcast ZIP from <a href="http://www.hazelcast.org/download/">hazelcast.org</a>. ZIP contains <code>mancenter</code>-<em>version</em><code>.war</code> file. </li>
<li>You can directly start <code>mancenter</code>-<em>version</em><code>.war</code> file from the command line:</li>
</ul>
<pre><code class="lang-java">java -jar mancenter-*version*.war 8080 mancenter
</code></pre>
<ul>
<li>The above command will start Hazelcast Management Center on port 8080 with context root &#39;mancenter&#39; (<code>http://localhost:8080/mancenter</code>).</li>
<li>Or, you can deploy it to your web server (Tomcat, Jetty, etc.). Let us say it is running at <code>http://localhost:8080/mancenter</code>.</li>
<li>After above steps are performed, make sure that <code>http://localhost:8080/mancenter</code> is up.</li>
<li>Configure your Hazelcast nodes by adding the URL of your web application to your <code>hazelcast.xml</code>. Hazelcast nodes will send their states to this URL.</li>
</ul>
<pre><code class="lang-xml">&lt;management-center enabled=&quot;true&quot;&gt;http://localhost:8080/mancenter&lt;/management-center&gt;
</code></pre>
<ul>
<li><p>Start your Hazelcast cluster.</p>
</li>
<li><p>Browse to <code>http://localhost:8080/mancenter</code> and login. <strong>Initial login username/password is <code>admin/admin</code></strong></p>
</li>
</ul>
<p>Management Center creates a directory with name &quot;mancenter&quot; under your &quot;user/home&quot; directory to save data files. You can change the data directory by setting <code>hazelcast.mancenter.home</code> system property.</p>
<h3 id="tool-overview">Tool Overview</h3>
<p>Once the page is loaded after selecting a cluster, tool&#39;s home page appears as shown below.</p>
<p><img src="images/NonHostedMCHomePage.jpg" alt=""></p>
<p>This page provides the fundamental properties of the selected cluster which are explained in <a href="#homepage">Home Page</a> section.</p>
<p>It also has a toolbar on the top and a menu on the left.</p>
<h4 id="toolbar">Toolbar</h4>
<p>Toolbar has the following buttons:</p>
<ul>
<li><strong>Home</strong>: When pressed, loads the home page shown above. Please see <a href="#homepage">Home Page</a>.</li>
<li><strong>Scripting</strong>: When pressed, loads the page used to write and execute user`s own scripts on the cluster. Please see <a href="#scripting">Scripting</a>.</li>
<li><strong>Console</strong>: When pressed, loads the page used to execute commands on the cluster. Please see <a href="#console">Console</a>.</li>
<li><strong>Alerts</strong>: It is used to create alerts by specifying filters. Please see <a href="#alerts">Alerts</a>.</li>
<li><strong>Documentation</strong>: It is used to open the documentation of Management Center in a window inside the tool. Please see <a href="#documentation">Documentation</a>.</li>
<li><strong>Administration</strong>: It is used by the admin users to manage users in the system. Please see <a href="#administration">Administration</a>.</li>
<li><strong>Time Travel</strong>: It is used to see the cluster&#39;s situation at a time in the past. Please see <a href="#time-travel">Time Travel</a>.</li>
<li><p><strong>Cluster Selector</strong>: It is used to switch between clusters. When the mouse is moved onto this item, a drop down list of clusters appears.</p>
<p><img src="images/4ChangeCluster.jpg" alt=""></p>
<p>The user can select any cluster and once selected, the page immediately loads with the selected cluster&#39;s information.</p>
</li>
<li><strong>Logout</strong>: It is used to close the current user&#39;s session.</li>
</ul>
<p><img src="images/NoteSmall.jpg" alt="image"> <strong><em>NOTE:</em></strong> <em>Some of the above listed toolbar items are not visible to the users who are not admin or have <strong>read-only</strong> permission. Also, some of the operations explained in the later sections cannot be performed by users with read-only permission. Please see <a href="#administration">Administration</a> for details.</em></p>
<h4 id="menu">Menu</h4>
<p>Home page includes a menu on the left which lists the distributed data structures in the cluster and also all cluster members (nodes), as shown below.</p>
<p><img src="images/LeftMenu.jpg" alt=""></p>
<p><img src="images/NoteSmall.jpg" alt="image"> <strong><em>NOTE:</em></strong> <em>Distributed data structures will be shown there when the proxies are created for them.</em></p>
<p>Menu items can be expanded/collapsed by clicking on them. Below is the list of menu items with the links to their explanations.</p>
<ul>
<li><a href="#caches">Caches</a></li>
<li><a href="#maps">Maps</a></li>
<li><a href="#queues">Queues</a></li>
<li><a href="#topics">Topics</a></li>
<li><a href="#MultiMaps">MultiMaps</a></li>
<li><a href="#executors">Executors</a></li>
<li><a href="#members">Members</a></li>
</ul>
<h4 id="tabbed-view">Tabbed View</h4>
<p>Each time an item from the toolbar or menu is selected, it is added to main view as a tab, as shown below.</p>
<p><img src="images/NonHMCTabbedView.jpg" alt=""></p>
<p>In the above example, <em>Home</em>, <em>Scripting</em>, <em>Console</em>, <em>queue1</em> and <em>map1</em> windows can be seen as tabs. Windows can be closed using the <img src="images/CloseIcon.jpg" alt=""> icon on each tab (except the Home Page; it cannot be closed).</p>
<hr>
<h3 id="home-page">Home Page</h3>
<p>This is the first page appearing after logging in. It gives an overview of the cluster connected. Below subsections describe each portion of the page.</p>
<h4 id="cpu-utilization">CPU Utilization</h4>
<p>This part of the page provides information related to load and utilization of CPUs for each node, as shown below.</p>
<p><img src="images/NonHMCCPUUtil.jpg" alt=""></p>
<p>First column lists the nodes with their IPs and ports. Then, the loads on each CPU for the last 1, 5 and 15 minutes are listed. The last column (<strong>Chart</strong>) shows the utilization of CPUs graphically. When you move the mouse cursor on a desired graph, you can see the CPU utilization at the time to which cursor corresponds. Graphs under this column shows the CPU utilizations approximately for the last 2 minutes.</p>
<h4 id="memory-utilization">Memory Utilization</h4>
<p>This part of the page provides information related to memory usages for each node, as shown below.</p>
<p><img src="images/NonHMCMemoryUtil.jpg" alt=""></p>
<p>First column lists the nodes with their IPs and ports. Then, used and free memories out of the total memory reserved for Hazelcast usage are shown, in real-time. <strong>Max</strong> column lists the maximum memory capacity of each node and <strong>Percent</strong> column lists the percentage value of used memory out of the maximum memory. The last column (<strong>Chart</strong>) shows the memory usage of nodes graphically. When you move the mouse cursor on a desired graph, you can see the memory usage at the time to which cursor corresponds. Graphs under this column shows the memory usages approximately for the last 2 minutes.</p>
<h4 id="memory-distribution">Memory Distribution</h4>
<p>This part of the page graphically provides the cluster wise breakdown of memory, as shown below. Blue area is the memory used by maps, dark yellow area is the memory used by non-Hazelcast entities and green area is the free memory (out of whole cluster`s memory capacity).</p>
<p><img src="images/Home-MemoryDistribution.jpg" alt=""></p>
<p>In the above example, you can see 0.32% of the total memory is used by Hazelcast maps (it can be seen by moving the mouse cursor on it), 58.75% is used by non-Hazelcast entities and 40.85% of the total memory is free.</p>
<h4 id="map-memory-distribution">Map Memory Distribution</h4>
<p>This part is actually the breakdown of the blue area shown in <strong>Memory Distribution</strong> graph explained above. It provides the percentage values of the memories used by each map, out of the total cluster memory reserved for all Hazelcast maps.</p>
<p><img src="images/Home-MapMemoryDistribution.jpg" alt=""></p>
<p>In the above example, you can see 49.55% of the total map memory is used by <strong>map1</strong> and 49.55% is used by <strong>map2</strong>.</p>
<h4 id="partition-distribution">Partition Distribution</h4>
<p>This pie chart shows what percentage of partitions each node has, as shown below.</p>
<p><img src="images/Home-PartitionDistribution.jpg" alt=""></p>
<p>You can see each node&#39;s partition percentages by moving the mouse cursor on the chart. In the above example, you can see the node &quot;127.0.0.1:5708&quot; has 5.64% of the total partition count (which is 271 by default and configurable, please see <a href="http://hazelcast.org/docs/latest/manual/html-single/hazelcast-documentation.html#advanced-configuration-properties">Advanced Configuration Properties</a>).</p>
<hr>
<h3 id="caches">Caches</h3>
<p>You can monitor your caches&#39; metrics by clicking the cache name listed on the left panel under <strong>Caches</strong> menu item. A new tab for monitoring that cache instance is opened on the right, as shown below.</p>
<p><img src="images/ManCenter-Caches.jpg" alt=""></p>
<p>On top of the page, there are four charts to monitor the <strong>Gets</strong>, <strong>Puts</strong>, <strong>Removals</strong> and <strong>Evictions</strong> in real-time. For all charts&#39; X-axis shows the current system time and a chart can be opened as a separate dialog by clicking on the <img src="images/MaximizeChart.jpg" alt=""> button placed at top right of each chart.</p>
<p>Under these charts, there is Cache Statistics Data Table. From left to right, this table lists the IP addresses and ports of each node, get, put, removal, eviction, hit and miss count per second in real-time.</p>
<p>You can navigate through the pages using the buttons placed at the bottom right of the table (<strong>First, Previous, Next, Last</strong>). The order of the listings in each column can be ascended or descended by clicking on column headings.</p>
<h3 id="maps">Maps</h3>
<p>Map instances are listed under the <strong>Maps</strong> menu item on the left. When you click on a map, a new tab for monitoring that map instance is opened on the right, as shown below. In this tab, you can monitor metrics and also re-configure the selected map.</p>
<p><img src="images/MapsHome.jpg" alt=""></p>
<p>Below subsections explain the portions of this window.</p>
<h4 id="map-browser">Map Browser</h4>
<p>Map Browser is a tool used to retrieve properties of the entries stored in the selected map. It can be opened by clicking on the <strong>Map Browser</strong> button, located at top right of the window. Once opened, the tool appears as a dialog, as shown below.</p>
<p><img src="images/Map-MapBrowser.jpg" alt=""></p>
<p>Once the key and key&#39;s type is specified and <strong>Browse</strong> button is clicked, key&#39;s properties along with its value is listed.</p>
<h4 id="map-config">Map Config</h4>
<p>By using Map Config tool, you can set selected map&#39;s attributes like the backup count, TTL, and eviction policy. It can be opened by clicking on the <strong>Map Config</strong> button, located at top right of the window. Once opened, the tool appears as a dialog, as shown below.</p>
<p><img src="images/Map-MapConfig.jpg" alt=""></p>
<p>Change any attribute as required and click <strong>Update</strong> button to save changes.</p>
<h4 id="map-monitoring">Map Monitoring</h4>
<p>Besides Map Browser and Map Config tools, this page has many  monitoring options explained below. All of these perform real-time monitoring.</p>
<p>On top of the page, there are small charts to monitor the size, throughput, memory usage, backup size, etc. of the selected map in real-time. All charts&#39; X-axis shows the current system time. Other small monitoring charts can be selected using <img src="images/ChangeWindowIcon.jpg" alt=""> button placed at top right of each chart. When it is clicked, the whole list of monitoring options are listed, as shown below.</p>
<p><img src="images/SelectConfOpt.jpg" alt=""></p>
<p>When you click on a desired monitoring, the chart is loaded with the selected option. Also, a chart can be opened as a separate dialog by clicking on the <img src="images/MaximizeChart.jpg" alt=""> button placed at top right of each chart. Below monitoring charts are available:</p>
<ul>
<li><strong>Size</strong>: Monitors the size of the map. Y-axis is the entry count (should be multiplied by 1000).</li>
<li><strong>Throughput</strong>: Monitors get, put and remove operations performed on the map. Y-axis is the operation count.</li>
<li><strong>Memory</strong>: Monitors the memory usage on the map. Y-axis is the memory count.</li>
<li><strong>Backups</strong>: It is the chart loaded when &quot;Backup Size&quot; is selected. Monitors the size of the backups in the map. Y-axis is the backup entry count (should be multiplied by 1000).</li>
<li><strong>Backup Memory</strong>: It is the chart loaded when &quot;Backup Mem.&quot; is selected. Monitors the memory usage of the backups. Y-axis is the memory count.</li>
<li><strong>Hits</strong>: Monitors the hit count of the map.</li>
<li><strong>Puts/s, Gets/s, Removes/s</strong>: These three charts monitor the put, get and remove operations (per second) performed on the selected map.</li>
</ul>
<p>Under these charts, there are <strong>Map Memory</strong> and <strong>Map Throughput</strong> data tables. Map Memory data table provides memory metrics distributed over nodes, as shown below.</p>
<p><img src="images/Map-MemoryDataTable.jpg" alt=""></p>
<p>From left to right, this table lists the IP address and port, entry counts, memory used by entries, backup entry counts, memory used by backup entries, events, hits, locks and dirty entries (in the cases where <em>MapStore</em> is enabled, these are the entries that are put to/removed from the map but not written to/removed from a database yet) of each node in the map. You can navigate through the pages using the buttons placed at the bottom right of the table (<strong>First, Previous, Next, Last</strong>). The order of the listings in each column can be ascended or descended by clicking on column headings.</p>
<p>Map Throughput data table provides information about the operations (get, put, remove) performed on each node in the map, as shown below.</p>
<p><img src="images/Map-MapThroughputDataTable.jpg" alt=""></p>
<p>From left to right, this table lists the IP address and port of each node, put, get and remove operations on each node, average put, get, remove latencies and maximum put, get, remove latencies on each node.</p>
<p>You can select the period in the combo box placed at top right corner of the window, for which the table data will be shown. Available values are <strong>Since Beginning</strong>, <strong>Last Minute</strong>, <strong>Last 10 Minutes</strong> and <strong>Last 1 Hour</strong>.</p>
<p>You can navigate through the pages using the buttons placed at the bottom right of the table (<strong>First, Previous, Next, Last</strong>). The order of the listings in each column can be ascended or descended by clicking on column headings.</p>
<h3 id="queues">Queues</h3>
<p>Using the menu item <strong>Queues</strong>, you can monitor your queues data structure. When you expand this menu item and click on a queue, a new tab for monitoring that queue instance is opened on the right, as shown below.</p>
<p><img src="images/Queues-Home.jpg" alt=""></p>
<p>On top of the page, there are small charts to monitor the size, offers and polls of the selected queue in real-time. All charts&#39; X-axis shows the current system time. And a chart can be opened as a separate dialog by clicking on the <img src="images/MaximizeChart.jpg" alt=""> button placed at top right of each chart. Below monitoring charts are available:</p>
<ul>
<li><strong>Size</strong>: Monitors the size of the queue. Y-axis is the entry count (should be multiplied by 1000).</li>
<li><strong>Offers</strong>: Monitors the offers sent to the selected queue. Y-axis is the offer count.</li>
<li><strong>Polls</strong>: Monitors the polls sent to the selected queue. Y-axis is the poll count.</li>
</ul>
<p>Under these charts, there are <strong>Queue Statistics</strong> and <strong>Queue Operation Statistics</strong> tables. Queue Statistics table provides item and backup item counts in the queue and age statistics of items and backup items at each node, as shown below.</p>
<p><img src="images/QueueStatistics.jpg" alt=""></p>
<p>From left to right, this table lists the IP address and port, items and backup items on the queue of each node, and maximum, minimum and average age of items in the queue. You can navigate through the pages using the buttons placed at the bottom right of the table (<strong>First, Previous, Next, Last</strong>). The order of the listings in each column can be ascended or descended by clicking on column headings.</p>
<p>Queue Operations Statistics table provides information about the operations (offers, polls, events) performed on the queues, as shown below.</p>
<p><img src="images/QueueOperationStatistics.jpg" alt=""></p>
<p>From left to right, this table lists the IP address and port of each node, and counts of offers, rejected offers, polls, poll misses and events.</p>
<p>You can select the period in the combo box placed at top right corner of the window, for which the table data will be shown. Available values are <strong>Since Beginning</strong>, <strong>Last Minute</strong>, <strong>Last 10 Minutes</strong> and <strong>Last 1 Hour</strong>.</p>
<p>You can navigate through the pages using the buttons placed at the bottom right of the table (<strong>First, Previous, Next, Last</strong>). The order of the listings in each column can be ascended or descended by clicking on column headings.</p>
<h3 id="topics">Topics</h3>
<p>You can monitor your topics&#39; metrics by clicking the topic name listed on the left panel under <strong>Topics</strong> menu item. A new tab for monitoring that topic instance is opened on the right, as shown below.</p>
<p><img src="images/ManCenter-Topics.jpg" alt=""></p>
<p>On top of the page, there are two charts to monitor the <strong>Publishes</strong> and <strong>Receives</strong> in real-time. They show the published and received message counts of the cluster, nodes of which are subscribed to the selected topic. Both charts&#39; X-axis shows the current system time. and a chart can be opened as a separate dialog by clicking on the <img src="images/MaximizeChart.jpg" alt=""> button placed at top right of each chart.</p>
<p>Under these charts, there is Topic Operation Statistics table. From left to right, this table lists the IP addresses and ports of each node, and counts of message published and receives per second in real-time. You can select the period in the combo box placed at top right corner of the table, for which the table data will be shown. Available values are <strong>Since Beginning</strong>, <strong>Last Minute</strong>, <strong>Last 10 Minutes</strong> and <strong>Last 1 Hour</strong>.</p>
<p>You can navigate through the pages using the buttons placed at the bottom right of the table (<strong>First, Previous, Next, Last</strong>). The order of the listings in each column can be ascended or descended by clicking on column headings.</p>
<h3 id="multimaps">MultiMaps</h3>
<p>As you know, MultiMap is a specialized map where you can associate a key with multiple values. This monitoring option is similar to the <strong>Maps</strong> one. Same monitoring charts and data tables are used to monitor MultiMaps. Differences are; not being able to browse the MultiMaps and to re-configure it. Please see <a href="#maps">Maps</a>.</p>
<h3 id="executors">Executors</h3>
<p>Executor instances are listed under the <strong>Executors</strong> menu item on the left. When you click on a executor, a new tab for monitoring that executor instance is opened on the right, as shown below.</p>
<p><img src="images/ExecutorsHome.jpg" alt=""></p>
<p>On top of the page, there are small charts to monitor the pending, started, completed, etc. executors in real-time. All charts&#39; X-axis shows the current system time. Other small monitoring charts can be selected using <img src="images/ChangeWindowIcon.jpg" alt=""> button placed at top right of each chart. When it is clicked, the whole list of monitoring options are listed, as shown below.</p>
<p><img src="images/SelectExecMonOpt.jpg" alt=""></p>
<p>When you click on a desired monitoring, the chart is loaded with the selected option. Also, a chart can be opened as a separate dialog by clicking on the <img src="images/MaximizeChart.jpg" alt=""> button placed at top right of each chart. Below monitoring charts are available:</p>
<ul>
<li><strong>Pending</strong>: Monitors the pending executors. Y-axis is the executor count.</li>
<li><strong>Started</strong>: Monitors the started executors. Y-axis is the executor count.</li>
<li><strong>Start Lat. (msec)</strong>: Shows the latency when executors are started. Y-axis is the duration in milliseconds.</li>
<li><strong>Completed</strong>: Monitors the completed executors. Y-axis is the executor count.</li>
<li><strong>Comp. Time (msec)</strong>: Shows the completion period of executors. Y-axis is the duration in milliseconds.</li>
</ul>
<p>Under these charts, there is <strong>Executor Operation Statistics</strong> table, as shown below.</p>
<p><img src="images/ExecutorOperationStats.jpg" alt=""></p>
<p>From left to right, this table lists the IP address and port of nodes, counts of pending, started and completed executors per second, execution time and average start latency of executors on each node. You can navigate through the pages using the buttons placed at the bottom right of the table (<strong>First, Previous, Next, Last</strong>). The order of the listings in each column can be ascended or descended by clicking on column headings.</p>
<h3 id="members">Members</h3>
<p>This menu item is used to monitor each cluster member (node) and also perform operations like running garbage collection (GC) and taking a thread dump. Once a member is selected from the menu, a new tab for monitoring that member is opened on the right, as shown below.</p>
<p><img src="images/MembersHome.jpg" alt=""></p>
<p><strong>CPU Utilization</strong> chart shows the CPU usage on the selected member in percentage. <strong>Memory Utilization</strong> chart shows the memory usage on the selected member with three different metrics (maximum, used and total memory). Both of these charts can be opened as separate windows using the <img src="images/ChangeWindowIcon.jpg" alt=""> button placed at top right of each chart, a more clearer view can be obtained by this way.</p>
<p>The window titled with <strong>Partitions</strong> shows which partitions are assigned to the selected member. <strong>Runtime</strong> is a dynamically updated window tab showing the processor number, start and up times, maximum, total and free memory sizes of the selected member. Next to this, there is <strong>Properties</strong> tab showing the system properties. <strong>Member Configuration</strong> window shows the connected Hazelcast cluster&#39;s XML configuration.</p>
<p>Besides the aforementioned monitoring charts and windows, there are also operations you can perform on the selected member through this page. You can see operation buttons located at top right of the page, explained below:</p>
<ul>
<li><strong>Run GC</strong>: When pressed, garbage collection is executed on the selected member. A notification stating that the GC execution was successful will be shown.</li>
<li><strong>Thread Dump</strong>: When pressed, thread dump of the selected member is taken and shown as a separate dialog to the user.</li>
<li><strong>Shutdown Node</strong>: It is used to shutdown the selected member.</li>
</ul>
<h3 id="scripting">Scripting</h3>
<p>Scripting feature of this tool is used to execute codes on the cluster. You can open this feature as a tab by selecting <strong>Scripting</strong> located at the toolbar on top. Once selected, it is opened as shown below.</p>
<p><img src="images/scripting.jpg" alt=""></p>
<p>In this window, <strong>Scripting</strong> part is the actual coding editor. You can select the members on which the code will be executed from the <strong>Members</strong> list shown at the right side of the window. Below the members list there is a combo box enabling you to select a scripting language. Currently, Javascript, Ruby, Groovy and Python languages are supported. After you write your script and press <strong>Execute</strong> button, you can see the execution result in the <strong>Result</strong> part of the window.</p>
<p>There are also <strong>Save</strong> and <strong>Delete</strong> buttons on top right of the scripting editor. You can save your scripts by pressing the <strong>Save</strong> button after you type a name for the script into the field next to this button. The scripts you saved are listed in the <strong>Saved Scripts</strong> part of the window, located at the bottom right of the page. You can simply click on a saved script from this list to execute or edit it. And, if you want to remove a script that you wrote and save before, just select it from this list and press <strong>Delete</strong> button.</p>
<p>In the scripting engine you have a <code>HazelcastInstance</code> bonded to a variable named <code>hazelcast</code>. You can invoke any method that <code>HazelcastInstance</code> has via the <code>hazelcast</code> variable. You can see sample usage for JavaScript below.</p>
<pre><code class="lang-javascript">var name = hazelcast.getName();
var node = hazelcast.getCluster().getLocalMember();
var employees = hazelcast.getMap(&quot;employees&quot;);
employees.put(&quot;1&quot;,&quot;John Doe&quot;);
employees.get(&quot;1&quot;); // will return &quot;John Doe&quot;
</code></pre>
<h3 id="console">Console</h3>
<p>Management Center has also a console feature that enables you to execute commands on the cluster. For example, you can perform &quot;put&quot;s and &quot;get&quot;s on a map, after you set the namespace with the command <code>ns &lt;name of your map&gt;</code>. Same is valid for queues, topics, etc. To execute your command, just type it into the field below the console and press <strong>Enter</strong>. You can type <code>help</code> to see all commands that can be used.</p>
<p>Console window can be opened by clicking on the <strong>Console</strong> button located at the toolbar. A sample view with some commands executed can ben seen below.</p>
<p><img src="images/console.jpg" alt=""></p>
<h3 id="alerts">Alerts</h3>
<p>Alerts feature of this tool is used to receive alerts by creating filters. In these filters, criteria can be specified for cluster, nodes or data structures. When the specified criteria are met for a filter, related alert is shown as a pop-up message on top right of the page.</p>
<p>Once the <strong>Alerts</strong> button located at the toolbar is clicked, the page shown below appears.</p>
<p><img src="images/Alerts-Home.jpg" alt=""></p>
<p><strong>Creating Filters for Cluster</strong></p>
<p>Select <strong>Cluster Alerts</strong> check box to create a cluster wise filter. Once selected, next screen asks the items for which alerts will be created, as shown below.</p>
<p><img src="images/ClusterAlert1.jpg" alt=""></p>
<p>Select the desired items and click the <strong>Next</strong> button. On the next page shown below, specify the frequency of checks in <strong>hour</strong> and <strong>min</strong> fields, give a name for the filter, select whether notification e-mails will be sent (to no one, only admin or to all users) and select whether the alert data will be written to the disk (if checked, you can see the alert log at the directory <em>/users/<your user>/mancenter<version></em>).</p>
<p><img src="images/ClusterAlert2.jpg" alt=""></p>
<p>Click on the <strong>Save</strong> button; your filter will be saved and put into the <strong>Filters</strong> part of the page, as shown below.</p>
<p><img src="images/ClusterAlert3.jpg" alt=""></p>
<p>You can edit the filter by clicking on the <img src="images/EditIcon.jpg" alt=""> icon and delete it by clicking on the <img src="images/DeleteIcon.jpg" alt=""> icon.</p>
<p><strong>Creating Filters for Cluster Members</strong></p>
<p>Select <strong>Member Alerts</strong> check box to create filters for some or all members in the cluster. Once selected, next screen asks for which members the alert will be created. Select as desired and click on the <strong>Next</strong> button. On the next page shown below, specify the criteria.</p>
<p><img src="images/MemberAlert1.jpg" alt=""></p>
<p>Alerts can be created when:</p>
<ul>
<li>free memory on the selected nodes is less than the specified number</li>
<li>used heap memory is larger than the specified number</li>
<li>number of active threads are less than the specified count</li>
<li>number of daemon threads are larger than the specified count</li>
</ul>
<p>When two or more criteria is specified they will be bound with the logical operator <strong>AND</strong>.</p>
<p>On the next page, give a name for the filter, select whether notification e-mails will be sent (to no one, only admin or to all users) and select whether the alert data will be written to the disk (if checked, you can see the alert log at the directory <em>/users/<your user>/mancenter<version></em>).</p>
<p>Click on the <strong>Save</strong> button; your filter will be saved and put into the <strong>Filters</strong> part of the page. You can edit the filter by clicking on the <img src="images/EditIcon.jpg" alt=""> icon and delete it by clicking on the <img src="images/DeleteIcon.jpg" alt=""> icon.</p>
<p><strong>Creating Filters for Data Types</strong></p>
<p>Select <strong>Data Type Alerts</strong> check box to create filters for data structures. Next screen asks for which data structure (maps, queues, multimaps, executors) the alert will be created. Once a structure is selected, next screen immediately loads and wants you to select the data structure instances (i.e. if you selected <em>Maps</em>, it will list all the maps defined in the cluster, you can select only one map or more). Select as desired, click on the <strong>Next</strong> button and select the members on which the selected data structure instances run.</p>
<p>Next screen, as shown below, is the one where the criteria for the selected data structure are specified.</p>
<p><img src="images/DataAlert1.jpg" alt=""></p>
<p>As it can be seen, you will select an item from the left combo box, select the operator in the middle one, specify a value in the input field and click on the <strong>Add</strong> button. You can create more than one criteria in this page, and those will be bound by the logical operator <strong>AND</strong>.</p>
<p>After the criteria are specified and <strong>Next</strong> button clicked, give a name for the filter, select whether notification e-mails will be sent (to no one, only admin or to all users) and select whether the alert data will be written to the disk (if checked, you can see the alert log at the directory <em>/users/<your user>/mancenter<version></em>).</p>
<p>Click on the <strong>Save</strong> button; your filter will be saved and put into the <strong>Filters</strong> part of the page. You can edit the filter by clicking on the <img src="images/EditIcon.jpg" alt=""> icon and delete it by clicking on the <img src="images/DeleteIcon.jpg" alt=""> icon.</p>
<h3 id="administration">Administration</h3>
<p><img src="images/NoteSmall.jpg" alt="image"> <strong><em>NOTE:</em></strong> <em>This toolbar item is available only to admin users, i.e. the users who initially have **</em>admin<em>** as their both usernames and passwords.</em></p>
<p><strong>Admin</strong> user can add, edit, remove users and specify the permissions for the users of Management Center. To perform these operations, click on <strong>Administration</strong> button located at the toolbar. The page shown below appears.</p>
<p><img src="images/admin.jpg" alt=""></p>
<p>To add a user to the system, specify the username, e-mail and password in the <strong>Add/Edit User</strong> part of the page. If the user to be added will have administrator privileges, select <strong>isAdmin</strong> checkbox. <strong>Permissions</strong> checkboxes have two values:</p>
<ul>
<li><strong>Read Only</strong>: If this permission is given to the user, only <em>Home</em>, <em>Documentation</em> and <em>Time Travel</em> items will be visible at the toolbar at that user&#39;s session. Also, the users with this permission cannot update a <a href="#map-config">map configuration</a>, run a garbage collection and take a thread dump on a node, and shutdown a node (please see <a href="#members">Members</a> section).</li>
<li><strong>Read/Write</strong>: If this permission is given to the user, <em>Home</em>, <em>Scripting</em>, <em>Console</em>, <em>Documentation</em> and <em>Time Travel</em> items will be visible. The users with this permission can update a map configuration and perform operations on the nodes.</li>
</ul>
<p>After all fields are entered/selected, click <strong>Save</strong> button to create the user. You will see the newly created user&#39;s username on the left side, in the <strong>Users</strong> part of the page.</p>
<p>To edit or delete a user, select a username listed in the <strong>Users</strong>. Selected user&#39;s information will appear on the right side of the page. To update the user information, change the fields as desired and click <strong>Save</strong> button. To delete the user from the system, click <strong>Delete</strong> button.</p>
<h3 id="time-travel">Time Travel</h3>
<p>Time Travel is used to check the status of the cluster at a time in the past. Once this item is selected on the toolbar, a small window appears on top of the page, as shown below.</p>
<p><img src="images/timetravel.jpg" alt=""></p>
<p>To see the cluster status in a past time, Time Travel should be enabled first. Click on the area where it says <strong>OFF</strong> (on the right of Time Travel window). It will turn to <strong>ON</strong> after it asks whether to enable the Time Travel with a dialog (just click on <strong>Enable</strong>).</p>
<p>Once it is <strong>ON</strong>, it means that the status of your cluster is started to be stored on your disk, as long as your web server is alive.</p>
<p>You can go back in time using the slider and/or calendar and check your cluster&#39;s situation at the selected time. All data structures and members can be monitored as if you are using the management center normally (charts and data tables for each data structure and members). Using the arrow buttons placed at both sides of the slider, you can go back or further with steps of 5 seconds. Naturally, it will show the status if Time Travel has been <strong>ON</strong> at the selected time in past. Otherwise, all charts and tables will be shown as empty.</p>
<p>The historical data collected with Time Travel feature are stored in a file database on the disk. These files can be found on the directory specified by <code>hazelcast.mancenter.home</code> (by default <code>mancenter3</code> directory in user home folder.)</p>
<h3 id="documentation">Documentation</h3>
<p>To see the documentation, click on the <strong>Documentation</strong> button located at the toolbar. Management Center manual will appear as a tab.</p>
<h3 id="suggested-heap-size">Suggested Heap Size</h3>
<p><strong>For 2 Nodes</strong></p>
<table>
<thead>
<tr>
<th>Mancenter Heap Size</th>
<th># of Maps</th>
<th># of Queues</th>
<th># of Topics</th>
</tr>
</thead>
<tbody>
<tr>
<td>256m</td>
<td>3k</td>
<td>1k</td>
<td>1k</td>
</tr>
<tr>
<td>1024m</td>
<td>10k</td>
<td>1k</td>
<td>1k</td>
</tr>
</tbody>
</table>
<p><strong>For 10 Nodes</strong></p>
<table>
<thead>
<tr>
<th>Mancenter Heap Size</th>
<th># of Maps</th>
<th># of Queues</th>
<th># of Topics</th>
</tr>
</thead>
<tbody>
<tr>
<td>256m</td>
<td>50</td>
<td>30</td>
<td>30</td>
</tr>
<tr>
<td>1024m</td>
<td>2k</td>
<td>1k</td>
<td>1k</td>
</tr>
</tbody>
</table>
<p><strong>For 20 Nodes</strong></p>
<table>
<thead>
<tr>
<th>Mancenter Heap Size</th>
<th># of Maps</th>
<th># of Queues</th>
<th># of Topics</th>
</tr>
</thead>
<tbody>
<tr>
<td>256m*</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
</tr>
<tr>
<td>1024m</td>
<td>1k</td>
<td>1k</td>
<td>1k</td>
</tr>
</tbody>
</table>
<p>* With 256m heap, management center is unable to collect statistics.</p>
<p><br> </br></p>
<h2 id="clustered-jmx">Clustered JMX</h2>
<p><img src="images/enterprise-onlycopy.jpg" alt=""></p>
<p>Clustered JMX via Management Center will allow you to monitor clustered statistics of distributed objects from a JMX interface.</p>
<h3 id="clustered-jmx-configuration">Clustered JMX Configuration</h3>
<p>In order to configure Clustered JMX, you should use two command line parameters for your Management Center deployment.</p>
<ul>
<li><code>-Dhazelcast.mc.jmx.enabled=true</code> (default is false)</li>
<li><code>-Dhazelcast.mc.jmx.port=9000</code> (optional, default is 9999)</li>
</ul>
<p>With embedded Jetty, there is no need to deploy your Management Center application to any container or application server.</p>
<p>You can start Management Center application with Clustered JMX enabled as shown below.</p>
<pre><code>java -Dhazelcast.mc.jmx.enabled=true -Dhazelcast.mc.jmx.port=9999 -jar mancenter-3.3.jar
</code></pre><p>Once Management Center starts, you should see a log similar to below.</p>
<pre><code>INFO: Management Center 3.3
Jun 05, 2014 11:55:32 AM com.hazelcast.webmonitor.service.jmx.impl.JMXService
INFO: Starting Management Center JMX Service on port :9999
</code></pre><p>You should be able to connect to Clustered JMX interface from the address <code>localhost:9999</code>.</p>
<p>You can use <code>jconsole</code> or any other JMX client to monitor your Hazelcast Cluster. As a sample, below is the <code>jconsole</code> screenshot of the Clustered JMX hierarchy.</p>
<p><img src="images/ClusteredJMX.png" alt=""></p>
<h3 id="api-documentation">API Documentation</h3>
<p>The management beans are exposed with the following object name format.</p>
<p><code>ManagementCenter[</code><em>cluster name</em><code>]:type=&lt;</code><em>object type</em><code>&gt;,name=&lt;</code><em>object name</em><code>&gt;,member=&quot;&lt;</code><em>cluster member IP address</em><code>&gt;&quot;</code></p>
<p>Object name starts with <code>ManagementCenter</code> prefix. Then it has the cluster name in brackets followed by a colon. After that, <code>type</code>,<code>name</code> and <code>member</code> attributes follows, each separated with a comma.</p>
<ul>
<li><p><code>type</code> is the type of object. Values are <code>Clients</code>, <code>Executors</code>, <code>Maps</code>, <code>Members</code>, <code>MultiMaps</code>, <code>Queues</code>, <code>Services</code>, and <code>Topics</code>.</p>
</li>
<li><p><code>name</code> is the name of object.</p>
</li>
<li><p><code>member</code> is the node address of object (only required if the statistics are local to the node).</p>
</li>
</ul>
<p>A sample bean is shown below.</p>
<pre><code>ManagementCenter[dev]:type=Services,name=OperationService,member=&quot;192.168.2.79:5701&quot;
</code></pre><p>Below is the list of attributes that are exposed from the Clustered JMX interface.</p>
<ul>
<li><strong>ManagementCenter[ClusterName]</strong></li>
<li>Clients<ul>
<li>Address</li>
<li>ClientType</li>
<li>Uuid</li>
</ul>
</li>
<li>Executors<ul>
<li>Cluster</li>
<li>Name</li>
<li>StartedTaskCount</li>
<li>CompletedTaskCount</li>
<li>CancelledTaskCount</li>
<li>PendingTaskCount</li>
</ul>
</li>
<li>Maps<ul>
<li>Cluster</li>
<li>Name</li>
<li>BackupEntryCount</li>
<li>BackupEntryMemoryCost</li>
<li>CreationTime</li>
<li>DirtyEntryCount</li>
<li>Events</li>
<li>GetOperationCount</li>
<li>HeapCost</li>
<li>Hits</li>
<li>LastAccessTime</li>
<li>LastUpdateTime</li>
<li>LockedEntryCount</li>
<li>MaxGetLatency</li>
<li>MaxPutLatency</li>
<li>MaxRemoveLatency</li>
<li>OtherOperationCount</li>
<li>OwnedEntryCount</li>
<li>PutOperationCount</li>
<li>RemoveOperationCount</li>
</ul>
</li>
<li>Members<ul>
<li>ConnectedClientCount</li>
<li>HeapFreeMemory</li>
<li>HeapMaxMemory</li>
<li>HeapTotalMemory</li>
<li>HeapUsedMemory</li>
<li>IsMaster</li>
<li>OwnedPartitionCount</li>
</ul>
</li>
<li>MultiMaps<ul>
<li>Cluster</li>
<li>Name</li>
<li>BackupEntryCount</li>
<li>BackupEntryMemoryCost</li>
<li>CreationTime</li>
<li>DirtyEntryCount</li>
<li>Events</li>
<li>GetOperationCount</li>
<li>HeapCost</li>
<li>Hits</li>
<li>LastAccessTime</li>
<li>LastUpdateTime</li>
<li>LockedEntryCount</li>
<li>MaxGetLatency</li>
<li>MaxPutLatency</li>
<li>MaxRemoveLatency</li>
<li>OtherOperationCount</li>
<li>OwnedEntryCount</li>
<li>PutOperationCount</li>
<li>RemoveOperationCount</li>
</ul>
</li>
<li>Queues<ul>
<li>Cluster</li>
<li>Name</li>
<li>MinAge</li>
<li>MaxAge</li>
<li>AvgAge</li>
<li>OwnedItemCount</li>
<li>BackupItemCount</li>
<li>OfferOperationCount</li>
<li>OtherOperationsCount</li>
<li>PollOperationCount</li>
<li>RejectedOfferOperationCount</li>
<li>EmptyPollOperationCount</li>
<li>EventOperationCount</li>
<li>CreationTime</li>
</ul>
</li>
<li>Services<ul>
<li>ConnectionManager<ul>
<li>ActiveConnectionCount</li>
<li>ClientConnectionCount</li>
<li>ConnectionCount</li>
</ul>
</li>
<li>EventService<ul>
<li>EventQueueCapacity</li>
<li>EventQueueSize</li>
<li>EventThreadCount</li>
</ul>
</li>
<li>OperationService<ul>
<li>ExecutedOperationCount</li>
<li>OperationExecutorQueueSize</li>
<li>OperationThreadCount</li>
<li>RemoteOperationCount</li>
<li>ResponseQueueSize</li>
<li>RunningOperationsCount</li>
</ul>
</li>
<li>PartitionService<ul>
<li>ActivePartitionCount</li>
<li>PartitionCount</li>
</ul>
</li>
<li>ProxyService<ul>
<li>ProxyCount</li>
</ul>
</li>
<li>ManagedExecutor[hz::async]<ul>
<li>Name</li>
<li>CompletedTaskCount</li>
<li>MaximumPoolSize</li>
<li>PoolSize</li>
<li>QueueSize</li>
<li>RemainingQueueCapacity</li>
<li>Terminated</li>
</ul>
</li>
<li>ManagedExecutor[hz::client]<ul>
<li>Name</li>
<li>CompletedTaskCount</li>
<li>MaximumPoolSize</li>
<li>PoolSize</li>
<li>QueueSize</li>
<li>RemainingQueueCapacity</li>
<li>Terminated</li>
</ul>
</li>
<li>ManagedExecutor[hz::global-operation]<ul>
<li>Name</li>
<li>CompletedTaskCount</li>
<li>MaximumPoolSize</li>
<li>PoolSize</li>
<li>QueueSize</li>
<li>RemainingQueueCapacity</li>
<li>Terminated</li>
</ul>
</li>
<li>ManagedExecutor[hz::io]<ul>
<li>Name</li>
<li>CompletedTaskCount</li>
<li>MaximumPoolSize</li>
<li>PoolSize</li>
<li>QueueSize</li>
<li>RemainingQueueCapacity</li>
<li>Terminated</li>
</ul>
</li>
<li>ManagedExecutor[hz::query]<ul>
<li>Name</li>
<li>CompletedTaskCount</li>
<li>MaximumPoolSize</li>
<li>PoolSize</li>
<li>QueueSize</li>
<li>RemainingQueueCapacity</li>
<li>Terminated</li>
</ul>
</li>
<li>ManagedExecutor[hz::scheduled]<ul>
<li>Name</li>
<li>CompletedTaskCount</li>
<li>MaximumPoolSize</li>
<li>PoolSize</li>
<li>QueueSize</li>
<li>RemainingQueueCapacity</li>
<li>Terminated</li>
</ul>
</li>
<li>ManagedExecutor[hz::system]<ul>
<li>Name</li>
<li>CompletedTaskCount</li>
<li>MaximumPoolSize</li>
<li>PoolSize</li>
<li>QueueSize</li>
<li>RemainingQueueCapacity</li>
<li>Terminated  </li>
</ul>
</li>
</ul>
</li>
<li>Topics<ul>
<li>Cluster</li>
<li>Name</li>
<li>CreationTime</li>
<li>PublishOperationCount</li>
<li>ReceiveOperationCount</li>
</ul>
</li>
</ul>
<h3 id="new-relic-integration">New Relic Integration</h3>
<p>Clustered JMX interface can be used to integrate Hazelcast Management Center with <em>New Relic</em>. In order to perform this, you need to attach New Relic Java agent and provide an extension file that describes which metrics will be sent to New Relic.</p>
<p>Please see <a href="http://docs.newrelic.com/docs/java/custom-jmx-instrumentation-by-yml">Custom JMX instrumentation by YAML</a> on New Relic webpage.</p>
<p>Below is an example Map monitoring <code>.yml</code> file for New Relic.</p>
<pre><code class="lang-plain">name: Clustered JMX
version: 1.0
enabled: true

jmx:
  - object_name: ManagementCenter[clustername]:type=Maps,name=mapname
    metrics:
      - attributes: PutOperationCount, GetOperationCount, RemoveOperationCount, Hits,\ 
            BackupEntryCount, OwnedEntryCount, LastAccessTime, LastUpdateTime
        type: simple
  - object_name: ManagementCenter[clustername]:type=Members,name=&quot;node address in\
        double quotes&quot;
    metrics:
      - attributes: OwnedPartitionCount
        type: simple
</code></pre>
<p>You should put the <code>.yml</code> file under the <code>extensions</code> folder in your New Relic installation. If that folder does not exist, please create one.</p>
<p>After you set your extension, you can attach New Relic Java agent and start Management Center as shown below.</p>
<pre><code class="lang-plain">java -javaagent:/path/to/newrelic.jar -Dhazelcast.mc.jmx.enabled=true\
    -Dhazelcast.mc.jmx.port=9999 -jar mancenter-3.3.jar
</code></pre>
<p>Once started and if your logging level is set as FINER, you should see the logs  similar to below in the file <code>newrelic_agent.log</code>, which is located at <code>logs</code> folder in your New Relic installation.</p>
<pre><code class="lang-plain">Jun 5, 2014 14:18:43 +0300 [72696 62] com.newrelic.agent.jmx.JmxService FINE:
    JMX Service : querying MBeans (1)
Jun 5, 2014 14:18:43 +0300 [72696 62] com.newrelic.agent.jmx.JmxService FINER:
    JMX Service : MBeans query ManagementCenter[dev]:type=Members,
    name=&quot;192.168.2.79:5701&quot;, matches 1
Jun 5, 2014 14:18:43 +0300 [72696 62] com.newrelic.agent.jmx.JmxService FINER:
    Recording JMX metric OwnedPartitionCount : 68
Jun 5, 2014 14:18:43 +0300 [72696 62] com.newrelic.agent.jmx.JmxService FINER:
    JMX Service : MBeans query ManagementCenter[dev]:type=Maps,name=orders, 
    matches 1
Jun 5, 2014 14:18:43 +0300 [72696 62] com.newrelic.agent.jmx.JmxService FINER: 
    Recording JMX metric Hits : 46,593
Jun 5, 2014 14:18:43 +0300 [72696 62] com.newrelic.agent.jmx.JmxService FINER: 
    Recording JMX metric BackupEntryCount : 1,100
Jun 5, 2014 14:18:43 +0300 [72696 62] com.newrelic.agent.jmx.JmxService FINER: 
    Recording JMX metric OwnedEntryCount : 1,100
Jun 5, 2014 14:18:43 +0300 [72696 62] com.newrelic.agent.jmx.JmxService FINER: 
    Recording JMX metric RemoveOperationCount : 0
Jun 5, 2014 14:18:43 +0300 [72696 62] com.newrelic.agent.jmx.JmxService FINER: 
    Recording JMX metric PutOperationCount : 118,962
Jun 5, 2014 14:18:43 +0300 [72696 62] com.newrelic.agent.jmx.JmxService FINER: 
    Recording JMX metric GetOperationCount : 0
Jun 5, 2014 14:18:43 +0300 [72696 62] com.newrelic.agent.jmx.JmxService FINER: 
    Recording JMX metric LastUpdateTime : 1,401,962,426,811
Jun 5, 2014 14:18:43 +0300 [72696 62] com.newrelic.agent.jmx.JmxService FINER: 
    Recording JMX metric LastAccessTime : 1,401,962,426,811
</code></pre>
<p>Then, you can navigate to your New Relic account and create Custom Dashboards. Please see <a href="http://docs.newrelic.com/docs/dashboards-menu/creating-custom-dashboards">Creating custom dashboards</a> on creating one.</p>
<p>While you are creating the dashboard, you should see the metrics that you are sending to New Relic from Management Center in the <strong>Metrics</strong> section under the JMX folder.</p>
<h3 id="appdynamics-integration">AppDynamics Integration</h3>
<p>Clustered JMX interface can be used to integrate Hazelcast Management Center with <em>AppDynamics</em>. In order to perform this, you need to attach AppDynamics Java agent to the Management Center.</p>
<p>For agent installation, you can refer to <a href="http://docs.appdynamics.com/display/PRO14S/Install+the+App+Agent+for+Java">Install the App Agent for Java</a> page.</p>
<p>For monitoring on AppDynamics, please see <a href="http://docs.appdynamics.com/display/PRO14S/Monitor+JMX+MBeans#MonitorJMXMBeans-UsingAppDynamicsforJMXMonitoring">Using AppDynamics for JMX Monitoring</a> page.</p>
<p>After installing AppDynamics agent, you can start Management Center as shown below.</p>
<pre><code class="lang-plain">java -javaagent:/path/to/javaagent.jar -Dhazelcast.mc.jmx.enabled=true\
    -Dhazelcast.mc.jmx.port=9999 -jar mancenter-3.3.jar
</code></pre>
<p>Once started, you should see the below logs.</p>
<pre><code class="lang-plain">Started AppDynamics Java Agent Successfully.
Hazelcast Management Center starting on port 8080 at path : /mancenter
</code></pre>
<p><br></br></p>
<h2 id="clustered-rest">Clustered REST</h2>
<p><img src="images/enterprise-onlycopy.jpg" alt=""></p>
<p>Clustered REST API is exposed from Management Center to allow you to monitor clustered statistics of distributed objects.</p>
<h3 id="enabling-clustered-rest">Enabling Clustered REST</h3>
<p>In order to enable Clustered REST on your Management Center, you need to pass the following system property at startup. This feature is disabled by default.</p>
<pre><code class="lang-plain">-Dhazelcast.mc.rest.enabled=true
</code></pre>
<h3 id="clustered-rest-api-root">Clustered REST API Root</h3>
<p>Entry point for Clustered REST API is <code>/rest/</code>.</p>
<p>This resource does not have any attributes</p>
<h3 id="clusters-resource">Clusters Resource</h3>
<p>This resource returns list of clusters that are connected to the Management Center.</p>
<h5 id="retrieve-clusters">Retrieve Clusters</h5>
<ul>
<li><em>Request Type:</em> GET</li>
<li><em>URL:</em> <code>/rest/clusters</code></li>
<li><p><em>Request:</em></p>
<pre><code class="lang-plain">  curl http://localhost:8083/mancenter/rest/clusters
</code></pre>
</li>
<li><em>Response:</em> <code>200</code> (application/json)</li>
<li><p><em>Body:</em></p>
<pre><code class="lang-json">  [&quot;dev&quot;,&quot;qa&quot;]
</code></pre>
</li>
</ul>
<h3 id="cluster-resource">Cluster Resource</h3>
<p>This resource returns information related to provided cluster name.</p>
<h5 id="retrieve-cluster-information">Retrieve Cluster Information</h5>
<ul>
<li><em>Request Type:</em> GET</li>
<li><em>URL:</em> <code>/rest/clusters/{clustername}</code></li>
<li><p><em>Request:</em></p>
<pre><code class="lang-plain">  curl http://localhost:8083/mancenter/rest/clusters/dev/
</code></pre>
</li>
<li><em>Response:</em> <code>200</code> (application/json)</li>
<li><p><em>Body:</em></p>
<pre><code class="lang-json">  {&quot;masterAddress&quot;:&quot;192.168.2.78:5701&quot;}
</code></pre>
</li>
</ul>
<h3 id="members-resource">Members Resource</h3>
<p>This resource returns list of members belonging to provided clusters.</p>
<h5 id="retrieve-members-get-rest-clusters-clustername-members-">Retrieve Members [GET] [/rest/clusters/{clustername}/members]</h5>
<ul>
<li><em>Request Type:</em> GET</li>
<li><em>URL:</em> <code>/rest/clusters/{clustername}/members</code></li>
<li><p><em>Request:</em></p>
<pre><code class="lang-plain">  curl http://localhost:8083/mancenter/rest/clusters/dev/members
</code></pre>
</li>
<li><em>Response:</em> <code>200</code> (application/json)</li>
<li><p><em>Body:</em></p>
<pre><code class="lang-json">  [&quot;192.168.2.78:5701&quot;,&quot;192.168.2.78:5702&quot;,&quot;192.168.2.78:5703&quot;,&quot;192.168.2.78:5704&quot;]
</code></pre>
</li>
</ul>
<h3 id="member-resource">Member Resource</h3>
<p>This resource returns information related to provided member.</p>
<h5 id="retrieve-member-information">Retrieve Member Information</h5>
<ul>
<li><em>Request Type:</em> GET</li>
<li><em>URL:</em> <code>/rest/clusters/{clustername}/members/{member}</code></li>
<li><p><em>Request:</em></p>
<pre><code class="lang-plain">  curl http://localhost:8083/mancenter/rest/clusters/dev/members/192.168.2.78:5701
</code></pre>
</li>
<li><em>Response:</em> <code>200</code> (application/json)</li>
<li><p><em>Body:</em></p>
<pre><code class="lang-json">  {
    &quot;cluster&quot;:&quot;dev&quot;,
    &quot;name&quot;:&quot;192.168.2.78:5701&quot;,
    &quot;maxMemory&quot;:129957888,
    &quot;ownedPartitionCount&quot;:68,
    &quot;usedMemory&quot;:60688784,
    &quot;freeMemory&quot;:24311408,
    &quot;totalMemory&quot;:85000192,
    &quot;connectedClientCount&quot;:1,
    &quot;master&quot;:true
  }
</code></pre>
</li>
</ul>
<h5 id="retrieve-connection-manager-information">Retrieve Connection Manager Information</h5>
<ul>
<li><em>Request Type:</em> GET</li>
<li><em>URL:</em> <code>/rest/clusters/{clustername}/members/{member}/connectionManager</code></li>
<li><p><em>Request:</em></p>
<pre><code class="lang-plain">  curl http://localhost:8083/mancenter/rest/clusters/dev/members/192.168.2.78:5701/connectionManager
</code></pre>
</li>
<li><em>Response:</em> <code>200</code> (application/json)</li>
<li><p><em>Body:</em></p>
<pre><code class="lang-json">  {
    &quot;clientConnectionCount&quot;:2,
    &quot;activeConnectionCount&quot;:5,
    &quot;connectionCount&quot;:5
  }
</code></pre>
</li>
</ul>
<h5 id="retrieve-operation-service-information">Retrieve Operation Service Information</h5>
<ul>
<li><em>Request Type:</em> GET</li>
<li><em>URL:</em> <code>/rest/clusters/{clustername}/members/{member}/operationService</code></li>
<li><p><em>Request:</em></p>
<pre><code class="lang-plain">  curl http://localhost:8083/mancenter/rest/clusters/dev/members/192.168.2.78:5701/operationService
</code></pre>
</li>
<li><em>Response:</em> <code>200</code> (application/json)</li>
<li><p><em>Body:</em></p>
<pre><code class="lang-json">  {
    &quot;responseQueueSize&quot;:0,
    &quot;operationExecutorQueueSize&quot;:0,
    &quot;runningOperationsCount&quot;:0,
    &quot;remoteOperationCount&quot;:1,
    &quot;executedOperationCount&quot;:461139,
    &quot;operationThreadCount&quot;:8
  }
</code></pre>
</li>
</ul>
<h5 id="retrieve-event-service-information">Retrieve Event Service Information</h5>
<ul>
<li><em>Request Type:</em> GET</li>
<li><em>URL:</em> <code>/rest/clusters/{clustername}/members/{member}/eventService</code></li>
<li><p><em>Request:</em></p>
<pre><code class="lang-plain">  curl http://localhost:8083/mancenter/rest/clusters/dev/members/192.168.2.78:5701/eventService
</code></pre>
</li>
<li><em>Response:</em> <code>200</code> (application/json)</li>
<li><p><em>Body:</em></p>
<pre><code class="lang-json">  {
    &quot;eventThreadCount&quot;:5,
    &quot;eventQueueCapacity&quot;:1000000,
    &quot;eventQueueSize&quot;:0
  }
</code></pre>
</li>
</ul>
<h5 id="retrieve-partition-service-information">Retrieve Partition Service Information</h5>
<ul>
<li><em>Request Type:</em> GET</li>
<li><em>URL:</em> <code>/rest/clusters/{clustername}/members/{member}/partitionService</code></li>
<li><p><em>Request:</em></p>
<pre><code class="lang-plain">  curl http://localhost:8083/mancenter/rest/clusters/dev/members/192.168.2.78:5701/partitionService
</code></pre>
</li>
<li><em>Response:</em> <code>200</code> (application/json)</li>
<li><p><em>Body:</em></p>
<pre><code class="lang-json">  {
    &quot;partitionCount&quot;:271,
    &quot;activePartitionCount&quot;:68
  }
</code></pre>
</li>
</ul>
<h5 id="retrieve-proxy-service-information">Retrieve Proxy Service Information</h5>
<ul>
<li><em>Request Type:</em> GET</li>
<li><em>URL:</em> <code>/rest/clusters/{clustername}/members/{member}/proxyService</code></li>
<li><p><em>Request:</em></p>
<pre><code class="lang-plain">  curl http://localhost:8083/mancenter/rest/clusters/dev/members/192.168.2.78:5701/proxyService
</code></pre>
</li>
<li><em>Response:</em> <code>200</code> (application/json)</li>
<li><p><em>Body:</em></p>
<pre><code class="lang-json">  {
    &quot;proxyCount&quot;:8
  }
</code></pre>
</li>
</ul>
<h5 id="retrieve-all-managed-executors">Retrieve All Managed Executors</h5>
<ul>
<li><em>Request Type:</em> GET</li>
<li><em>URL:</em> <code>/rest/clusters/{clustername}/members/{member}/managedExecutors</code></li>
<li><p><em>Request:</em></p>
<pre><code class="lang-plain">  curl http://localhost:8083/mancenter/rest/clusters/dev/members/192.168.2.78:5701/managedExecutors
</code></pre>
</li>
<li><em>Response:</em> <code>200</code> (application/json)</li>
<li><p><em>Body:</em></p>
<pre><code class="lang-json">  [&quot;hz:system&quot;,&quot;hz:scheduled&quot;,&quot;hz:client&quot;,&quot;hz:query&quot;,&quot;hz:io&quot;,&quot;hz:async&quot;]
</code></pre>
</li>
</ul>
<h5 id="retrieve-a-managed-executor">Retrieve a Managed Executor</h5>
<ul>
<li><em>Request Type:</em> GET</li>
<li><em>URL:</em> <code>/rest/clusters/{clustername}/members/{member}/managedExecutors/{managedExecutor}</code></li>
<li><p><em>Request:</em></p>
<pre><code class="lang-plain">  curl http://localhost:8083/mancenter/rest/clusters/dev/members/192.168.2.78:5701
    /managedExecutors/hz:system
</code></pre>
</li>
<li><em>Response:</em> <code>200</code> (application/json)</li>
<li><p><em>Body:</em></p>
<pre><code class="lang-json">  {
    &quot;name&quot;:&quot;hz:system&quot;,
    &quot;queueSize&quot;:0,
    &quot;poolSize&quot;:0,
    &quot;remainingQueueCapacity&quot;:2147483647,
    &quot;maximumPoolSize&quot;:4,
    &quot;completedTaskCount&quot;:12,
    &quot;terminated&quot;:false
  }
</code></pre>
</li>
</ul>
<h3 id="clients-resource">Clients Resource</h3>
<p>This resource returns list of clients belonging to provided cluster.</p>
<h5 id="retrieve-list-of-clients">Retrieve List of Clients</h5>
<ul>
<li><em>Request Type:</em> GET</li>
<li><em>URL:</em> <code>/rest/clusters/{clustername}/clients</code></li>
<li><p><em>Request:</em></p>
<pre><code class="lang-plain">  curl http://localhost:8083/mancenter/rest/clusters/dev/clients
</code></pre>
</li>
<li><em>Response:</em> <code>200</code> (application/json)</li>
<li><p><em>Body:</em></p>
<pre><code class="lang-json">  [&quot;192.168.2.78:61708&quot;]
</code></pre>
</li>
</ul>
<h5 id="retrieve-client-information">Retrieve Client Information</h5>
<ul>
<li><em>Request Type:</em> GET</li>
<li><em>URL:</em> <code>/rest/clusters/{clustername}/clients/{client}</code></li>
<li><p><em>Request:</em></p>
<pre><code class="lang-plain">  curl http://localhost:8083/mancenter/rest/clusters/dev/clients/192.168.2.78:61708
</code></pre>
</li>
<li><em>Response:</em> <code>200</code> (application/json)</li>
<li><p><em>Body:</em></p>
<pre><code class="lang-json">  {
    &quot;uuid&quot;:&quot;6fae7af6-7a7c-4fa5-b165-cde24cf070f5&quot;,
    &quot;address&quot;:&quot;192.168.2.78:61708&quot;,
    &quot;clientType&quot;:&quot;JAVA&quot;
  }
</code></pre>
</li>
</ul>
<h3 id="maps-resource">Maps Resource</h3>
<p>This resource returns list of maps belonging to provided cluster.</p>
<h5 id="retrieve-list-of-maps">Retrieve List of Maps</h5>
<ul>
<li><em>Request Type:</em> GET</li>
<li><em>URL:</em> <code>/rest/clusters/{clustername}/maps</code></li>
<li><p><em>Request:</em></p>
<pre><code class="lang-plain">  curl http://localhost:8083/mancenter/rest/clusters/dev/maps
</code></pre>
</li>
<li><em>Response:</em> <code>200</code> (application/json)</li>
<li><p><em>Body:</em></p>
<pre><code class="lang-json">  [&quot;customers&quot;,&quot;orders&quot;]
</code></pre>
</li>
</ul>
<h5 id="retrieve-map-information">Retrieve Map Information</h5>
<ul>
<li><em>Request Type:</em> GET</li>
<li><em>URL:</em> <code>/rest/clusters/{clustername}/maps/{mapName}</code></li>
<li><p><em>Request:</em></p>
<pre><code class="lang-plain">  curl http://localhost:8083/mancenter/rest/clusters/dev/maps/customers
</code></pre>
</li>
<li><em>Response:</em> <code>200</code> (application/json)</li>
<li><p><em>Body:</em></p>
<pre><code class="lang-json">  {
    &quot;cluster&quot;:&quot;dev&quot;,
    &quot;name&quot;:&quot;customers&quot;,
    &quot;ownedEntryCount&quot;:1000,
    &quot;backupEntryCount&quot;:1000,
    &quot;ownedEntryMemoryCost&quot;:157890,
    &quot;backupEntryMemoryCost&quot;:113683,
    &quot;heapCost&quot;:297005,
    &quot;lockedEntryCount&quot;:0,
    &quot;dirtyEntryCount&quot;:0,
    &quot;hits&quot;:3001,
    &quot;lastAccessTime&quot;:1403608925777,
    &quot;lastUpdateTime&quot;:1403608925777,
    &quot;creationTime&quot;:1403602693388,
    &quot;putOperationCount&quot;:110630,
    &quot;getOperationCount&quot;:165945,
    &quot;removeOperationCount&quot;:55315,
    &quot;otherOperationCount&quot;:0,
    &quot;events&quot;:0,
    &quot;maxPutLatency&quot;:52,
    &quot;maxGetLatency&quot;:30,
    &quot;maxRemoveLatency&quot;:21
  }
</code></pre>
</li>
</ul>
<h3 id="multimaps-resource">MultiMaps Resource</h3>
<p>This resource returns list of multimaps belonging to provided cluster.</p>
<h5 id="retrieve-list-of-multimaps">Retrieve List of MultiMaps</h5>
<ul>
<li><em>Request Type:</em> GET</li>
<li><em>URL:</em> <code>/rest/clusters/{clustername}/multimaps</code></li>
<li><p><em>Request:</em></p>
<pre><code class="lang-plain">  curl http://localhost:8083/mancenter/rest/clusters/dev/multimaps
</code></pre>
</li>
<li><em>Response:</em> <code>200</code> (application/json)</li>
<li><p><em>Body:</em></p>
<pre><code class="lang-json">  [&quot;customerAddresses&quot;]
</code></pre>
</li>
</ul>
<h5 id="retrieve-multimap-information">Retrieve MultiMap Information</h5>
<ul>
<li><em>Request Type:</em> GET</li>
<li><em>URL:</em> <code>/rest/clusters/{clustername}/multimaps/{multimapname}</code></li>
<li><p><em>Request:</em></p>
<pre><code class="lang-plain">  curl http://localhost:8083/mancenter/rest/clusters/dev/multimaps/customerAddresses
</code></pre>
</li>
<li><em>Response:</em> <code>200</code> (application/json)</li>
<li><p><em>Body:</em></p>
<pre><code class="lang-json">  {
    &quot;cluster&quot;:&quot;dev&quot;,
    &quot;name&quot;:&quot;customerAddresses&quot;,
    &quot;ownedEntryCount&quot;:996,
    &quot;backupEntryCount&quot;:996,
    &quot;ownedEntryMemoryCost&quot;:0,
    &quot;backupEntryMemoryCost&quot;:0,
    &quot;heapCost&quot;:0,
    &quot;lockedEntryCount&quot;:0,
    &quot;dirtyEntryCount&quot;:0,
    &quot;hits&quot;:0,
    &quot;lastAccessTime&quot;:1403603095521,
    &quot;lastUpdateTime&quot;:1403603095521,
    &quot;creationTime&quot;:1403602694158,
    &quot;putOperationCount&quot;:166041,
    &quot;getOperationCount&quot;:110694,
    &quot;removeOperationCount&quot;:55347,
    &quot;otherOperationCount&quot;:0,
    &quot;events&quot;:0,
    &quot;maxPutLatency&quot;:77,
    &quot;maxGetLatency&quot;:69,
    &quot;maxRemoveLatency&quot;:42
  }
</code></pre>
</li>
</ul>
<h3 id="queues-resource">Queues Resource</h3>
<p>This resource returns list of queues belonging to provided cluster.</p>
<h5 id="retrieve-list-of-queues">Retrieve List of Queues</h5>
<ul>
<li><em>Request Type:</em> GET</li>
<li><em>URL:</em> <code>/rest/clusters/{clustername}/queues</code></li>
<li><p><em>Request:</em></p>
<pre><code class="lang-plain">  curl http://localhost:8083/mancenter/rest/clusters/dev/queues
</code></pre>
</li>
<li><em>Response:</em> <code>200</code> (application/json)</li>
<li><p><em>Body:</em></p>
<pre><code class="lang-json">  [&quot;messages&quot;]
</code></pre>
</li>
</ul>
<h5 id="retrieve-queue-information">Retrieve Queue Information</h5>
<ul>
<li><em>Request Type:</em> GET</li>
<li><em>URL:</em> <code>/rest/clusters/{clustername}/queues/{queueName}</code></li>
<li><p><em>Request:</em></p>
<pre><code class="lang-plain">  curl http://localhost:8083/mancenter/rest/clusters/dev/queues/messages
</code></pre>
</li>
<li><em>Response:</em> <code>200</code> (application/json)</li>
<li><p><em>Body:</em></p>
<pre><code class="lang-json">  {
    &quot;cluster&quot;:&quot;dev&quot;,
    &quot;name&quot;:&quot;messages&quot;,
    &quot;ownedItemCount&quot;:55408,
    &quot;backupItemCount&quot;:55408,
    &quot;minAge&quot;:0,
    &quot;maxAge&quot;:0,
    &quot;aveAge&quot;:0,
    &quot;numberOfOffers&quot;:55408,
    &quot;numberOfRejectedOffers&quot;:0,
    &quot;numberOfPolls&quot;:0,
    &quot;numberOfEmptyPolls&quot;:0,
    &quot;numberOfOtherOperations&quot;:0,
    &quot;numberOfEvents&quot;:0,
    &quot;creationTime&quot;:1403602694196
  }
</code></pre>
</li>
</ul>
<h3 id="topics-resource">Topics Resource</h3>
<p>This resource returns list of topics belonging to provided cluster.</p>
<h5 id="retrieve-list-of-topics">Retrieve List of Topics</h5>
<ul>
<li><em>Request Type:</em> GET</li>
<li><em>URL:</em> <code>/rest/clusters/{clustername}/topics</code></li>
<li><p><em>Request:</em></p>
<pre><code class="lang-plain">  curl http://localhost:8083/mancenter/rest/clusters/dev/topics
</code></pre>
</li>
<li><em>Response:</em> <code>200</code> (application/json)</li>
<li><p><em>Body:</em></p>
<pre><code class="lang-json">  [&quot;news&quot;]
</code></pre>
</li>
</ul>
<h5 id="retrieve-topic-information">Retrieve Topic Information</h5>
<ul>
<li><em>Request Type:</em> GET</li>
<li><em>URL:</em> <code>/rest/clusters/{clustername}/topics/{topicName}</code></li>
<li><p><em>Request:</em></p>
<pre><code class="lang-plain">  curl http://localhost:8083/mancenter/rest/clusters/dev/topics/news
</code></pre>
</li>
<li><em>Response:</em> <code>200</code> (application/json)</li>
<li><p><em>Body:</em></p>
<pre><code class="lang-json">  {
    &quot;cluster&quot;:&quot;dev&quot;,
    &quot;name&quot;:&quot;news&quot;,
    &quot;numberOfPublishes&quot;:56370,
    &quot;totalReceivedMessages&quot;:56370,
    &quot;creationTime&quot;:1403602693411
  }
</code></pre>
</li>
</ul>
<h3 id="executors-resource">Executors Resource</h3>
<p>This resource returns list of executors belonging to provided cluster.</p>
<h5 id="retrieve-list-of-executors">Retrieve List of Executors</h5>
<ul>
<li><em>Request Type:</em> GET</li>
<li><em>URL:</em> <code>/rest/clusters/{clustername}/executors</code></li>
<li><p><em>Request:</em></p>
<pre><code class="lang-plain">  curl http://localhost:8083/mancenter/rest/clusters/dev/executors
</code></pre>
</li>
<li><em>Response:</em> <code>200</code> (application/json)</li>
<li><p><em>Body:</em></p>
<pre><code class="lang-json">  [&quot;order-executor&quot;]
</code></pre>
</li>
</ul>
<h5 id="retrieve-executor-information-get-rest-clusters-clustername-executors-executorname-">Retrieve Executor Information [GET] [/rest/clusters/{clustername}/executors/{executorName}]</h5>
<ul>
<li><em>Request Type:</em> GET</li>
<li><em>URL:</em> <code>/rest/clusters/{clustername}/executors/{executorName}</code></li>
<li><p><em>Request:</em></p>
<pre><code class="lang-plain">  curl http://localhost:8083/mancenter/rest/clusters/dev/executors/order-executor
</code></pre>
</li>
<li><em>Response:</em> <code>200</code> (application/json)</li>
<li><p><em>Body:</em></p>
<pre><code class="lang-json">  {
    &quot;cluster&quot;:&quot;dev&quot;,
    &quot;name&quot;:&quot;order-executor&quot;,
    &quot;creationTime&quot;:1403602694196,
    &quot;pendingTaskCount&quot;:0,
    &quot;startedTaskCount&quot;:1241,
    &quot;completedTaskCount&quot;:1241,
    &quot;cancelledTaskCount&quot;:0
  }
</code></pre>
</li>
</ul>
<h1 id="security">Security</h1>
<h2 id="enabling-security-for-hazelcast-enterprise">Enabling Security for Hazelcast Enterprise</h2>
<p><img src="images/enterprise-onlycopy.jpg" alt=""></p>
<p>Hazelcast has an extensible, JAAS based security feature which can be used to authenticate both cluster members and clients and to perform access control checks on client operations. Access control can be done according to endpoint principal and/or endpoint address. </p>
<p>Security can be enabled as stated in the below programmatic or declarative configuration.</p>
<pre><code class="lang-xml">&lt;hazelcast xsi:schemaLocation=&quot;http://www.hazelcast.com/schema/config
    http://www.hazelcast.com/schema/config/hazelcast-config-3.3.xsd&quot;
    xmlns=&quot;http://www.hazelcast.com/schema/config&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&gt;

  ...

  &lt;security enabled=&quot;true&quot;&gt;
    ...
  &lt;/security&gt;
&lt;/hazelcast&gt;
</code></pre>
<pre><code class="lang-java">Config cfg = new Config();
SecurityConfig securityCfg = cfg.getSecurityConfig();
securityCfg.setEnabled( true );
</code></pre>
<p>Also, please see <a href="#setting-the-license-key-for-hazelcast-enterprise">Setting License Key</a>.</p>
<h2 id="socket-interceptor">Socket Interceptor</h2>
<p><img src="images/enterprise-onlycopy.jpg" alt=""></p>
<p>Hazelcast allows you to intercept socket connections before a node joins to cluster or a client connects to a node. This provides ability to add custom hooks to join/connection procedure (like identity checking using Kerberos, etc.). You should implement <code>com.hazelcast.nio.MemberSocketInterceptor</code> for members and <code>com.hazelcast.nio.SocketInterceptor</code> for clients.</p>
<pre><code class="lang-java">public class MySocketInterceptor implements MemberSocketInterceptor {
  public void init( SocketInterceptorConfig socketInterceptorConfig ) {
    // initialize interceptor
  }

  void onConnect( Socket connectedSocket ) throws IOException {
    // do something meaningful when connected
  }

  public void onAccept( Socket acceptedSocket ) throws IOException {
    // do something meaningful when accepted a connection
  }
}
</code></pre>
<pre><code class="lang-xml">&lt;hazelcast&gt;
  ...
  &lt;network&gt;
    ...
    &lt;socket-interceptor enabled=&quot;true&quot;&gt;
      &lt;class-name&gt;com.hazelcast.examples.MySocketInterceptor&lt;/class-name&gt;
      &lt;properties&gt;
        &lt;property name=&quot;kerberos-host&quot;&gt;kerb-host-name&lt;/property&gt;
        &lt;property name=&quot;kerberos-config-file&quot;&gt;kerb.conf&lt;/property&gt;
      &lt;/properties&gt;
    &lt;/socket-interceptor&gt;
  &lt;/network&gt;
  ...
&lt;/hazelcast&gt;
</code></pre>
<pre><code class="lang-java">public class MyClientSocketInterceptor implements SocketInterceptor {
  void onConnect( Socket connectedSocket ) throws IOException {
    // do something meaningful when connected
  }
}

ClientConfig clientConfig = new ClientConfig();
clientConfig.setGroupConfig( new GroupConfig( &quot;dev&quot;, &quot;dev-pass&quot; ) )
    .addAddress( &quot;10.10.3.4&quot; );

MyClientSocketInterceptor clientSocketInterceptor = new MyClientSocketInterceptor();
clientConfig.setSocketInterceptor( clientSocketInterceptor );
HazelcastInstance client = HazelcastClient.newHazelcastClient( clientConfig );
</code></pre>
<h2 id="security-interceptor">Security Interceptor</h2>
<p><img src="images/enterprise-onlycopy.jpg" alt=""></p>
<p>Hazelcast allows you to intercept every remote operation executed by the client. This provides ability to add a very flexible custom security logic. You should implement <code>com.hazelcast.security.SecurityInterceptor</code></p>
<pre><code class="lang-java">public class MySecurityInterceptor implements SecurityInterceptor {

  public void before( Credentials credentials, String serviceName,
                      String methodName, Parameters parameters )
      throws AccessControlException {
    // credentials: client credentials 
    // serviceName: MapService.SERVICE_NAME, QueueService.SERVICE_NAME, ... etc
    // methodName: put, get, offer, poll, ... etc
    // parameters: holds parameters of the executed method, iterable.
  }

  public void after( Credentials credentials, String serviceName,
                     String methodName, Parameters parameters ) {
    // can be used for logging etc.
  }
}
</code></pre>
<p><code>before</code> method will be called before processing the request on the remote server and <code>after</code> method will be called after the processing. Any exception thrown while executing <code>before</code> method will propagate to client but exceptions thrown while executing <code>after</code> method will be suppressed.  </p>
<h2 id="encryption">Encryption</h2>
<p><img src="images/enterprise-onlycopy.jpg" alt=""></p>
<p>Hazelcast allows you to encrypt entire socket level communication among all Hazelcast members. Encryption is based on <a href="http://java.sun.com/javase/6/docs/technotes/guides/security/crypto/CryptoSpec.html">Java Cryptography Architecture</a>. In symmetric encryption, each node uses the same key, so the key is shared. Here is a sample configuration for symmetric encryption:</p>
<pre><code class="lang-xml">&lt;hazelcast&gt;
  ...
  &lt;network&gt;
    ...
    &lt;!--
      Make sure to set enabled=true
      Make sure this configuration is exactly the same on
      all members
    --&gt;
    &lt;symmetric-encryption enabled=&quot;true&quot;&gt;
      &lt;!--
        encryption algorithm such as
        DES/ECB/PKCS5Padding,
        PBEWithMD5AndDES,
        Blowfish,
        DESede
      --&gt;
      &lt;algorithm&gt;PBEWithMD5AndDES&lt;/algorithm&gt;

      &lt;!-- salt value to use when generating the secret key --&gt;
      &lt;salt&gt;thesalt&lt;/salt&gt;

      &lt;!-- pass phrase to use when generating the secret key --&gt;
      &lt;password&gt;thepass&lt;/password&gt;

      &lt;!-- iteration count to use when generating the secret key --&gt;
      &lt;iteration-count&gt;19&lt;/iteration-count&gt;
    &lt;/symmetric-encryption&gt;
  &lt;/network&gt;
  ...
&lt;/hazelcast&gt;
</code></pre>
<p><br> </br></p>
<p><strong><em>RELATED INFORMATION</em></strong></p>
<p><em>Please see <a href="#ssl">SSL</a>.</em></p>
<h2 id="ssl">SSL</h2>
<p><img src="images/enterprise-onlycopy.jpg" alt=""></p>
<p>Hazelcast allows you to use SSL socket communication among all Hazelcast members. You need to implement <code>com.hazelcast.nio.ssl.SSLContextFactory</code> and configure SSL section in network configuration.</p>
<pre><code class="lang-java">public class MySSLContextFactory implements SSLContextFactory {
  public void init( Properties properties ) throws Exception {
  }

  public SSLContext getSSLContext() {
    ...
    SSLContext sslCtx = SSLContext.getInstance( protocol );
    return sslCtx;
  }
}
</code></pre>
<pre><code class="lang-xml">&lt;hazelcast&gt;
  ...
  &lt;network&gt;
    ...
    &lt;ssl enabled=&quot;true&quot;&gt;
      &lt;factory-class-name&gt;
          com.hazelcast.examples.MySSLContextFactory
      &lt;/factory-class-name&gt;
      &lt;properties&gt;
        &lt;property name=&quot;foo&quot;&gt;bar&lt;/property&gt;
      &lt;/properties&gt;
    &lt;/ssl&gt;
  &lt;/network&gt;
  ...
&lt;/hazelcast&gt;
</code></pre>
<p>Hazelcast provides a default SSLContextFactory; <code>com.hazelcast.nio.ssl.BasicSSLContextFactory</code> which uses configured keystore to initialize <code>SSLContext</code>. Just define <code>keyStore</code> and <code>keyStorePassword</code>, and also you can set <code>keyManagerAlgorithm</code> (default <code>SunX509</code>), <code>trustManagerAlgorithm</code> (default <code>SunX509</code>) and <code>protocol</code> (default <code>TLS</code>).</p>
<pre><code class="lang-xml">&lt;hazelcast&gt;
  ...
  &lt;network&gt;
    ...
    &lt;ssl enabled=&quot;true&quot;&gt;
      &lt;factory-class-name&gt;
          com.hazelcast.nio.ssl.BasicSSLContextFactory
      &lt;/factory-class-name&gt;
      &lt;properties&gt;
        &lt;property name=&quot;keyStore&quot;&gt;keyStore&lt;/property&gt;
        &lt;property name=&quot;keyStorePassword&quot;&gt;keyStorePassword&lt;/property&gt;
        &lt;property name=&quot;keyManagerAlgorithm&quot;&gt;SunX509&lt;/property&gt;
        &lt;property name=&quot;trustManagerAlgorithm&quot;&gt;SunX509&lt;/property&gt;
        &lt;property name=&quot;protocol&quot;&gt;TLS&lt;/property&gt;
      &lt;/properties&gt;
    &lt;/ssl&gt;
  &lt;/network&gt;
  ...
&lt;/hazelcast&gt;
</code></pre>
<p>Hazelcast client has SSL support too. Client SSL configuration can be defined using programmatic configuration as shown below.</p>
<pre><code class="lang-java">Properties props = new Properties();
...
ClientConfig config = new ClientConfig();
config.getSocketOptions().setSocketFactory( new SSLSocketFactory( props ) );
</code></pre>
<p>You can also set <code>keyStore</code> and <code>keyStorePassword</code> through the following system properties:</p>
<ul>
<li><code>javax.net.ssl.keyStore</code></li>
<li><code>javax.net.ssl.keyStorePassword</code> </li>
</ul>
<p><img src="images/NoteSmall.jpg" alt="image"> <strong><em>NOTE:</em></strong> <em>You cannot use SSL when <a href="#encryption">Hazelcast Encryption</a> is enabled.</em></p>
<h2 id="credentials">Credentials</h2>
<p><img src="images/enterprise-onlycopy.jpg" alt=""></p>
<p>One of the key elements in Hazelcast security is <code>Credentials</code> object. It is used to carry all credentials of an endpoint (member or client). Credentials is an interface which extends <code>Serializable</code> and has three methods to be implemented. The users can either implement <code>Credentials</code> interface or extend <code>AbstractCredentials</code> class, which is an abstract implementation of <code>Credentials</code>, according to their needs.</p>
<pre><code class="lang-java">package com.hazelcast.security;
public interface Credentials extends Serializable {
  String getEndpoint();
  void setEndpoint( String endpoint ) ;    
  String getPrincipal() ;    
}
</code></pre>
<p><code>Credentials.setEndpoint()</code> method is called by Hazelcast when authentication request arrives to node before authentication takes place.</p>
<pre><code class="lang-java">package com.hazelcast.security;
...
public abstract class AbstractCredentials implements Credentials, DataSerializable {
  private transient String endpoint;
  private String principal;
  ...
}
</code></pre>
<p><code>UsernamePasswordCredentials</code>, a custom implementation of Credentials can be found in Hazelcast <code>com.hazelcast.security</code> package. It is used by default configuration during authentication process of both members and clients.</p>
<pre><code class="lang-java">package com.hazelcast.security;
...
public class UsernamePasswordCredentials extends Credentials {
  private byte[] password;
  ...
}
</code></pre>
<h2 id="clusterloginmodule">ClusterLoginModule</h2>
<p><img src="images/enterprise-onlycopy.jpg" alt=""></p>
<p>All security attributes are carried in <code>Credentials</code> object and <code>Credentials</code> is used by <a href="http://docs.oracle.com/javase/7/docs/api/javax/security/auth/spi/LoginModule.html">LoginModule</a>s during authentication process. Accessing user supplied attributes from <code>LoginModule</code>s is done by <a href="http://docs.oracle.com/javase/7/docs/api/javax/security/auth/callback/CallbackHandler.html">CallbackHandler</a>s. To provide access to Credentials object, Hazelcast uses its own specialized <code>CallbackHandler</code>. During initialization of <code>LoginModules</code> Hazelcast will pass this special <code>CallbackHandler</code> into <code>LoginModule.initialize()</code> method.</p>
<p>LoginModule implementations should create an instance of <code>com.hazelcast.security.CredentialsCallback</code> and call <code>handle(Callback[] callbacks)</code> method of <code>CallbackHandler</code> during login process. </p>
<p><code>CredentialsCallback.getCredentials()</code> will return the supplied <code>Credentials</code> object.</p>
<pre><code class="lang-java">public class CustomLoginModule implements LoginModule {
  CallbackHandler callbackHandler;
  Subject subject;

  public void initialize( Subject subject, CallbackHandler callbackHandler,
                          Map&lt;String, ?&gt; sharedState, Map&lt;String, ?&gt; options ) {
    this.subject = subject;
    this.callbackHandler = callbackHandler;
  }

  public final boolean login() throws LoginException {
    CredentialsCallback callback = new CredentialsCallback();
    try {
      callbackHandler.handle( new Callback[] { callback } );
      credentials = cb.getCredentials();
    } catch ( Exception e ) {
      throw new LoginException( e.getMessage() );
    }
    ...
  }
  ...
}
</code></pre>
<p>To use default Hazelcast permission policy, an instance of <code>com.hazelcast.security.ClusterPrincipal</code> that holding <code>Credentials</code> object must be created and added to <code>Subject.principals onLoginModule.commit()</code> as shown below.</p>
<pre><code class="lang-java">public class MyCustomLoginModule implements LoginModule {
  ...
  public boolean commit() throws LoginException {
    ...
    Principal principal = new ClusterPrincipal( credentials );
    subject.getPrincipals().add( principal );

    return true;
  }
  ...
}
</code></pre>
<p>Hazelcast also has an abstract implementation of <code>LoginModule</code> that does callback and cleanup operations and holds resulting <code>Credentials</code> instance. <code>LoginModule</code>s extending <code>ClusterLoginModule</code> can access <code>Credentials</code>, <code>Subject</code>, <code>LoginModule</code> instances and options and <code>sharedState</code> maps. Extending <code>ClusterLoginModule</code> is recommended instead of implementing all required stuff.</p>
<pre><code class="lang-java">package com.hazelcast.security;
...
public abstract class ClusterLoginModule implements LoginModule {

  protected abstract boolean onLogin() throws LoginException;
  protected abstract boolean onCommit() throws LoginException;
  protected abstract boolean onAbort() throws LoginException;
  protected abstract boolean onLogout() throws LoginException;
}
</code></pre>
<p><br></br></p>
<p><strong><em>RELATED INFORMATION</em></strong></p>
<p><em>Please refer to <a href="http://docs.oracle.com/javase/7/docs/technotes/guides/security/jaas/JAASRefGuide.html">JAAS Reference Guide</a> for further information.</em></p>
<h2 id="cluster-member-security">Cluster Member Security</h2>
<p><img src="images/enterprise-onlycopy.jpg" alt=""></p>
<p>Hazelcast supports standard Java Security (JAAS) based authentication between cluster members. You should configure one or moreLoginModules and an instance of <code>com.hazelcast.security.ICredentialsFactory</code>. Although Hazelcast has default implementations using cluster group and group-password and UsernamePasswordCredentials on authentication, it is advised to implement these according to specific needs and environment.</p>
<pre><code class="lang-xml">&lt;security enabled=&quot;true&quot;&gt;
  &lt;member-credentials-factory 
      class-name=&quot;com.hazelcast.examples.MyCredentialsFactory&quot;&gt;
    &lt;properties&gt;
      &lt;property name=&quot;property1&quot;&gt;value1&lt;/property&gt;
      &lt;property name=&quot;property2&quot;&gt;value2&lt;/property&gt;
    &lt;/properties&gt;
  &lt;/member-credentials-factory&gt;
  &lt;member-login-modules&gt;
    &lt;login-module usage=&quot;required&quot;
        class-name=&quot;com.hazelcast.examples.MyRequiredLoginModule&quot;&gt;
      &lt;properties&gt;
        &lt;property name=&quot;property3&quot;&gt;value3&lt;/property&gt;
      &lt;/properties&gt;
    &lt;/login-module&gt;
    &lt;login-module usage=&quot;sufficient&quot;
        class-name=&quot;com.hazelcast.examples.MySufficientLoginModule&quot;&gt;
      &lt;properties&gt;
        &lt;property name=&quot;property4&quot;&gt;value4&lt;/property&gt;
      &lt;/properties&gt;
    &lt;/login-module&gt;
    &lt;login-module usage=&quot;optional&quot;
        class-name=&quot;com.hazelcast.examples.MyOptionalLoginModule&quot;&gt;
      &lt;properties&gt;
        &lt;property name=&quot;property5&quot;&gt;value5&lt;/property&gt;
      &lt;/properties&gt;
    &lt;/login-module&gt;
  &lt;/member-login-modules&gt;
  ...
&lt;/security&gt;
</code></pre>
<p>You can define as many asLoginModules you wanted in configuration. Those are executed in given order. Usage attribute has 4 values; &#39;required&#39;, &#39;requisite&#39;, &#39;sufficient&#39; and &#39;optional&#39; as defined in <code>javax.security.auth.login.AppConfigurationEntry.LoginModuleControlFlag</code>.</p>
<pre><code class="lang-java">package com.hazelcast.security;
/**
 * ICredentialsFactory is used to create Credentials objects to be used
 * during node authentication before connection accepted by master node.
 */
public interface ICredentialsFactory {

  void configure( GroupConfig groupConfig, Properties properties );

  Credentials newCredentials();

  void destroy();
}
</code></pre>
<p>Properties defined in configuration are passed to <code>ICredentialsFactory.configure()</code> method as java.util.Properties and to <code>LoginModule.initialize()</code> method as java.util.Map.</p>
<h2 id="native-client-security">Native Client Security</h2>
<p><img src="images/enterprise-onlycopy.jpg" alt=""></p>
<p>Hazelcast&#39;s Client security includes both authentication and authorization.</p>
<h3 id="authentication">Authentication</h3>
<p>Authentication mechanism just works the same as cluster member authentication. Implementation of client authentication requires a Credentials and one or more LoginModule(s). Client side does not have/need a factory object to create Credentials objects like <code>ICredentialsFactory</code>. Credentials must be created at the client side and sent to the connected node during connection process.</p>
<pre><code class="lang-xml">&lt;security enabled=&quot;true&quot;&gt;
  &lt;client-login-modules&gt;
    &lt;login-module usage=&quot;required&quot;
        class-name=&quot;com.hazelcast.examples.MyRequiredClientLoginModule&quot;&gt;
      &lt;properties&gt;
        &lt;property name=&quot;property3&quot;&gt;value3&lt;/property&gt;
      &lt;/properties&gt;
    &lt;/login-module&gt;
    &lt;login-module usage=&quot;sufficient&quot;
        class-name=&quot;com.hazelcast.examples.MySufficientClientLoginModule&quot;&gt;
      &lt;properties&gt;
        &lt;property name=&quot;property4&quot;&gt;value4&lt;/property&gt;
      &lt;/properties&gt;
    &lt;/login-module&gt;
    &lt;login-module usage=&quot;optional&quot;
        class-name=&quot;com.hazelcast.examples.MyOptionalClientLoginModule&quot;&gt;
      &lt;properties&gt;
        &lt;property name=&quot;property5&quot;&gt;value5&lt;/property&gt;
      &lt;/properties&gt;
    &lt;/login-module&gt;
  &lt;/client-login-modules&gt;
  ...
&lt;/security&gt;
</code></pre>
<p>You can define as many as <code>LoginModules</code> you want in configuration. Those are executed in the given order. Usage attribute has 4 values; &#39;required&#39;, &#39;requisite&#39;, &#39;sufficient&#39; and &#39;optional&#39; as defined in <code>javax.security.auth.login.AppConfigurationEntry.LoginModuleControlFlag</code>.</p>
<pre><code class="lang-java">ClientConfig clientConfig = new ClientConfig();
clientConfig.setCredentials( new UsernamePasswordCredentials( &quot;dev&quot;, &quot;dev-pass&quot; ) );
HazelcastInstance client = HazelcastClient.newHazelcastClient( clientConfig );
</code></pre>
<h3 id="authorization">Authorization</h3>
<p>Hazelcast client authorization is configured by a client permission policy. Hazelcast has a default permission policy implementation that uses permission configurations defined in Hazelcast security configuration. Default policy permission checks are done against instance types (map, queue, etc.), instance names (map, queue, etc. name), instance actions (put, read, remove, add, etc.), client endpoint addresses and client principal defined by Credentials object. Instance and principal names and endpoint addresses can be defined as wildcards(*). Please see <a href="#network-configuration">Network Configuration</a> and <a href="#using-wildcard">Using Wildcard</a> sections.</p>
<pre><code class="lang-xml">&lt;security enabled=&quot;true&quot;&gt;
  &lt;client-permissions&gt;
    &lt;!-- Principal &#39;admin&#39; from endpoint &#39;127.0.0.1&#39; has all permissions. --&gt;
    &lt;all-permissions principal=&quot;admin&quot;&gt;
      &lt;endpoints&gt;
        &lt;endpoint&gt;127.0.0.1&lt;/endpoint&gt;
      &lt;/endpoints&gt;
    &lt;/all-permissions&gt;

    &lt;!-- Principals named &#39;dev&#39; from all endpoints have &#39;create&#39;, &#39;destroy&#39;, 
         &#39;put&#39;, &#39;read&#39; permissions for map named &#39;default&#39;. --&gt;
    &lt;map-permission name=&quot;default&quot; principal=&quot;dev&quot;&gt;
      &lt;actions&gt;
        &lt;action&gt;create&lt;/action&gt;
        &lt;action&gt;destroy&lt;/action&gt;
        &lt;action&gt;put&lt;/action&gt;
        &lt;action&gt;read&lt;/action&gt;
      &lt;/actions&gt;
    &lt;/map-permission&gt;

    &lt;!-- All principals from endpoints &#39;127.0.0.1&#39; or matching to &#39;10.10.*.*&#39; 
         have &#39;put&#39;, &#39;read&#39;, &#39;remove&#39; permissions for map
         whose name matches to &#39;com.foo.entity.*&#39;. --&gt;
    &lt;map-permission name=&quot;com.foo.entity.*&quot;&gt;
      &lt;endpoints&gt;
        &lt;endpoint&gt;10.10.*.*&lt;/endpoint&gt;
        &lt;endpoint&gt;127.0.0.1&lt;/endpoint&gt;
      &lt;/endpoints&gt;
      &lt;actions&gt;
        &lt;action&gt;put&lt;/action&gt;
        &lt;action&gt;read&lt;/action&gt;
        &lt;action&gt;remove&lt;/action&gt;
      &lt;/actions&gt;
    &lt;/map-permission&gt;

    &lt;!-- Principals named &#39;dev&#39; from endpoints matching to either 
         &#39;192.168.1.1-100&#39; or &#39;192.168.2.*&#39; 
         have &#39;create&#39;, &#39;add&#39;, &#39;remove&#39; permissions for all queues. --&gt;
    &lt;queue-permission name=&quot;*&quot; principal=&quot;dev&quot;&gt;
      &lt;endpoints&gt;
        &lt;endpoint&gt;192.168.1.1-100&lt;/endpoint&gt;
        &lt;endpoint&gt;192.168.2.*&lt;/endpoint&gt;
      &lt;/endpoints&gt;
      &lt;actions&gt;
        &lt;action&gt;create&lt;/action&gt;
        &lt;action&gt;add&lt;/action&gt;
        &lt;action&gt;remove&lt;/action&gt;
      &lt;/actions&gt;
    &lt;/queue-permission&gt;

    &lt;!-- All principals from all endpoints have transaction permission.--&gt;
    &lt;transaction-permission /&gt;
  &lt;/client-permissions&gt;
&lt;/security&gt;
</code></pre>
<p>The users also can define their own policy by implementing <code>com.hazelcast.security.IPermissionPolicy</code>.</p>
<pre><code class="lang-java">package com.hazelcast.security;
/**
 * IPermissionPolicy is used to determine any Subject&#39;s 
 * permissions to perform a security sensitive Hazelcast operation.
 *
 */
public interface IPermissionPolicy {
  void configure( SecurityConfig securityConfig, Properties properties );

  PermissionCollection getPermissions( Subject subject,
                                       Class&lt;? extends Permission&gt; type );

  void destroy();
}
</code></pre>
<p>Permission policy implementations can access client-permissions in configuration by using 
<code>SecurityConfig.getClientPermissionConfigs()</code> during <code>configure(SecurityConfig securityConfig, Properties properties)</code> method is called by Hazelcast.</p>
<p><code>IPermissionPolicy.getPermissions(Subject subject, Class&lt;? extends Permission&gt; type)</code> method is used to determine a client request that has been granted permission to perform a security-sensitive operation. </p>
<p>Permission policy should return a <code>PermissionCollection</code> containing permissions of given type for given <code>Subject</code>. Hazelcast access controller will call <code>PermissionCollection.implies(Permission)</code> on returning <code>PermissionCollection</code> and will decide if current <code>Subject</code> has permitted to access to requested resources or not.</p>
<h3 id="permissions">Permissions</h3>
<ul>
<li>All Permission</li>
</ul>
<pre><code class="lang-xml">&lt;all-permissions principal=&quot;principal&quot;&gt;
  &lt;endpoints&gt;
    ...
  &lt;/endpoints&gt;
&lt;/all-permissions&gt;
</code></pre>
<ul>
<li>Map Permission</li>
</ul>
<pre><code class="lang-xml">&lt;map-permission name=&quot;name&quot; principal=&quot;principal&quot;&gt;
  &lt;endpoints&gt;
    ...
  &lt;/endpoints&gt;
  &lt;actions&gt;
    ...
  &lt;/actions&gt;
&lt;/map-permission&gt;
</code></pre>
<pre><code>Actions: all, create, destroy, put, read, remove, lock, intercept, index, listen
</code></pre><ul>
<li>Queue Permission</li>
</ul>
<pre><code class="lang-xml">&lt;queue-permission name=&quot;name&quot; principal=&quot;principal&quot;&gt;
  &lt;endpoints&gt;
    ...
  &lt;/endpoints&gt;
  &lt;actions&gt;
    ...
  &lt;/actions&gt;
&lt;/queue-permission&gt;
</code></pre>
<pre><code>Actions: all, create, destroy, add, remove, read, listen
</code></pre><ul>
<li>Multimap Permission</li>
</ul>
<pre><code class="lang-xml">&lt;multimap-permission name=&quot;name&quot; principal=&quot;principal&quot;&gt;
  &lt;endpoints&gt;
    ...
  &lt;/endpoints&gt;
  &lt;actions&gt;
    ...
  &lt;/actions&gt;
&lt;/multimap-permission&gt;
</code></pre>
<pre><code>Actions: all, create, destroy, put, read, remove, listen, lock
</code></pre><ul>
<li>Topic Permission</li>
</ul>
<pre><code class="lang-xml">&lt;topic-permission name=&quot;name&quot; principal=&quot;principal&quot;&gt;
  &lt;endpoints&gt;
    ...
  &lt;/endpoints&gt;
  &lt;actions&gt;
    ...
  &lt;/actions&gt;
&lt;/topic-permission&gt;
</code></pre>
<pre><code>Actions: create, destroy, publish, listen
</code></pre><ul>
<li>List Permission</li>
</ul>
<pre><code class="lang-xml">&lt;list-permission name=&quot;name&quot; principal=&quot;principal&quot;&gt;
  &lt;endpoints&gt;
    ...
  &lt;/endpoints&gt;
  &lt;actions&gt;
    ...
  &lt;/actions&gt;
&lt;/list-permission&gt;
</code></pre>
<pre><code>Actions: all, create, destroy, add, read, remove, listen
</code></pre><ul>
<li>Set Permission</li>
</ul>
<pre><code class="lang-xml">&lt;set-permission name=&quot;name&quot; principal=&quot;principal&quot;&gt;
  &lt;endpoints&gt;
    ...
  &lt;/endpoints&gt;
  &lt;actions&gt;
    ...
  &lt;/actions&gt;
&lt;/set-permission&gt;
</code></pre>
<pre><code>Actions: all, create, destroy, add, read, remove, listen
</code></pre><ul>
<li>Lock Permission</li>
</ul>
<pre><code class="lang-xml">&lt;lock-permission name=&quot;name&quot; principal=&quot;principal&quot;&gt;
  &lt;endpoints&gt;
    ...
  &lt;/endpoints&gt;
  &lt;actions&gt;
    ...
  &lt;/actions&gt;
&lt;/lock-permission&gt;
</code></pre>
<pre><code>Actions: all, create, destroy, lock, read
</code></pre><ul>
<li>AtomicLong Permission</li>
</ul>
<pre><code class="lang-xml">&lt;atomic-long-permission name=&quot;name&quot; principal=&quot;principal&quot;&gt;
  &lt;endpoints&gt;
        ...
  &lt;/endpoints&gt;
  &lt;actions&gt;
    ...
  &lt;/actions&gt;
&lt;/atomic-long-permission&gt;
</code></pre>
<pre><code>Actions: all, create, destroy, read, modify
</code></pre><ul>
<li>CountDownLatch Permission</li>
</ul>
<pre><code class="lang-xml">&lt;countdown-latch-permission name=&quot;name&quot; principal=&quot;principal&quot;&gt;
  &lt;endpoints&gt;
    ...
  &lt;/endpoints&gt;
  &lt;actions&gt;
    ...
  &lt;/actions&gt;
&lt;/countdown-latch-permission&gt;
</code></pre>
<pre><code>Actions: all, create, destroy, modify, read
</code></pre><ul>
<li>Semaphore Permission</li>
</ul>
<pre><code class="lang-xml">&lt;semaphore-permission name=&quot;name&quot; principal=&quot;principal&quot;&gt;
  &lt;endpoints&gt;
    ...
  &lt;/endpoints&gt;
  &lt;actions&gt;
    ...
  &lt;/actions&gt;
&lt;/semaphore-permission&gt;
</code></pre>
<pre><code>Actions: all, create, destroy, acquire, release, read
</code></pre><ul>
<li>Executor Service Permission</li>
</ul>
<pre><code class="lang-xml">&lt;executor-service-permission name=&quot;name&quot; principal=&quot;principal&quot;&gt;
  &lt;endpoints&gt;
    ...
  &lt;/endpoints&gt;
  &lt;actions&gt;
    ...
  &lt;/actions&gt;
&lt;/executor-service-permission&gt;
</code></pre>
<pre><code>Actions: all, create, destroy
</code></pre><ul>
<li>Transaction Permission</li>
</ul>
<pre><code class="lang-xml">&lt;transaction-permission principal=&quot;principal&quot;&gt;
  &lt;endpoints&gt;
    ...
  &lt;/endpoints&gt;
&lt;/transaction-permission&gt;
</code></pre>
<p><br> </br></p>
<h1 id="performance">Performance</h1>
<h2 id="data-affinity">Data Affinity</h2>
<p>Data affinity is to ensure that related entries exist on the same node. If related data is on the same node, operations can be executed without the cost of extra network call and extra wire data. This feature is provided by using same partition keys for related data.</p>
<p><strong>Co-location of related data and computation</strong></p>
<p>Hazelcast has a standard way of finding out which member owns/manages each key object. Following operations will be routed to the same member, since all of them are operating based on the same key, &quot;key1&quot;.</p>
<pre><code class="lang-java">HazelcastInstance hazelcastInstance = Hazelcast.newHazelcastInstance();
Map mapA = hazelcastInstance.getMap( &quot;mapA&quot; );
Map mapB = hazelcastInstance.getMap( &quot;mapB&quot; );
Map mapC = hazelcastInstance.getMap( &quot;mapC&quot; );
mapA.put( &quot;key1&quot;, value );
mapB.get( &quot;key1&quot; );
mapC.remove( &quot;key1&quot; );
// since map names are different, operation will be manipulating
// different entries, but the operation will take place on the
// same member since the keys (&quot;key1&quot;) are the same

hazelcastInstance.getLock( &quot;key1&quot; ).lock();
// lock operation will still execute on the same member of the cluster
// since the key (&quot;key1&quot;) is same

hazelcastInstance.getExecutorService().executeOnKeyOwner( runnable, &quot;key1&quot; );
// distributed execution will execute the &#39;runnable&#39; on the same member
// since &quot;key1&quot; is passed as the key.
</code></pre>
<p>So, when the keys are the same, then entries are stored on the same node. But we sometimes want to have related entries stored on the same node. Consider customer and his/her order entries. We would have customers map with customerId as the key and orders map with orderId as the key. Since customerId and orderIds are different keys, customer and his/her orders may fall into different members/nodes in your cluster. So how can we have them stored on the same node? The trick here is to create an affinity between customer and orders. If we can somehow make them part of the same partition then these entries will be co-located. We achieve this by making orderIds <code>PartitionAware</code>.</p>
<pre><code class="lang-java">public class OrderKey implements Serializable, PartitionAware {
  private final long customerId;
  private final long orderId;

  public OrderKey( long orderId, long customerId ) {
    this.customerId = customerId;
    this.orderId = orderId;
  }

  public long getCustomerId() {
    return customerId;
  }

  public long getOrderId() {
    return orderId;
  }

  public Object getPartitionKey() {
    return customerId;
  }

  @Override
  public String toString() {
    return &quot;OrderKey{&quot; +
        &quot;customerId=&quot; + customerId +
        &quot;, orderId=&quot; + orderId +
      &#39;}&#39;;
    }
}
</code></pre>
<p>Notice that OrderKey implements <code>PartitionAware</code> and <code>getPartitionKey()</code> returns the <code>customerId</code>. This will make sure that <code>Customer</code> entry and its <code>Order</code>s are going to be stored on the same node.</p>
<pre><code class="lang-java">HazelcastInstance hazelcastInstance = Hazelcast.newHazelcastInstance();
Map mapCustomers = hazelcastInstance.getMap( &quot;customers&quot; )
Map mapOrders = hazelcastInstance.getMap( &quot;orders&quot; )
// create the customer entry with customer id = 1
mapCustomers.put( 1, customer );
// now create the orders for this customer
mapOrders.put( new OrderKey( 21, 1 ), order );
mapOrders.put( new OrderKey( 22, 1 ), order );
mapOrders.put( new OrderKey( 23, 1 ), order );
</code></pre>
<p>Assume that you have a customers map where <code>customerId</code> is the key and the customer object is the value and you want to remove one of the orders of a customer and return the number of remaining orders. Here is how you would normally do it:</p>
<pre><code class="lang-java">public static int removeOrder( long customerId, long orderId ) throws Exception {
  IMap&lt;Long, Customer&gt; mapCustomers = instance.getMap( &quot;customers&quot; );
  IMap mapOrders = hazelcastInstance.getMap( &quot;orders&quot; )
  mapCustomers.lock( customerId );
  mapOrders.remove(orderId);
  Set orders = orderMap.keySet(Predicates.equal(&quot;customerId&quot;, customerId));
  mapCustomers.unlock( customerId );
  return orders.size();
}
</code></pre>
<p>There are couple of things you should consider:</p>
<ol>
<li><p>There are four distributed operations there: lock, remove, keySet, unlock. Can you reduce 
the number of distributed operations?</p>
</li>
<li><p>Customer object may not be that big, but can you not have to pass that object through the 
wire? Think about a scenario which you set order count to customer object for fast access, so you 
should do a get and a put as a result customer object is being passed through the wire twice.</p>
</li>
</ol>
<p>So instead, why not moving the computation over to the member (JVM) where your customer data actually is. Here is how you can do this with distributed executor service:</p>
<ol>
<li><p>Send a <code>PartitionAware</code> <code>Callable</code> task.</p>
</li>
<li><p><code>Callable</code> does the deletion of the order right there and returns with the remaining 
order count.</p>
</li>
<li><p>Upon completion of the <code>Callable</code> task, return the result (remaining order count). Plus, you 
do not have to wait until the task is completed; since distributed executions are asynchronous, you can do other things in the meantime.</p>
</li>
</ol>
<p>Here is a sample code:</p>
<pre><code class="lang-java">HazelcastInstance hazelcastInstance = Hazelcast.newHazelcastInstance();

public int removeOrder(long customerId, long orderId) throws Exception {
    IExecutorService es = hazelcastInstance
        .getExecutorService( &quot;ExecutorService&quot; );
    OrderDeletionTask task = new OrderDeletionTask( customerId, orderId );
    Future&lt;Integer&gt; future = es.submit( task );
    int remainingOrders = future.get();
    return remainingOrders;
}

public static class OrderDeletionTask
    implements Callable&lt;Integer&gt;, PartitionAware, Serializable {

    private long customerId;
    private long orderId;

    public OrderDeletionTask() {
    }

    public OrderDeletionTask(long customerId, long orderId) {
        super();
        this.customerId = customerId;
        this.orderId = orderId;
    }

    public Integer call () {
        Map&lt;Long, Customer&gt; customerMap = hazelcastInstance.getMap(&quot;customers&quot;);
        IMap&lt;OrderKey, Order&gt; orderMap = hazelcastInstance.getMap(&quot;orders&quot;);
        mapCustomers.lock( customerId );
        Customer customer = mapCustomers.get( customerId );
        final Predicate predicate = Predicates.equal(&quot;customerId&quot;, customerId);
        final Set&lt;OrderKey&gt; orderKeys = orderMap.localKeySet(predicate);
        int orderCount = orderKeys.size();
        for (OrderKey key : orderKeys) {
            if (key.orderId == orderId) {
                orderCount--;
                orderMap.delete(key);
            }
        }
        mapCustomers.unlock( customerId );
        return orderCount;
    }

    public Object getPartitionKey() {
        return customerId;
    }
}
</code></pre>
<p>Benefits of doing the same operation with distributed <code>ExecutorService</code> based on the key are:</p>
<ul>
<li><p>Only one distributed execution (<code>es.submit(task)</code>), instead of four.</p>
</li>
<li><p>Less data is sent over the wire.</p>
</li>
<li><p>Since lock/update/unlock cycle is done locally (local to the customer data), lock duration for the <code>Customer</code> entry is much less, so enabling higher concurrency.</p>
</li>
</ul>
<p><br> </br></p>
<h2 id="threading-model">Threading Model</h2>
<p>Your application server has its own threads. Hazelcast does not use these - it manages its own threads.</p>
<h3 id="i-o-threading">I/O Threading</h3>
<p>Hazelcast uses a pool of threads for I/O; so there is not a single thread doing all the IO, but there are multiple. On each cluster
member, the IO threading is split up in 3 types of IO-threads:</p>
<ul>
<li>IO-thread that takes care of accept request,</li>
<li>IO-threads that take care of reading data from other members/clients,</li>
<li>IO-threads that take care of writing data to other members/clients</li>
</ul>
<p>The number of IO-threads can be configured using the <code>hazelcast.io.thread.count</code> system property and defaults to 3 per member. 
This means that if 3 is used, in total there are 7 IO-threads; 1 accept-IO-thread, 3 read-IO-threads and 3 write-IO-threads. Each 
IO-thread has their own Selector instance and wait on <code>Selector.select</code> if there is nothing to do.</p>
<p>In case of the IO-read-thread, when sufficient bytes for a packet have been received, the Packet object is created. This Packet is 
then sent to the System where it is de-multiplexed. If the Packet header signals that it is an operation/response, it is handed 
over to the operation service (please see <a href="#operation-threading">Operation Threading</a>). If the Packet is an event, it is handed 
over to the event service (please see <a href="#event-threading">Event Threading</a>). </p>
<h3 id="event-threading">Event Threading</h3>
<p>Hazelcast uses a shared event system to deal with components that rely on events like topic, collections listeners and near-cache. </p>
<p>Each cluster member has an array of event threads and each thread has its own work queue. When an event is produced,
either locally or remote, an event thread is selected (depending on if there is a message ordering) and the event is placed
in the work queue for that event thread.</p>
<p>The following properties
can be set to alter the behavior of the system:</p>
<ul>
<li><code>hazelcast.event.thread.count</code>: Number of event-threads in this array. Its default value is 5.</li>
<li><code>hazelcast.event.queue.capacity</code>: Capacity of the work queue. Its default value is 1000000.</li>
<li><code>hazelcast.event.queue.timeout.millis</code>: Timeout for placing an item on the work queue. Its default value is 250.</li>
</ul>
<p>If you process a lot of events and have many cores, changing the value of <code>hazelcast.event.thread.count</code> property to
a higher value is a good idea. By this way, more events can be processed in parallel.</p>
<p>Multiple components share the same event queues. If there are 2 topics, say A and B, for certain messages
they may share the same queue(s) and hence event thread. If there are a lot of pending messages produced by A, then B needs to wait.
Also, when processing a message from A takes a lot of time and the event thread is used for that, B will suffer from this. 
That is why it is better to offload processing to a dedicate thread (pool) so that systems are better isolated.</p>
<p>If events are produced at a higher rate than they are consumed, the queue will grow in size. To prevent overloading system
and running into an <code>OutOfMemoryException</code>, the queue is given a capacity of 1M million items. When the maximum capacity is reached, the items are
dropped. This means that the event system is a &#39;best effort&#39; system. There is no guarantee that you are going to get an
event. It can also be that Topic A has a lot of pending messages, and therefore B cannot receive messages because the queue
has no capacity and messages for B are dropped.</p>
<h3 id="iexecutor-threading">IExecutor Threading</h3>
<p>Executor threading is straight forward. When a task is received to be executed on Executor E, then E will have its
own <code>ThreadPoolExecutor</code> instance and the work is put on the work queue of this executor. So, Executors are fully isolated, but of course, they will share the same underlying hardware; most importantly the CPUs. </p>
<p>The IExecutor can be configured using the <code>ExecutorConfig</code> (programmatic configuration) or using <code>&lt;executor&gt;</code> (declarative configuration).</p>
<h3 id="operation-threading">Operation Threading</h3>
<p>There are 2 types of operations:</p>
<ul>
<li>Operations that are aware of a certain partition, e.g. <code>IMap.get(key)</code></li>
<li>Operations that are not partition aware like the <code>IExecutorService.executeOnMember(command,member)</code> operation.</li>
</ul>
<p>Each of these types has a different threading model explained below.</p>
<h4 id="partition-aware-operations">Partition-aware Operations</h4>
<p>To execute partition-aware operations, an array of operation threads is created. The size of this array is by default two 
times the number of cores. It can be changed using the <code>hazelcast.operation.thread.count</code> property.</p>
<p>Each operation-thread has its own work queue and it will consume messages from this work queue. If a partition-aware 
operation needs to be scheduled, the right thread is found using the below formula:</p>
<p><code>threadIndex = partitionId % partition-thread-count</code></p>
<p>After the threadIndex is determined, the operation is put in the work queue of that operation-thread.</p>
<p>This means that:</p>
<ul>
<li><p>a single operation thread executes operations for multiple partitions; if there are 271 partitions and
10 partition-threads, then roughly every operation-thread will execute operations for 27 partitions. </p>
</li>
<li><p>each partition belongs to only 1 operation thread. All operations for partition some partition, will always 
be handled by exactly the same operation-thread. </p>
</li>
<li><p>no concurrency control is needed to deal with partition-aware operations because once a partition-aware
operation is put on the work queue of a partition-aware operation thread, you get the guarantee that only 
1 thread is able to touch that partition.</p>
</li>
</ul>
<p>Because of this threading strategy, there are two forms of false sharing you need to be aware of:</p>
<ul>
<li><p>false sharing of the partition: two completely independent data structures share the same partitions; e.g. if there
is a map <code>employees</code> and a map <code>orders</code> it could be that an employees.get(peter) (running on e.g. partition 25) is blocked
by a map.get of orders.get(1234) (also running on partition 25). So if independent data structure share the same partition
a slow operation on one data structure can slow down the other data structures.</p>
</li>
<li><p>false sharing of the partition-aware operation-thread: each operation-thread is responsible for executing
operations of a number of partitions. For example thread-1 could be responsible for partitions 0,10,20.. thread-2 for partitions
1,11,21,.. etc. So if an operation for partition 1 is taking a lot of time, it will block the execution of an operation of partition
11 because both of them are mapped to exactly the same operation-thread.</p>
</li>
</ul>
<p>So you need to be careful with long running operations because it could be that you are starving operations of a thread. 
The general rule is is that the partition thread should be released as soon as possible because operations are not designed
to execute long running operations. That is why it for example is very dangerous to execute a long running operation 
using e.g. AtomicReference.alter or a IMap.executeOnKey, because these operations will block others operations to be executed.</p>
<p>Currently, there is no support for work stealing; so different partitions, that map to the same thread may need to wait 
till one of the partitions is finished, even though there are other free partition-operation threads available.</p>
<p><strong>Example:</strong></p>
<p>Take a 3 node cluster. Two members will have 90 primary partitions and one member will have 91 primary partitions. Let&#39;s
say you have one CPU and 4 cores per CPU. By default, 8 operation threads will be allocated to serve 90 or 91 partitions.</p>
<h4 id="non-partition-aware-operations">Non Partition-aware Operations</h4>
<p>To execute non partition-aware operations, e.g. <code>IExecutorService.executeOnMember(command,member)</code>, generic operation 
threads are used. When the Hazelcast instance is started, an array of operation threads is created. Size of this array 
also is by default two times the number of cores. It can be changed using the <code>hazelcast.operation.generic.thread.count</code> 
property.</p>
<p>This means that:</p>
<ul>
<li>a non partition-aware operation-thread will never execute an operation for a specific partition. Only partition-aware
operation-threads execute partition-aware operations. </li>
</ul>
<p>Unlike the partition-aware operation threads, all the generic operation threads share the same work queue: <code>genericWorkQueue</code>.</p>
<p>If a non partition-aware operation needs to be executed, it is placed in that work queue and any generic operation 
thread can execute it. The big advantage is that you automatically have work balancing since any generic operation 
thread is allowed to pick up work from this queue.</p>
<p>The disadvantage is that this shared queue can be a point of contention; however, practically we do not see this as in 
production as performance is dominated by I/O and the system is not executing that many non partition-aware operations.</p>
<h4 id="priority-operations">Priority Operations</h4>
<p>In some cases the system needs to execute operations with a higher priority, e.g. an important system operation. To support priority
operations we do the following:</p>
<ul>
<li><p>For partition-aware operations: each partition thread has of course its own work queue. But apart from that, it also has a priority
work queue. It will always check this priority queue, before it is going to process work from its normal work queue.</p>
</li>
<li><p>For non partition-aware operations: next to the <code>genericWorkQueue</code>, there also is a <code>genericPriorityWorkQueue</code>. So when a priority operation
needs to be executed, it is put in this <code>genericPriorityWorkQueue</code>. And just like the partition-aware operation threads, a generic
operation thread, will first check the <code>genericPriorityWorkQueue</code> for work. </p>
</li>
</ul>
<p>Because a worker thread will block on the normal work queue (either partition specific or generic) it could be that a priority operation
is not picked up because it will not be put on the queue it is blocking on. We always send a &#39;kick the worker&#39; operation that does 
nothing else than trigger the worker to wake up and check the priority queue. </p>
<h4 id="operation-response-and-invocation-future">Operation-response and Invocation-future</h4>
<p>When an Operation is invoked, a <code>Future</code> is returned. Let&#39;s take the below sample code. </p>
<pre><code class="lang-java">GetOperation operation = new GetOperation( mapName, key )
Future future = operationService.invoke( operation )
future.get)
</code></pre>
<p>So, the calling side blocks for a reply. In this case, <code>GetOperation</code> is set in the work queue for the partition of <code>key</code>, where
it eventually is executed. On execution, a response is returned and placed on the <code>genericWorkQueue</code> where it is executed by a 
&quot;generic operation thread&quot;. This thread will signal the <code>future</code> and notifies the blocked thread that a response is available. 
In the future we will expose this Future to the outside world, and we will provide the ability to register a completion listener 
so you can do asynchronous calls. </p>
<h4 id="local-calls">Local Calls</h4>
<p>When a local partition-aware call is done, an operation is made and handed over to the work queue of the correct partition operation thread
and a future is returned. When the calling thread calls get on that future, it will acquire a lock and wait for the result 
to become available. When a response is calculated, the future is looked up, and the waiting thread is notified.  </p>
<p>In the future, this will be optimized to reduce the amount of expensive systems calls like <code>lock.acquire</code>/<code>notify</code> and the expensive
interaction with the operation-queue. Probably, we will add support for a caller-runs mode, so that an operation is directly executed on
the calling thread.</p>
<h1 id="wan">WAN</h1>
<p><img src="images/enterprise-onlycopy.jpg" alt=""></p>
<h2 id="wan-replication">WAN Replication</h2>
<p>There are cases where you need to synchronize multiple clusters to the same state. Synchronization of clusters, also known as
WAN (Wide Area Network) Replication, is mainly used for replicating stats of different clusters over WAN environments like
the Internet. </p>
<p>Imagine you have different data centers in New York, London and Tokyo each running an independent Hazelcast cluster. Every cluster
would be operating at native speed in their own LAN (Local Area Network) settings but you also want some or all recordsets in
these clusters replicated to each other. So, updates to Tokyo cluster also go to London and New York, in the meantime updates
from New York cluster are synchronized to Tokyo and London.</p>
<h3 id="wan-replication-configuration">WAN Replication Configuration</h3>
<p>The current WAN Replication implementation supports two different operation modes: </p>
<ul>
<li><p><strong>Active-Passive:</strong> This mode is mostly used for failover scenarios where you want to replicate only one active cluster to one
or more non active ones for backup reasons</p>
</li>
<li><p><strong>Active-Active:</strong> Every cluster is fully equal and all clusters replicating to all others which is normally used to connect
different clients to different clusters for the sake of shortest path between client and server.</p>
</li>
</ul>
<p>Let&#39;s see how we can set up WAN Replication for London and Tokyo clusters:</p>
<pre><code class="lang-xml">&lt;hazelcast&gt;
  &lt;wan-replication name=&quot;my-wan-cluster&quot;&gt;
    &lt;target-cluster group-name=&quot;tokyo&quot; group-password=&quot;tokyo-pass&quot;&gt;
      &lt;replication-impl&gt;com.hazelcast.wan.impl.WanNoDelayReplication&lt;/replication-impl&gt;
      &lt;end-points&gt;
        &lt;address&gt;10.2.1.1:5701&lt;/address&gt;
        &lt;address&gt;10.2.1.2:5701&lt;/address&gt;
      &lt;/end-points&gt;
    &lt;/target-cluster&gt;
    &lt;target-cluster group-name=&quot;london&quot; group-password=&quot;london-pass&quot;&gt;
      &lt;replication-impl&gt;com.hazelcast.wan.impl.WanNoDelayReplication&lt;/replication-impl&gt;
      &lt;end-points&gt;
        &lt;address&gt;10.3.5.1:5701&lt;/address&gt;
        &lt;address&gt;10.3.5.2:5701&lt;/address&gt;
      &lt;/end-points&gt;
    &lt;/target-cluster&gt;
  &lt;/wan-replication&gt;
  ...
&lt;/hazelcast&gt;
</code></pre>
<p>Using this configuration, the cluster running in NY is replicating to Tokyo and London. Tokyo and London clusters should
have a similar configurations if you want to run in Active-Active mode.</p>
<p>If New York and London cluster configurations contain the <code>wan-replication</code> element and Tokyo cluster does not, it means
New York and London are active endpoints and Tokyo is a passive endpoint.</p>
<p>By using an Active-Active Replication setup, you might end up in situations where multiple clusters simultaneously updating the same
entry in the same distributed data structure. Those situations will cause conflicts which make it sufficient to provide
merge-policies to resolve those conflicts. </p>
<pre><code class="lang-xml">&lt;hazelcast&gt;
  &lt;wan-replication name=&quot;my-wan-cluster&quot;&gt;
    &lt;merge-policy&gt;com.hazelcast.map.merge.PassThroughMergePolicy&lt;/merge-policy&gt;
    ...
  &lt;/wan-replication&gt;
  ...
&lt;/hazelcast&gt;
</code></pre>
<p>As noted earlier, you can have Hazelcast replicating only some or all of the data in your cluster. Imagine you have 5 different
distributed maps but you might want only one of these maps replicating across clusters. To achieve this you mark the maps to be
replicated by adding <code>wan-replication-ref</code> element in the map configuration as shown below.</p>
<pre><code class="lang-xml">&lt;hazelcast&gt;
  &lt;wan-replication name=&quot;my-wan-cluster&quot;&gt;
    ...
  &lt;/wan-replication&gt;
  &lt;map name=&quot;my-shared-map&quot;&gt;
    &lt;wan-replication-ref name=&quot;my-wan-cluster&quot;&gt;
    &lt;merge-policy&gt;com.hazelcast.map.merge.PassThroughMergePolicy&lt;/merge-policy&gt;
      ...
    &lt;/wan-replication-ref&gt;
  &lt;/map&gt;
  ...
&lt;/hazelcast&gt;
</code></pre>
<p>You see that we have <code>my-shared-map</code> configured to replicate itself to the cluster targets defined in the earlier
<code>wan-replication</code> element.</p>
<p>Note that, you will also have to define a <code>merge policy</code> for merging replica entries and resolving conflicts during the merge
as mentioned before.</p>
<h3 id="wan-replication-queue-size">WAN Replication Queue Size</h3>
<p>For huge clusters or high data mutation rates, it might be necessary to increase the replication queue size. The default queue
size for replication queues is <code>100000</code>. This means, if you have heavy put/update/remove rates, you might exceed the queue size
so that oldest, not yet replicated, updates might get lost.</p>
<p>To increase the replication queue size, Hazelcast Enterprise user can use the <code>hazelcast.enterprise.wanrep.queuesize</code>
configuration property.</p>
<p>This can either be achieved using a command line property (where xxx is the queue size):</p>
<pre><code class="lang-plain">-Dhazelcast.enterprise.wanrep.queuesize=xxx
</code></pre>
<p>or using properties inside the <code>hazelcast.xml</code> (also here change xxx to the requested queue size):</p>
<pre><code class="lang-xml">&lt;hazelcast&gt;
  &lt;properties&gt;
    &lt;property name=&quot;hazelcast.enterprise.wanrep.queuesize&quot;&gt;xxx&lt;/property&gt;
  &lt;/properties&gt;
&lt;/hazelcast&gt;
</code></pre>
<h3 id="wan-replication-additional-information">WAN Replication Additional Information</h3>
<p><strong><em>RELATED INFORMATION</em></strong></p>
<p><em>You can download the white paper <strong>Hazelcast on AWS: Best Practices for Deployment</strong> from
<a href="http://hazelcast.com/resources/hazelcast-on-aws-best-practices-for-deployment/">Hazelcast.com</a>.</em></p>
<h1 id="configuration">Configuration</h1>
<p>Hazelcast can be configured declaratively (XML) or programmatically (API) or even by the mix of both.</p>
<p><strong>1- Declarative Configuration</strong></p>
<p>If you are creating new Hazelcast instance with passing <code>null</code> parameter to <code>Hazelcast.newHazelcastInstance(null)</code> or just using empty factory method (<code>Hazelcast.newHazelcastInstance()</code>), Hazelcast will look into two places for the configuration file:</p>
<ul>
<li><p><strong>System property:</strong> Hazelcast will first check if &quot;<code>hazelcast.config</code>&quot; system property is set to a file path. Example: <code>-Dhazelcast.config=C:/myhazelcast.xml</code>.</p>
</li>
<li><p><strong>Classpath:</strong> If config file is not set as a system property, Hazelcast will check classpath for <code>hazelcast.xml</code> file.</p>
</li>
</ul>
<p>If Hazelcast does not find any configuration file, it will happily start with default configuration (<code>hazelcast-default.xml</code>) located in <code>hazelcast.jar</code>. (Before configuring Hazelcast, please try to work with default configuration to see if it works for you. Default should be just fine for most of the users. If not, then consider custom configuration for your environment.)</p>
<p>If you want to specify your own configuration file to create <code>Config</code>, Hazelcast supports several ways including filesystem, classpath, InputStream, URL, etc.:</p>
<ul>
<li><p><code>Config cfg = new XmlConfigBuilder(xmlFileName).build();</code></p>
</li>
<li><p><code>Config cfg = new XmlConfigBuilder(inputStream).build();</code></p>
</li>
<li><p><code>Config cfg = new ClasspathXmlConfig(xmlFileName);</code></p>
</li>
<li><p><code>Config cfg = new FileSystemXmlConfig(configFilename);</code></p>
</li>
<li><p><code>Config cfg = new UrlXmlConfig(url);</code></p>
</li>
<li><p><code>Config cfg = new InMemoryXmlConfig(xml);</code></p>
</li>
</ul>
<p><strong>2- Programmatic Configuration</strong></p>
<p>To configure Hazelcast programmatically, just instantiate a <code>Config</code> object and set/change its properties/attributes due to your needs.</p>
<pre><code class="lang-java">Config config = new Config();
config.getNetworkConfig().setPort( 5900 );
config.getNetworkConfig().setPortAutoIncrement( false );

NetworkConfig network = config.getNetworkConfig();
JoinConfig join = network.getJoin();
join.getMulticastConfig().setEnabled( false );
join.getTcpIpConfig().addMember( &quot;10.45.67.32&quot; ).addMember( &quot;10.45.67.100&quot; )
            .setRequiredMember( &quot;192.168.10.100&quot; ).setEnabled( true );
network.getInterfaces().setEnabled( true ).addInterface( &quot;10.45.67.*&quot; );

MapConfig mapConfig = new MapConfig();
mapConfig.setName( &quot;testMap&quot; );
mapConfig.setBackupCount( 2 );
mapConfig.getMaxSizeConfig().setSize( 10000 );
mapConfig.setTimeToLiveSeconds( 300 );

MapStoreConfig mapStoreConfig = new MapStoreConfig();
mapStoreConfig.setClassName( &quot;com.hazelcast.examples.DummyStore&quot; )
    .setEnabled( true );
mapConfig.setMapStoreConfig( mapStoreConfig );

NearCacheConfig nearCacheConfig = new NearCacheConfig();
nearCacheConfig.setMaxSize( 1000 ).setMaxIdleSeconds( 120 )
    .setTimeToLiveSeconds( 300 );
mapConfig.setNearCacheConfig( nearCacheConfig );

config.addMapConfig( mapConfig );
</code></pre>
<p>After creating <code>Config</code> object, you can use it to create a new Hazelcast instance.</p>
<ul>
<li><code>HazelcastInstance hazelcast = Hazelcast.newHazelcastInstance( config );</code>
<a name="named-hazelcastinstance"></a></li>
<li>To create a named <code>HazelcastInstance</code> you should set <code>instanceName</code> of <code>Config</code> object. </li>
</ul>
<pre><code class="lang-java">    Config config = new Config();
    config.setInstanceName( &quot;my-instance&quot; );
    Hazelcast.newHazelcastInstance( config );
</code></pre>
<ul>
<li>To retrieve an existing <code>HazelcastInstance</code> using its name, use;</li>
</ul>
<p><code>Hazelcast.getHazelcastInstanceByName( &quot;my-instance&quot; );</code></p>
<ul>
<li>To retrieve all existing<code>HazelcastInstance</code>s, use;</li>
</ul>
<p><code>Hazelcast.getAllHazelcastInstances();</code></p>
<h2 id="using-wildcard">Using Wildcard</h2>
<p>Hazelcast supports wildcard configuration for all distributed data structures that can be configured using <code>Config</code> (i.e. for all except IAtomicLong, IAtomicReference). Using an asterisk (*) character in the name, different instances of maps, queues, topics, semaphores, etc. can be configured by a single configuration.</p>
<p>Note that, with a limitation of a single usage, asterisk (*) can be placed anywhere inside the configuration name.</p>
<p>For instance, a map named &#39;<code>com.hazelcast.test.mymap</code>&#39; can be configured using one of these configurations;</p>
<pre><code class="lang-xml">&lt;map name=&quot;com.hazelcast.test.*&quot;&gt;
...
&lt;/map&gt;
</code></pre>
<pre><code class="lang-xml">&lt;map name=&quot;com.hazel*&quot;&gt;
...
&lt;/map&gt;
</code></pre>
<pre><code class="lang-xml">&lt;map name=&quot;*.test.mymap&quot;&gt;
...
&lt;/map&gt;
</code></pre>
<pre><code class="lang-xml">&lt;map name=&quot;com.*test.mymap&quot;&gt;
...
&lt;/map&gt;
</code></pre>
<p>Or a queue &#39;<code>com.hazelcast.test.myqueue</code>&#39;;</p>
<pre><code class="lang-xml">&lt;queue name=&quot;*hazelcast.test.myqueue&quot;&gt;
...
&lt;/queue&gt;
</code></pre>
<pre><code class="lang-xml">&lt;queue name=&quot;com.hazelcast.*.myqueue&quot;&gt;
...
&lt;/queue&gt;
</code></pre>
<h2 id="network-configuration">Network Configuration</h2>
<h3 id="configuring-tcp-ip-cluster">Configuring TCP/IP Cluster</h3>
<p>If multicast is not preferred as the way of discovery for your environment, then you can configure Hazelcast for full TCP/IP cluster. As below configuration shows, while <code>enable</code> attribute of <code>multicast</code> is set to false, <code>tcp-ip</code> has to be set to true. </p>
<p>For the none-multicast option, all or subset of nodes&#39; hostnames and/or IP addresses must be listed. Note that, all of the cluster members do not have to be listed there but at least one of them has to be active in cluster when a new member joins. </p>
<pre><code class="lang-xml">&lt;hazelcast&gt;
  ...
  &lt;network&gt;
    &lt;port auto-increment=&quot;true&quot;&gt;5701&lt;/port&gt;
    &lt;join&gt;
      &lt;multicast enabled=&quot;false&quot;&gt;
        &lt;multicast-group&gt;224.2.2.3&lt;/multicast-group&gt;
        &lt;multicast-port&gt;54327&lt;/multicast-port&gt;
      &lt;/multicast&gt;
      &lt;tcp-ip enabled=&quot;true&quot;&gt;
        &lt;member&gt;machine1&lt;/member&gt;
        &lt;member&gt;machine2&lt;/member&gt;
        &lt;member&gt;machine3:5799&lt;/member&gt;
        &lt;member&gt;192.168.1.0-7&lt;/member&gt;
        &lt;member&gt;192.168.1.21&lt;/member&gt;
      &lt;/tcp-ip&gt;
    &lt;/join&gt;
    ...
  &lt;/network&gt;
  ...
&lt;/hazelcast&gt;
</code></pre>
<p>As it can be seen, IP addresses or hostnames can be provided for <code>member</code> tags. You can also give a range of IP addresses like <code>192.168.1.0-7</code>.</p>
<p>Instead of providing members line by line, you have the option to use <code>members</code> tag and write comma-separated IP addresses, as shown below.</p>
<p><code>&lt;members&gt;192.168.1.0-7,192.168.1.21&lt;/members&gt;</code></p>
<p>If ports of members are not provided, Hazelcast automatically tries the ports 5701, 5702, and so on.</p>
<p>Hazelcast binds to all local network interfaces to accept incoming traffic, by default. This behavior can be changed using the system property <code>hazelcast.socket.bind.any</code>. When the value of this property is set to <code>false</code>, Hazelcast uses the interfaces specified between <code>interfaces</code> tag (please refer to <em><a href="#specifying-network-interfaces">Specifying Network Interfaces</a></em> section). If there are not any interfaces provided, then it will try to resolve one interface to bind, given in the <code>member</code> tags.</p>
<p>The <code>tcp-ip</code> tag accepts an attribute called <code>connection-timeout-seconds</code> whose default value is 5. Increasing this value is recommended if you have many IPs listed and members cannot properly build up the cluster.</p>
<p>There is also a tag, <code>required-member</code>, to specify a particular cluster member which is wanted to be available before a cluster is formed. </p>
<pre><code class="lang-xml">&lt;hazelcast&gt;
  ...
  &lt;network&gt;
    &lt;join&gt;
      &lt;tcp-ip enabled=&quot;true&quot;&gt;
        &lt;required-member&gt;192.168.1.21&lt;/required-member&gt;
        &lt;member&gt;machine2&lt;/member&gt;
        &lt;member&gt;machine3:5799&lt;/member&gt;
        &lt;member&gt;192.168.1.0-7&lt;/member&gt;
      &lt;/tcp-ip&gt;
    &lt;/join&gt;
    ...
  &lt;/network&gt;
  ...
&lt;/hazelcast&gt;
</code></pre>
<p>In this example, the cluster will not be formed unless the member with IP address 192.168.1.21 is up.
<br></br></p>
<h3 id="specifying-network-interfaces">Specifying Network Interfaces</h3>
<p>You can also specify which network interfaces that Hazelcast should use. Servers mostly have more than one network interface so you may want to list the valid IPs. Range characters (&#39;*&#39; and &#39;-&#39;) can be used for simplicity. So 10.3.10.*, for instance, refers to IPs between 10.3.10.0 and 10.3.10.255. Interface 10.3.10.4-18 refers to IPs between 10.3.10.4 and 10.3.10.18 (4 and 18 included). If network interface configuration is enabled (disabled by default) and if Hazelcast cannot find an matching interface, then it will print a message on console and won&#39;t start on that node.</p>
<pre><code class="lang-xml">&lt;hazelcast&gt;
  ...
  &lt;network&gt;
    ...
    &lt;interfaces enabled=&quot;true&quot;&gt;
      &lt;interface&gt;10.3.16.*&lt;/interface&gt; 
      &lt;interface&gt;10.3.10.4-18&lt;/interface&gt; 
      &lt;interface&gt;192.168.1.3&lt;/interface&gt;         
    &lt;/interfaces&gt;    
  &lt;/network&gt;
  ...
&lt;/hazelcast&gt;
</code></pre>
<p><br></br></p>
<h3 id="ec2-auto-discovery">EC2 Auto Discovery</h3>
<p>Hazelcast supports EC2 Auto Discovery. It is useful when you do not want or cannot provide the list of possible IP addresses. To configure your cluster to be able to use EC2 Auto Discovery, disable join over multicast and TCP/IP and enable AWS. Also provide your credentials (access and secret keys). </p>
<p>You need to add <em>hazelcast-cloud.jar</em> dependency into your project. Note that it is also bundled inside <em>hazelcast-all.jar</em>. Hazelcast cloud  module does not depend on any other third party modules.</p>
<p>Below is a sample configuration. </p>
<pre><code class="lang-xml">&lt;join&gt;
  &lt;multicast enabled=&quot;false&quot;&gt;
    &lt;multicast-group&gt;224.2.2.3&lt;/multicast-group&gt;
    &lt;multicast-port&gt;54327&lt;/multicast-port&gt;
  &lt;/multicast&gt;
  &lt;tcp-ip enabled=&quot;false&quot;&gt;
    &lt;interface&gt;192.168.1.2&lt;/interface&gt;
  &lt;/tcp-ip&gt;
  &lt;aws enabled=&quot;true&quot;&gt;
    &lt;access-key&gt;my-access-key&lt;/access-key&gt;
    &lt;secret-key&gt;my-secret-key&lt;/secret-key&gt;
    &lt;!-- optional, default is us-east-1 --&gt;
    &lt;region&gt;us-west-1&lt;/region&gt;
    &lt;!-- optional, default is ec2.amazonaws.com. If set, region 
         shouldn&#39;t be set as it will override this property --&gt;
    &lt;host-header&gt;ec2.amazonaws.com&lt;/host-header&gt;
    &lt;!-- optional --&gt;
    &lt;security-group-name&gt;hazelcast-sg&lt;/security-group-name&gt;
    &lt;!-- optional --&gt;
    &lt;tag-key&gt;type&lt;/tag-key&gt;
    &lt;!-- optional --&gt;
    &lt;tag-value&gt;hz-nodes&lt;/tag-value&gt;
  &lt;/aws&gt;
&lt;/join&gt;
</code></pre>
<p>The <code>aws</code> tag accepts an attribute called <em>connection-timeout-seconds</em> whose default value is 5. Increasing this value is recommended if you have many IPs listed and members cannot properly build up the cluster.</p>
<p>The parameter <code>region</code> specifies where the members are running. Its default value is <code>us-east-1</code>. If the cluster is running on a different region, it must be specified here. Otherwise, the cluster will not be formed since the members will not discover each other.</p>
<p>The parameters <code>tag-key</code> and <code>tag-value</code> provides unique keys and values to members so that you can create multiple clusters in one data center.</p>
<p>The parameter <code>security-group-name</code> is also used to filter/group members.</p>
<p><img src="images/NoteSmall.jpg" alt="image"> <strong><em>NOTE:</em></strong> <em>If you are using a cloud provider other than AWS, you can use the programmatic configuration specify a TCP/IP cluster. The members will needed to be retrieved from that provider (e.g. JClouds).</em></p>
<h4 id="awsclient">AWSClient</h4>
<p>To make sure EC2 instances are found correctly, AWSClient class can be used. It determines private IP addresses of EC2 instances to be connected. Just give the values of parameters you specified in <code>aws</code> tag to this class, as shown below. You will see whether your EC2 instances are found.</p>
<pre><code class="lang-java">public static void main( String[] args )throws Exception{ 
  AwsConfig config = new AwsConfig(); 
  config.setSecretKey( ... ) ;
  config.setSecretKey( ... );
  config.setRegion( ... );
  config.setSecurityGroupName( ... );
  config.setTagKey( ... );
  config.setTagValue( ... );
  config.setEnabled(&quot;true&quot;);
  AWSClient client = new AWSClient( config );
  List&lt;String&gt; ipAddresses = client.getPrivateIpAddresses();
  System.out.println( &quot;addresses found:&quot; + ipAddresses ); 
  for ( String ip: ipAddresses ) {
    System.out.println( ip ); 
  }
}
</code></pre>
<h4 id="debugging">Debugging</h4>
<p>When and if needed, Hazelcast can log the events for the instances that exist in a region. To see what has happened or trace the activities while forming the cluster, change the log level in your logging mechanism to FINEST or DEBUG. After this change, you can also see whether the instances are accepted or rejected, and the reason of rejection for the rejected instances in the generated log. Note that, changing the log level to one of the mentioned levels may affect the performance of the cluster.</p>
<p><br> </br>
<strong><em>RELATED INFORMATION</em></strong></p>
<p><em>You can download the white paper </em>&quot;Hazelcast on AWS: Best Practices for Deployment&quot;<em> from <a href="http://hazelcast.com/resources/hazelcast-on-aws-best-practices-for-deployment/">Hazelcast.com</a>.</em>
<br> </br></p>
<h3 id="ports">Ports</h3>
<p>You can specify the ports which Hazelcast will use to communicate between cluster members. The name of the parameter for this is <code>port</code> and its default value is <code>5701</code>.</p>
<pre><code class="lang-xml">&lt;network&gt;
  &lt;port&gt;5701&lt;/port&gt;
&lt;/network&gt;
</code></pre>
<p>By default, Hazelcast will try 100 ports to bind. Meaning that, if you set the value of port as 5701, as members are joining to the cluster, Hazelcast tries to find ports between 5701 and 5801. </p>
<p>You can choose to change the port count in the cases like having large instances on a single machine or willing to have only a few ports to be assigned. The parameter <code>port-count</code> is used for this purpose, whose default value is 100.</p>
<pre><code class="lang-xml">&lt;network&gt;
  &lt;port port-count=&quot;20&quot;&gt;5781&lt;/port&gt;
&lt;/network&gt;
</code></pre>
<p>According to the above example, Hazelcast will try to find free ports between 5781 and 5801. Normally, you will not need to change this value, but it will come very handy when needed. You may also want to choose to use only one port. In that case, you can disable the auto-increment feature of <code>port</code>, as shown below.</p>
<pre><code class="lang-xml">&lt;network&gt;
  &lt;port auto-increment=&quot;false&quot;&gt;5701&lt;/port&gt;
&lt;/network&gt;
</code></pre>
<p>Naturally, the parameter <code>port-count</code> is ignored when the above configuration is made.</p>
<h4 id="outbound-ports">Outbound Ports</h4>
<p>By default, Hazelcast lets the system to pick up an ephemeral port during socket bind operation. But security policies/firewalls may require to restrict outbound ports to be used by Hazelcast enabled applications. To fulfill this requirement, you can configure Hazelcast to use only defined outbound ports.</p>
<pre><code class="lang-xml">&lt;hazelcast&gt;
  ...
  &lt;network&gt;
    &lt;port auto-increment=&quot;true&quot;&gt;5701&lt;/port&gt;
    &lt;outbound-ports&gt;
      &lt;!-- ports between 33000 and 35000 --&gt;
      &lt;ports&gt;33000-35000&lt;/ports&gt;
      &lt;!-- comma separated ports --&gt;
      &lt;ports&gt;37000,37001,37002,37003&lt;/ports&gt; 
      &lt;ports&gt;38000,38500-38600&lt;/ports&gt;
    &lt;/outbound-ports&gt;
    ...
  &lt;/network&gt;
  ...
&lt;/hazelcast&gt;
</code></pre>
<p>Or, by programmatically:</p>
<pre><code class="lang-java">...
NetworkConfig networkConfig = config.getNetworkConfig();
// ports between 35000 and 35100
networkConfig.addOutboundPortDefinition(&quot;35000-35100&quot;);
// comma separated ports
networkConfig.addOutboundPortDefinition(&quot;36001, 36002, 36003&quot;);
networkConfig.addOutboundPort(37000);
networkConfig.addOutboundPort(37001);
...
</code></pre>
<p><img src="images/NoteSmall.jpg" alt="image"> <strong><em>NOTE:</em></strong> <em>You can use port ranges and/or comma separated ports.</em>
<br></br></p>
<h3 id="ipv6-support">IPv6 Support</h3>
<p>Hazelcast supports IPv6 addresses seamlessly (This support is switched off by default, please see the note at the end of this section).</p>
<p>All you need is to define IPv6 addresses or interfaces in <a href="#network-configuration">network configuration</a>. Only limitation at the moment is that you cannot define wildcard IPv6 addresses in <a href="#configuring-tcp-ip-cluster">TCP-IP</a> join configuration. <a href="#specifying-network-interfaces">Interfaces</a> section does not have this limitation, you can configure wildcard IPv6 interfaces same as IPv4 interfaces.</p>
<pre><code class="lang-xml">&lt;hazelcast&gt;
  ...
  &lt;network&gt;
    &lt;port auto-increment=&quot;true&quot;&gt;5701&lt;/port&gt;
    &lt;join&gt;
      &lt;multicast enabled=&quot;false&quot;&gt;
        &lt;multicast-group&gt;FF02:0:0:0:0:0:0:1&lt;/multicast-group&gt;
        &lt;multicast-port&gt;54327&lt;/multicast-port&gt;
      &lt;/multicast&gt;
      &lt;tcp-ip enabled=&quot;true&quot;&gt;
        &lt;member&gt;[fe80::223:6cff:fe93:7c7e]:5701&lt;/member&gt;
        &lt;interface&gt;192.168.1.0-7&lt;/interface&gt;
        &lt;interface&gt;192.168.1.*&lt;/interface&gt;
        &lt;interface&gt;fe80:0:0:0:45c5:47ee:fe15:493a&lt;/interface&gt;
      &lt;/tcp-ip&gt;
    &lt;/join&gt;
    &lt;interfaces enabled=&quot;true&quot;&gt;
      &lt;interface&gt;10.3.16.*&lt;/interface&gt;
      &lt;interface&gt;10.3.10.4-18&lt;/interface&gt;
      &lt;interface&gt;fe80:0:0:0:45c5:47ee:fe15:*&lt;/interface&gt;
      &lt;interface&gt;fe80::223:6cff:fe93:0-5555&lt;/interface&gt;
    &lt;/interfaces&gt;
    ...
  &lt;/network&gt;
  ...
&lt;/hazelcast&gt;
</code></pre>
<p>JVM has two system properties for setting the preferred protocol stack (IPv4 or IPv6) as well as the preferred address family types (inet4 or inet6). On a dual stack machine, IPv6 stack is preferred by default, this can be changed through <code>java.net.preferIPv4Stack=&lt;true|false&gt;</code> system property. And when querying name services, JVM prefers IPv4 addressed over IPv6 addresses and will return an IPv4 address if possible. This can be changed through <code>java.net.preferIPv6Addresses=&lt;true|false&gt;</code> system property.</p>
<p>Also see additional <a href="http://docs.oracle.com/javase/1.5.0/docs/guide/net/ipv6_guide/query.html#details">details on IPv6 support in Java</a>.</p>
<p><img src="images/NoteSmall.jpg" alt="image"> <strong><em>NOTE:</em></strong> <em>IPv6 support has been switched off by default, since some platforms have issues in use of IPv6 stack. Some other platforms such as Amazon AWS have no support at all. To enable IPv6 support, just set configuration property <code>hazelcast.prefer.ipv4.stack</code> to </em>false<em>. See <a href="#advanced-configuration-properties">Advanced Configuration Properties</a>.</em>
<br></br></p>
<h3 id="partition-grouping">Partition Grouping</h3>
<p>Hazelcast distributes key objects into partitions using a consistent hashing algorithm and those partitions are assigned to nodes. That means an entry is stored in a node which is owner of partition to which entry&#39;s key is assigned. Total partition count is 271 by default and can be changed with configuration property <code>hazelcast.map.partition.count</code>. Please see <a href="#advanced-configuration-properties">Advanced Configuration Properties</a>.</p>
<p>Along with those partitions, there are also copies of them as backups. Backup partitions can have multiple copies due to backup count defined in configuration, such as first backup partition, second backup partition, etc. As a rule, a node can not hold more than one copy of a partition (ownership or backup). By default Hazelcast distributes partitions and their backup copies randomly and equally among cluster nodes assuming all nodes in the cluster are identical.</p>
<p>Now; What if some nodes share same JVM or physical machine or chassis and you want backups of these nodes to be assigned to nodes in another machine or chassis? What if processing or memory capacities of some nodes are different and you do not want equal number of partitions to be assigned to all nodes?</p>
<p>You can group nodes in the same JVM (or physical machine) or nodes located in the same chassis. Or, you can group nodes to create identical capacity. We call these groups <strong>partition groups</strong>. This way partitions are assigned to those partition groups instead of single nodes. And backups of these partitions are located in another partition group.</p>
<p>When you enable partition grouping, Hazelcast presents three choices to configure partition groups at the moment.</p>
<ul>
<li>First one is to group nodes automatically using IP addresses of nodes, so nodes sharing same network interface will be grouped together. All members on the same host (IP address or domain name) will be a single partition group. This helps to avoid data loss when a physical server crashes by not storing multiple replicas of the same partition on the same host. But if there are multiple network interfaces or domain names per physical machine, that will make this assumption invalid.</li>
</ul>
<pre><code class="lang-xml">&lt;partition-group enabled=&quot;true&quot; group-type=&quot;HOST_AWARE&quot; /&gt;
</code></pre>
<pre><code class="lang-java">Config config = ...;
PartitionGroupConfig partitionGroupConfig = config.getPartitionGroupConfig();
partitionGroupConfig.setEnabled( true )
    .setGroupType( MemberGroupType.HOST_AWARE );
</code></pre>
<ul>
<li>Second one is custom grouping using Hazelcast&#39;s interface matching configuration. This way, you can add different and multiple interfaces to a group. You can also use wildcards in interface addresses. For example, the users can create rack aware or data warehouse partition groups using custom partition grouping.</li>
</ul>
<pre><code class="lang-xml">&lt;partition-group enabled=&quot;true&quot; group-type=&quot;CUSTOM&quot;&gt;
&lt;member-group&gt;
  &lt;interface&gt;10.10.0.*&lt;/interface&gt;
  &lt;interface&gt;10.10.3.*&lt;/interface&gt;
  &lt;interface&gt;10.10.5.*&lt;/interface&gt;
&lt;/member-group&gt;
&lt;member-group&gt;
  &lt;interface&gt;10.10.10.10-100&lt;/interface&gt;
  &lt;interface&gt;10.10.1.*&lt;/interface&gt;
  &lt;interface&gt;10.10.2.*&lt;/interface&gt;
&lt;/member-group
&lt;/partition-group&gt;
</code></pre>
<pre><code class="lang-java">Config config = ...;
PartitionGroupConfig partitionGroupConfig = config.getPartitionGroupConfig();
partitionGroupConfig.setEnabled( true )
    .setGroupType( MemberGroupType.CUSTOM );

MemberGroupConfig memberGroupConfig = new MemberGroupConfig();
memberGroupConfig.addInterface( &quot;10.10.0.*&quot; )
.addInterface( &quot;10.10.3.*&quot; ).addInterface(&quot;10.10.5.*&quot; );

MemberGroupConfig memberGroupConfig2 = new MemberGroupConfig();
memberGroupConfig2.addInterface( &quot;10.10.10.10-100&quot; )
.addInterface( &quot;10.10.1.*&quot;).addInterface( &quot;10.10.2.*&quot; );

partitionGroupConfig.addMemberGroupConfig( memberGroupConfig );
partitionGroupConfig.addMemberGroupConfig( memberGroupConfig2 );
</code></pre>
<ul>
<li>Third one is to give every member their own group. Meaning that, each member is a group of its own and primary and backup partitions are distributed randomly (not on the same physical member). This gives the least amount of protection and is the default configuration for a Hazelcast cluster.</li>
</ul>
<pre><code class="lang-xml">&lt;partition-group enabled=&quot;true&quot; group-type=&quot;PER_MEMBER&quot; /&gt;
</code></pre>
<pre><code class="lang-java">Config config = ...;
PartitionGroupConfig partitionGroupConfig = config.getPartitionGroupConfig();
partitionGroupConfig.setEnabled( true )
    .setGroupType( MemberGroupType.PER_MEMBER );
</code></pre>
<h2 id="listener-configurations">Listener Configurations</h2>
<p>Event listeners can be added to and removed from the related object using Hazelcast API.</p>
<p>Downside of attaching listeners using API is the possibility of missing events between creation of object and registering listener. To overcome this race condition, Hazelcast introduces registration of listeners in configuration. Listeners can be registered using either declarative, programmatic or Spring configuration.</p>
<ul>
<li><p><strong>MembershipListener</strong></p>
<ul>
<li><p>Declarative Configuration</p>
<pre><code class="lang-xml">&lt;listeners&gt;
 &lt;listener&gt;com.hazelcast.examples.MembershipListener&lt;/listener&gt;
&lt;/listeners&gt;
</code></pre>
</li>
<li><p>Programmatic Configuration</p>
<pre><code class="lang-java">config.addListenerConfig(
   new ListenerConfig( &quot;com.hazelcast.examples.MembershipListener&quot; ) );
</code></pre>
</li>
<li><p>Spring XML configuration</p>
<pre><code class="lang-xml">&lt;hz:listeners&gt;
 &lt;hz:listener class-name=&quot;com.hazelcast.spring.DummyMembershipListener&quot;/&gt;
 &lt;hz:listener implementation=&quot;dummyMembershipListener&quot;/&gt;
&lt;/hz:listeners&gt;
</code></pre>
</li>
</ul>
</li>
<li><p><strong>DistributedObjectListener</strong></p>
<ul>
<li><p>Declarative Configuration</p>
<pre><code class="lang-xml">&lt;listeners&gt;
 &lt;listener&gt;com.hazelcast.examples.DistributedObjectListener&lt;/listener&gt;
&lt;/listeners&gt;
</code></pre>
</li>
<li><p>Programmatic Configuration</p>
<pre><code class="lang-java">config.addListenerConfig(
   new ListenerConfig( &quot;com.hazelcast.examples.DistributedObjectListener&quot; ) );
</code></pre>
</li>
<li><p>Spring XML configuration</p>
<pre><code class="lang-xml">&lt;hz:listeners&gt;
 &lt;hz:listener class-name=&quot;com.hazelcast.spring.DummyDistributedObjectListener&quot;/&gt;
 &lt;hz:listener implementation=&quot;dummyDistributedObjectListener&quot;/&gt;
&lt;/hz:listeners&gt;
</code></pre>
</li>
</ul>
</li>
<li><p><strong>MigrationListener</strong></p>
<ul>
<li><p>Declarative Configuration</p>
<pre><code class="lang-xml">&lt;listeners&gt;
 &lt;listener&gt;com.hazelcast.examples.MigrationListener&lt;/listener&gt;
&lt;/listeners&gt;
</code></pre>
</li>
<li><p>Programmatic Configuration</p>
<pre><code class="lang-java">config.addListenerConfig( 
   new ListenerConfig( &quot;com.hazelcast.examples.MigrationListener&quot; ) );
</code></pre>
</li>
<li><p>Spring XML configuration</p>
<pre><code class="lang-xml">&lt;hz:listeners&gt;
 &lt;hz:listener class-name=&quot;com.hazelcast.spring.DummyMigrationListener&quot;/&gt;
 &lt;hz:listener implementation=&quot;dummyMigrationListener&quot;/&gt;
&lt;/hz:listeners&gt;
</code></pre>
</li>
</ul>
</li>
<li><p><strong>LifecycleListener</strong></p>
<ul>
<li><p>Declarative Configuration</p>
<pre><code class="lang-xml">&lt;listeners&gt;
 &lt;listener&gt;com.hazelcast.examples.LifecycleListener&lt;/listener&gt;
&lt;/listeners&gt;
</code></pre>
</li>
<li><p>Programmatic Configuration</p>
<pre><code class="lang-java">config.addListenerConfig(
   new ListenerConfig( &quot;com.hazelcast.examples.LifecycleListener&quot; ) );
</code></pre>
</li>
<li><p>Spring XML configuration</p>
<pre><code class="lang-xml">&lt;hz:listeners&gt;
 &lt;hz:listener class-name=&quot;com.hazelcast.spring.DummyLifecycleListener&quot;/&gt;
 &lt;hz:listener implementation=&quot;dummyLifecycleListener&quot;/&gt;
&lt;/hz:listeners&gt;
</code></pre>
</li>
</ul>
</li>
<li><p><strong>EntryListener</strong> for IMap</p>
<ul>
<li><p>Declarative Configuration</p>
<pre><code class="lang-xml">&lt;map name=&quot;default&quot;&gt;
 ...
 &lt;entry-listeners&gt;
   &lt;entry-listener include-value=&quot;true&quot; local=&quot;false&quot;&gt;
       com.hazelcast.examples.EntryListener
   &lt;/entry-listener&gt;
 &lt;/entry-listeners&gt;
&lt;/map&gt;
</code></pre>
</li>
<li><p>Programmatic Configuration</p>
<pre><code class="lang-java">mapConfig.addEntryListenerConfig(
   new EntryListenerConfig( &quot;com.hazelcast.examples.EntryListener&quot;, 
                            false, false ) );
</code></pre>
</li>
<li><p>Spring XML configuration</p>
<pre><code class="lang-xml">&lt;hz:map name=&quot;default&quot;&gt;
 &lt;hz:entry-listeners&gt;
   &lt;hz:entry-listener include-value=&quot;true&quot;
        class-name=&quot;com.hazelcast.spring.DummyEntryListener&quot;/&gt;
   &lt;hz:entry-listener implementation=&quot;dummyEntryListener&quot; local=&quot;true&quot;/&gt;
 &lt;/hz:entry-listeners&gt;
&lt;/hz:map&gt;
</code></pre>
</li>
</ul>
</li>
<li><p><strong>EntryListener</strong> for MultiMap</p>
<ul>
<li><p>Declarative Configuration</p>
<pre><code class="lang-xml">&lt;multimap name=&quot;default&quot;&gt;
 &lt;value-collection-type&gt;SET&lt;/value-collection-type&gt;
   &lt;entry-listeners&gt;
     &lt;entry-listener include-value=&quot;true&quot; local=&quot;false&quot;&gt;
         com.hazelcast.examples.EntryListener
     &lt;/entry-listener&gt;
   &lt;/entry-listeners&gt;
&lt;/multimap&gt;
</code></pre>
</li>
<li><p>Programmatic Configuration</p>
<pre><code class="lang-java">multiMapConfig.addEntryListenerConfig(
   new EntryListenerConfig( &quot;com.hazelcast.examples.EntryListener&quot;,
                            false, false ) );
</code></pre>
</li>
<li><p>Spring XML configuration</p>
<pre><code class="lang-xml">&lt;hz:multimap name=&quot;default&quot; value-collection-type=&quot;LIST&quot;&gt;
 &lt;hz:entry-listeners&gt;
   &lt;hz:entry-listener include-value=&quot;true&quot;
        class-name=&quot;com.hazelcast.spring.DummyEntryListener&quot;/&gt;
   &lt;hz:entry-listener implementation=&quot;dummyEntryListener&quot; local=&quot;true&quot;/&gt;
 &lt;/hz:entry-listeners&gt;
&lt;/hz:multimap&gt;
</code></pre>
</li>
</ul>
</li>
<li><p><strong>ItemListener</strong> for IQueue</p>
<ul>
<li><p>Declarative Configuration</p>
<pre><code class="lang-xml">&lt;queue name=&quot;default&quot;&gt;
 ...
 &lt;item-listeners&gt;
   &lt;item-listener include-value=&quot;true&quot;&gt;
       com.hazelcast.examples.ItemListener
   &lt;/item-listener&gt;
 &lt;/item-listeners&gt;
&lt;/queue&gt;
</code></pre>
</li>
<li><p>Programmatic Configuration</p>
<pre><code class="lang-java">queueConfig.addItemListenerConfig(
   new ItemListenerConfig( &quot;com.hazelcast.examples.ItemListener&quot;, true ) );
</code></pre>
</li>
<li><p>Spring XML configuration</p>
<pre><code class="lang-xml">&lt;hz:queue name=&quot;default&quot; &gt;
 &lt;hz:item-listeners&gt;
   &lt;hz:item-listener include-value=&quot;true&quot;
       class-name=&quot;com.hazelcast.spring.DummyItemListener&quot;/&gt;
 &lt;/hz:item-listeners&gt;
&lt;/hz:queue&gt;
</code></pre>
</li>
</ul>
</li>
<li><p><strong>MessageListener</strong> for ITopic</p>
<ul>
<li><p>Declarative Configuration</p>
<pre><code class="lang-xml">&lt;topic name=&quot;default&quot;&gt;
 &lt;message-listeners&gt;
   &lt;message-listener&gt;
       com.hazelcast.examples.MessageListener
   &lt;/message-listener&gt;
 &lt;/message-listeners&gt;
&lt;/topic&gt;
</code></pre>
</li>
<li><p>Programmatic Configuration</p>
<pre><code class="lang-java">topicConfig.addMessageListenerConfig(
   new ListenerConfig( &quot;com.hazelcast.examples.MessageListener&quot; ) );
</code></pre>
</li>
<li><p>Spring XML configuration</p>
<pre><code class="lang-xml">&lt;hz:topic name=&quot;default&quot;&gt;
 &lt;hz:message-listeners&gt;
   &lt;hz:message-listener 
       class-name=&quot;com.hazelcast.spring.DummyMessageListener&quot;/&gt;
 &lt;/hz:message-listeners&gt;
&lt;/hz:topic&gt;
</code></pre>
</li>
</ul>
</li>
<li><p><strong>ClientListener</strong> </p>
<ul>
<li><p>Declarative Configuration</p>
<pre><code class="lang-xml">&lt;listeners&gt;
 &lt;listener&gt;com.hazelcast.examples.ClientListener&lt;/listener&gt;
&lt;/listeners&gt;
</code></pre>
</li>
<li><p>Programmatic Configuration</p>
<pre><code class="lang-java">topicConfig.addMessageListenerConfig(
   new ListenerConfig( &quot;com.hazelcast.examples.ClientListener&quot; ) );
</code></pre>
</li>
<li><p>Spring XML configuration</p>
<pre><code class="lang-xml">&lt;hz:listeners&gt;
 &lt;hz:listener class-name=&quot;com.hazelcast.spring.DummyClientListener&quot;/&gt;
 &lt;hz:listener implementation=&quot;dummyClientListener&quot;/&gt;
&lt;/hz:listeners&gt;
</code></pre>
</li>
</ul>
</li>
</ul>
<h2 id="logging-configuration">Logging Configuration</h2>
<p>Hazelcast has a flexible logging configuration and does not depend on any logging framework except JDK logging. It has in-built adaptors for a number of logging frameworks and also supports custom loggers by providing logging interfaces.</p>
<p>To use built-in adaptors, you should set <code>hazelcast.logging.type</code> property to one of predefined types below.</p>
<ul>
<li><p><strong>jdk</strong>: JDK logging (default)</p>
</li>
<li><p><strong>log4j</strong>: Log4j</p>
</li>
<li><p><strong>slf4j</strong>: Slf4j</p>
</li>
<li><p><strong>none</strong>: disable logging</p>
</li>
</ul>
<p>You can set <code>hazelcast.logging.type</code> through declarative configuration, programmatic configuration or JVM system property.</p>
<p><img src="images/NoteSmall.jpg" alt="image"> <strong><em>NOTE:</em></strong> <em>If you choose to use <code>log4j</code> or <code>slf4j</code>, proper dependencies should be included in the classpath.</em>
<br></br></p>
<ul>
<li><strong>Declarative Configuration</strong></li>
</ul>
<pre><code class="lang-xml">&lt;hazelcast xsi:schemaLocation=&quot;http://www.hazelcast.com/schema/config
    http://www.hazelcast.com/schema/config/hazelcast-config-3.0.xsd&quot;
    xmlns=&quot;http://www.hazelcast.com/schema/config&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&gt;

  ....

  &lt;properties&gt;
    &lt;property name=&quot;hazelcast.logging.type&quot;&gt;jdk&lt;/property&gt;
    ....
  &lt;/properties&gt;
&lt;/hazelcast&gt;
</code></pre>
<ul>
<li><strong>Programmatic Configuration</strong></li>
</ul>
<pre><code class="lang-java">Config config = new Config() ;
config.setProperty( &quot;hazelcast.logging.type&quot;, &quot;log4j&quot; );
</code></pre>
<ul>
<li><p><strong>System Property</strong></p>
<ul>
<li>Using JVM parameter: <code>java -Dhazelcast.logging.type=slf4j</code></li>
<li>Using System class: <code>System.setProperty( &quot;hazelcast.logging.type&quot;, &quot;none&quot; );</code></li>
</ul>
</li>
</ul>
<p>If provided logging mechanisms are not satisfactory, you can implement your own using the custom logging feature. To use it, you should implement <code>com.hazelcast.logging.LoggerFactory</code> and <code>com.hazelcast.logging.ILogger</code> interfaces and set system property <code>hazelcast.logging.class</code> as your custom <code>LoggerFactory</code> class name.</p>
<pre><code class="lang-plain">-Dhazelcast.logging.class=foo.bar.MyLoggingFactory
</code></pre>
<p>You can also listen to logging events generated by Hazelcast runtime by registering <code>LogListener</code>s to <code>LoggingService</code>.</p>
<pre><code class="lang-java">LogListener listener = new LogListener() {
  public void log( LogEvent logEvent ) {
    // do something
  }
}
HazelcastInstance instance = Hazelcast.newHazelcastInstance();
LoggingService loggingService = instance.getLoggingService();
loggingService.addLogListener( Level.INFO, listener );
</code></pre>
<p>Through the <code>LoggingService</code>, you can get the currently used ILogger implementation and log your own messages, too.</p>
<p><img src="images/NoteSmall.jpg" alt="image"> <strong><em>NOTE:</em></strong> <em>If you are not using command line for configuring logging, you should be careful about Hazelcast classes. They may be defaulted to <code>jdk</code> logging before newly configured logging is read. When logging mechanism is selected, it will not change.</em></p>
<p><br></br></p>
<h2 id="advanced-configuration-properties">Advanced Configuration Properties</h2>
<p>Hazelcast has advanced configuration properties to tune some aspects of it. These can be set as property name and value pairs through declarative configuration, programmatic configuration or JVM system property.</p>
<h3 id="declarative-configuration">Declarative Configuration</h3>
<pre><code class="lang-xml">&lt;hazelcast xsi:schemaLocation=&quot;http://www.hazelcast.com/schema/config
    http://www.hazelcast.com/schema/config/hazelcast-config-3.0.xsd&quot;
    xmlns=&quot;http://www.hazelcast.com/schema/config&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&gt;

  ....
  &lt;properties&gt;
    &lt;property name=&quot;hazelcast.property.foo&quot;&gt;value&lt;/property&gt;
    ....
  &lt;/properties&gt;
&lt;/hazelcast&gt;
</code></pre>
<h3 id="programmatic-configuration">Programmatic Configuration</h3>
<pre><code class="lang-java">Config config = new Config() ;
config.setProperty( &quot;hazelcast.property.foo&quot;, &quot;value&quot; );
</code></pre>
<h3 id="system-property">System Property</h3>
<ol>
<li><p>Using JVM parameter: <code>java -Dhazelcast.property.foo=value</code></p>
</li>
<li><p>Using System class: <code>System.setProperty( &quot;hazelcast.property.foo&quot;, &quot;value&quot; );</code></p>
</li>
</ol>
<p>Below table lists the advanced configuration properties with their descriptions.</p>
<table>
<thead>
<tr>
<th style="text-align:left">Property Name</th>
<th style="text-align:left">Default Value</th>
<th style="text-align:left">Type</th>
<th style="text-align:left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>hazelcast.health.monitoring.level</code></td>
<td style="text-align:left">SILENT</td>
<td style="text-align:left">string</td>
<td style="text-align:left">Health monitoring log level. When <em>SILENT</em>, logs are printed only when values exceed some predefined threshold. When <em>NOISY</em>, logs are always printed periodically. Set <em>OFF</em> to turn off completely.  </td>
</tr>
<tr>
<td style="text-align:left"><code>hazelcast.health.monitoring.delay.seconds</code></td>
<td style="text-align:left">30</td>
<td style="text-align:left">int</td>
<td style="text-align:left">Health monitoring logging interval in seconds.</td>
</tr>
<tr>
<td style="text-align:left"><code>hazelcast.version.check.enabled</code></td>
<td style="text-align:left">true</td>
<td style="text-align:left">bool</td>
<td style="text-align:left">Enable Hazelcast new version check on startup.</td>
</tr>
<tr>
<td style="text-align:left"><code>hazelcast.prefer.ipv4.stack</code></td>
<td style="text-align:left">true</td>
<td style="text-align:left">bool</td>
<td style="text-align:left">Prefer Ipv4 network interface when picking a local address.</td>
</tr>
<tr>
<td style="text-align:left"><code>hazelcast.io.thread.count</code></td>
<td style="text-align:left">3</td>
<td style="text-align:left">int</td>
<td style="text-align:left">Number of input and output threads.</td>
</tr>
<tr>
<td style="text-align:left"><code>hazelcast.operation.thread.count</code></td>
<td style="text-align:left">-1</td>
<td style="text-align:left">int</td>
<td style="text-align:left">Number of partition based operation handler threads. <code>-1</code> means CPU core count x 2.</td>
</tr>
<tr>
<td style="text-align:left"><code>hazelcast.operation.generic.thread.count</code></td>
<td style="text-align:left">-1</td>
<td style="text-align:left">int</td>
<td style="text-align:left">Number of generic operation handler threads. <code>-1</code> means CPU core count x 2.</td>
</tr>
<tr>
<td style="text-align:left"><code>hazelcast.event.thread.count</code></td>
<td style="text-align:left">5</td>
<td style="text-align:left">int</td>
<td style="text-align:left">Number of event handler threads.</td>
</tr>
<tr>
<td style="text-align:left"><code>hazelcast.event.queue.capacity</code></td>
<td style="text-align:left">1000000</td>
<td style="text-align:left">int</td>
<td style="text-align:left">Capacity of internal event queue.</td>
</tr>
<tr>
<td style="text-align:left"><code>hazelcast.event.queue.timeout.millis</code></td>
<td style="text-align:left">250</td>
<td style="text-align:left">int</td>
<td style="text-align:left">Timeout to enqueue events to event queue.</td>
</tr>
<tr>
<td style="text-align:left"><code>hazelcast.connect.all.wait.seconds</code></td>
<td style="text-align:left">120</td>
<td style="text-align:left">int</td>
<td style="text-align:left">Timeout to connect all other cluster members when a member is joining to a cluster.</td>
</tr>
<tr>
<td style="text-align:left"><code>hazelcast.memcache.enabled</code></td>
<td style="text-align:left">true</td>
<td style="text-align:left">bool</td>
<td style="text-align:left">Enable <a href="#memcache-client">Memcache</a> client request listener service.</td>
</tr>
<tr>
<td style="text-align:left"><code>hazelcast.rest.enabled</code></td>
<td style="text-align:left">true</td>
<td style="text-align:left">bool</td>
<td style="text-align:left">Enable <a href="#rest-client">REST</a> client request listener service.</td>
</tr>
<tr>
<td style="text-align:left"><code>hazelcast.map.load.chunk.size</code></td>
<td style="text-align:left">1000</td>
<td style="text-align:left">int</td>
<td style="text-align:left">Chunk size for <a href="#persistence">MapLoader</a> &#39;s map initialization process (MapLoder.loadAllKeys()).</td>
</tr>
<tr>
<td style="text-align:left"><code>hazelcast.merge.first.run.delay.seconds</code></td>
<td style="text-align:left">300</td>
<td style="text-align:left">int</td>
<td style="text-align:left">Initial run delay of <a href="#network-partitioning-split-brain-syndrome">split brain/merge process</a> in seconds.</td>
</tr>
<tr>
<td style="text-align:left"><code>hazelcast.merge.next.run.delay.seconds</code></td>
<td style="text-align:left">120</td>
<td style="text-align:left">int</td>
<td style="text-align:left">Run interval of <a href="#network-partitioning-split-brain-syndrome">split brain/merge process</a> in seconds.</td>
</tr>
<tr>
<td style="text-align:left"><code>hazelcast.operation.call.timeout.millis</code></td>
<td style="text-align:left">60000</td>
<td style="text-align:left">int</td>
<td style="text-align:left">Timeout to wait for a response when a remote call is sent, in milliseconds.</td>
</tr>
<tr>
<td style="text-align:left"><code>hazelcast.socket.bind.any</code></td>
<td style="text-align:left">true</td>
<td style="text-align:left">bool</td>
<td style="text-align:left">Bind both server-socket and client-sockets to any local interface.</td>
</tr>
<tr>
<td style="text-align:left"><code>hazelcast.socket.server.bind.any</code></td>
<td style="text-align:left">true</td>
<td style="text-align:left">bool</td>
<td style="text-align:left">Bind server-socket to any local interface. If not set, <code>hazelcast.socket.bind.any</code> will be used as default.</td>
</tr>
<tr>
<td style="text-align:left"><code>hazelcast.socket.client.bind.any</code></td>
<td style="text-align:left">true</td>
<td style="text-align:left">bool</td>
<td style="text-align:left">Bind client-sockets to any local interface. If not set, <code>hazelcast.socket.bind.any</code> will be used as default.</td>
</tr>
<tr>
<td style="text-align:left"><code>hazelcast.socket.client.bind</code></td>
<td style="text-align:left">true</td>
<td style="text-align:left">bool</td>
<td style="text-align:left">Bind client socket to an interface when connecting to a remote server socket. When set to <code>false</code>, client socket is not bound to any interface.</td>
</tr>
<tr>
<td style="text-align:left"><code>hazelcast.socket.receive.buffer.size</code></td>
<td style="text-align:left">32</td>
<td style="text-align:left">int</td>
<td style="text-align:left">Socket receive buffer (<code>SO_RCVBUF</code>) size in KB.</td>
</tr>
<tr>
<td style="text-align:left"><code>hazelcast.socket.send.buffer.size</code></td>
<td style="text-align:left">32</td>
<td style="text-align:left">int</td>
<td style="text-align:left">Socket send buffer (<code>SO_SNDBUF</code>) size in KB.</td>
</tr>
<tr>
<td style="text-align:left"><code>hazelcast.socket.linger.seconds</code></td>
<td style="text-align:left">0</td>
<td style="text-align:left">int</td>
<td style="text-align:left">Set socket <code>SO_LINGER</code> option.</td>
</tr>
<tr>
<td style="text-align:left"><code>hazelcast.socket.keep.alive</code></td>
<td style="text-align:left">true</td>
<td style="text-align:left">bool</td>
<td style="text-align:left">Socket set keep alive (<code>SO_KEEPALIVE</code>).</td>
</tr>
<tr>
<td style="text-align:left"><code>hazelcast.socket.no.delay</code></td>
<td style="text-align:left">true</td>
<td style="text-align:left">bool</td>
<td style="text-align:left">Socket set TCP no delay.</td>
</tr>
<tr>
<td style="text-align:left"><code>hazelcast.shutdownhook.enabled</code></td>
<td style="text-align:left">true</td>
<td style="text-align:left">bool</td>
<td style="text-align:left">Enable Hazelcast shutdownhook thread.</td>
</tr>
<tr>
<td style="text-align:left"><code>hazelcast.wait.seconds.before.join</code></td>
<td style="text-align:left">5</td>
<td style="text-align:left">int</td>
<td style="text-align:left">Wait time before join operation.</td>
</tr>
<tr>
<td style="text-align:left"><code>hazelcast.max.join.seconds</code></td>
<td style="text-align:left">300</td>
<td style="text-align:left">int</td>
<td style="text-align:left">Join timeout, maximum time to try to join before giving.</td>
</tr>
<tr>
<td style="text-align:left"><code>hazelcast.max.join.merge.target.seconds</code></td>
<td style="text-align:left">20</td>
<td style="text-align:left">int</td>
<td style="text-align:left">Split-brain merge timeout for a specific target.</td>
</tr>
<tr>
<td style="text-align:left"><code>hazelcast.max.wait.seconds.before.join</code></td>
<td style="text-align:left">20</td>
<td style="text-align:left">int</td>
<td style="text-align:left">Maximum wait time before join operation.</td>
</tr>
<tr>
<td style="text-align:left"><code>hazelcast.heartbeat.interval.seconds</code></td>
<td style="text-align:left">1</td>
<td style="text-align:left">int</td>
<td style="text-align:left">Heartbeat send interval in seconds.</td>
</tr>
<tr>
<td style="text-align:left"><code>hazelcast.max.no.heartbeat.seconds</code></td>
<td style="text-align:left">500</td>
<td style="text-align:left">int</td>
<td style="text-align:left">Max timeout of heartbeat in seconds for a node to assume it is dead.</td>
</tr>
<tr>
<td style="text-align:left"><code>hazelcast.max.no.master.confirmation.seconds</code></td>
<td style="text-align:left">450</td>
<td style="text-align:left">int</td>
<td style="text-align:left">Max timeout of master confirmation from other nodes.</td>
</tr>
<tr>
<td style="text-align:left"><code>hazelcast.master.confirmation.interval.seconds</code></td>
<td style="text-align:left">30</td>
<td style="text-align:left">int</td>
<td style="text-align:left">Interval at which nodes send master confirmation.</td>
</tr>
<tr>
<td style="text-align:left"><code>hazelcast.member.list.publish.interval.seconds</code></td>
<td style="text-align:left">600</td>
<td style="text-align:left">int</td>
<td style="text-align:left">Interval at which master node publishes a member list.</td>
</tr>
<tr>
<td style="text-align:left"><code>hazelcast.icmp.enabled</code></td>
<td style="text-align:left">false</td>
<td style="text-align:left">bool</td>
<td style="text-align:left">Enable ICMP ping.</td>
</tr>
<tr>
<td style="text-align:left"><code>hazelcast.icmp.timeout</code></td>
<td style="text-align:left">1000</td>
<td style="text-align:left">int</td>
<td style="text-align:left">ICMP timeout in ms.</td>
</tr>
<tr>
<td style="text-align:left"><code>hazelcast.icmp.ttl</code></td>
<td style="text-align:left">0</td>
<td style="text-align:left">int</td>
<td style="text-align:left">ICMP TTL (maximum numbers of hops to try).</td>
</tr>
<tr>
<td style="text-align:left"><code>hazelcast.initial.min.cluster.size</code></td>
<td style="text-align:left">0</td>
<td style="text-align:left">int</td>
<td style="text-align:left">Initial expected cluster size to wait before node to start completely.</td>
</tr>
<tr>
<td style="text-align:left"><code>hazelcast.initial.wait.seconds</code></td>
<td style="text-align:left">0</td>
<td style="text-align:left">int</td>
<td style="text-align:left">Initial time in seconds to wait before node to start completely.</td>
</tr>
<tr>
<td style="text-align:left"><code>hazelcast.map.replica.wait.seconds.for.scheduled.tasks</code></td>
<td style="text-align:left">10</td>
<td style="text-align:left">int</td>
<td style="text-align:left">Scheduler delay for map tasks those will be executed on backup members.</td>
</tr>
<tr>
<td style="text-align:left"><code>hazelcast.partition.count</code></td>
<td style="text-align:left">271</td>
<td style="text-align:left">int</td>
<td style="text-align:left">Total partition count.</td>
</tr>
<tr>
<td style="text-align:left"><code>hazelcast.logging.type</code></td>
<td style="text-align:left">jdk</td>
<td style="text-align:left">enum</td>
<td style="text-align:left">Name of <a href="#logging-configuration">logging</a> framework type to send logging events.</td>
</tr>
<tr>
<td style="text-align:left"><code>hazelcast.jmx</code></td>
<td style="text-align:left">false</td>
<td style="text-align:left">bool</td>
<td style="text-align:left">Enable <a href="#monitoring-with-jmx">JMX</a> agent.</td>
</tr>
<tr>
<td style="text-align:left"><code>hazelcast.jmx.detailed</code></td>
<td style="text-align:left">false</td>
<td style="text-align:left">bool</td>
<td style="text-align:left">Enable detailed views on <a href="#monitoring-with-jmx">JMX</a>.</td>
</tr>
<tr>
<td style="text-align:left"><code>hazelcast.mc.max.visible.instance.count</code></td>
<td style="text-align:left">100</td>
<td style="text-align:left">int</td>
<td style="text-align:left">Management Center maximum visible instance count.</td>
</tr>
<tr>
<td style="text-align:left"><code>hazelcast.mc.url.change.enabled</code></td>
<td style="text-align:left">true</td>
<td style="text-align:left">bool</td>
<td style="text-align:left">Management Center changing server url is enabled.</td>
</tr>
<tr>
<td style="text-align:left"><code>hazelcast.connection.monitor.interval</code></td>
<td style="text-align:left">100</td>
<td style="text-align:left">int</td>
<td style="text-align:left">Minimum interval to consider a connection error as critical in milliseconds.</td>
</tr>
<tr>
<td style="text-align:left"><code>hazelcast.connection.monitor.max.faults</code></td>
<td style="text-align:left">3</td>
<td style="text-align:left">int</td>
<td style="text-align:left">Maximum IO error count before disconnecting from a node.</td>
</tr>
<tr>
<td style="text-align:left"><code>hazelcast.partition.migration.interval</code></td>
<td style="text-align:left">0</td>
<td style="text-align:left">int</td>
<td style="text-align:left">Interval to run partition migration tasks in seconds.</td>
</tr>
<tr>
<td style="text-align:left"><code>hazelcast.partition.migration.timeout</code></td>
<td style="text-align:left">300</td>
<td style="text-align:left">int</td>
<td style="text-align:left">Timeout for partition migration tasks in seconds.</td>
</tr>
<tr>
<td style="text-align:left"><code>hazelcast.partition.migration.zip.enabled</code></td>
<td style="text-align:left">true</td>
<td style="text-align:left">bool</td>
<td style="text-align:left">Enable compression during partition migration.</td>
</tr>
<tr>
<td style="text-align:left"><code>hazelcast.partition.table.send.interval</code></td>
<td style="text-align:left">15</td>
<td style="text-align:left">int</td>
<td style="text-align:left">Interval for publishing partition table periodically to all cluster members.</td>
</tr>
<tr>
<td style="text-align:left"><code>hazelcast.partition.backup.sync.interval</code></td>
<td style="text-align:left">30</td>
<td style="text-align:left">int</td>
<td style="text-align:left">Interval for syncing backup replicas.</td>
</tr>
<tr>
<td style="text-align:left"><code>hazelcast.partitioning.strategy.class</code></td>
<td style="text-align:left">null</td>
<td style="text-align:left">string</td>
<td style="text-align:left">Class name implementing <code>com.hazelcast.core.PartitioningStrategy</code>, which defines key to partition mapping.</td>
</tr>
<tr>
<td style="text-align:left"><code>hazelcast.migration.min.delay.on.member.removed.seconds</code></td>
<td style="text-align:left">5</td>
<td style="text-align:left">int</td>
<td style="text-align:left">Minimum delay (in seconds) between detection of a member that has left and start of the rebalancing process.</td>
</tr>
<tr>
<td style="text-align:left"><code>hazelcast.graceful.shutdown.max.wait</code></td>
<td style="text-align:left">600</td>
<td style="text-align:left">int</td>
<td style="text-align:left">Maximum wait seconds during graceful shutdown.</td>
</tr>
<tr>
<td style="text-align:left"><code>hazelcast.system.log.enabled</code></td>
<td style="text-align:left">true</td>
<td style="text-align:left">bool</td>
<td style="text-align:left">Enable system logs.</td>
</tr>
<tr>
<td style="text-align:left"><code>hazelcast.elastic.memory.enabled</code></td>
<td style="text-align:left">false</td>
<td style="text-align:left">bool</td>
<td style="text-align:left">Enable <a href="#elastic-memory-enterprise-only">Hazelcast Elastic Memory</a> off-heap storage.</td>
</tr>
<tr>
<td style="text-align:left"><code>hazelcast.elastic.memory.total.size</code></td>
<td style="text-align:left">128</td>
<td style="text-align:left">int</td>
<td style="text-align:left"><a href="#elastic-memory-enterprise-only">Hazelcast Elastic Memory</a> storage total size in MB.</td>
</tr>
<tr>
<td style="text-align:left"><code>hazelcast.elastic.memory.chunk.size</code></td>
<td style="text-align:left">1</td>
<td style="text-align:left">int</td>
<td style="text-align:left"><a href="#elastic-memory-enterprise-only">Hazelcast Elastic Memory</a> storage chunk size in KB.</td>
</tr>
<tr>
<td style="text-align:left"><code>hazelcast.elastic.memory.shared.storage</code></td>
<td style="text-align:left">false</td>
<td style="text-align:left">bool</td>
<td style="text-align:left">Enable <a href="#elastic-memory-enterprise-only">Hazelcast Elastic Memory</a> shared storage.</td>
</tr>
<tr>
<td style="text-align:left"><code>hazelcast.elastic.memory.unsafe.enabled</code></td>
<td style="text-align:left">false</td>
<td style="text-align:left">bool</td>
<td style="text-align:left">Enable usage of <code>sun.misc.Unsafe</code> when allocating, reading and modifying off-heap storage.</td>
</tr>
<tr>
<td style="text-align:left"><code>hazelcast.enterprise.license.key</code></td>
<td style="text-align:left">null</td>
<td style="text-align:left">string</td>
<td style="text-align:left"><a href="http://www.hazelcast.com/products.jsp">Hazelcast Enterprise</a> license key.</td>
</tr>
<tr>
<td style="text-align:left"><code>hazelcast.client.heartbeat.timeout</code></td>
<td style="text-align:left">300000</td>
<td style="text-align:left">string</td>
<td style="text-align:left">Timeout for the heartbeat messages sent by the client to members. If there is no any message passing between client and member within the given time via this property in milliseconds the connection will be closed.</td>
</tr>
<tr>
<td style="text-align:left"><code>hazelcast.client.heartbeat.interval</code></td>
<td style="text-align:left">10000</td>
<td style="text-align:left">string</td>
<td style="text-align:left">The frequency of heartbeat messages sent by the clients to members.</td>
</tr>
<tr>
<td style="text-align:left"><code>hazelcast.client.max.failed.heartbeat.count</code></td>
<td style="text-align:left">3</td>
<td style="text-align:left">string</td>
<td style="text-align:left">When the count of failed heartbeats sent to members reaches this value, the cluster is deemed as dead by the client.</td>
</tr>
<tr>
<td style="text-align:left"><code>hazelcast.client.request.retry.count</code></td>
<td style="text-align:left">20</td>
<td style="text-align:left">string</td>
<td style="text-align:left">The retry count of the connection requests by the client to the members.</td>
</tr>
<tr>
<td style="text-align:left"><code>hazelcast.client.request.retry.wait.time</code></td>
<td style="text-align:left">250</td>
<td style="text-align:left">string</td>
<td style="text-align:left">The frequency of the connection retries.</td>
</tr>
<tr>
<td style="text-align:left"><code>hazelcast.client.event.thread.count</code></td>
<td style="text-align:left">5</td>
<td style="text-align:left">string</td>
<td style="text-align:left">Thread count for handling incoming event packets.</td>
</tr>
<tr>
<td style="text-align:left"><code>hazelcast.client.event.queue.capacity</code></td>
<td style="text-align:left">1000000</td>
<td style="text-align:left">string</td>
<td style="text-align:left">Default value of the capacity of executor that handles incoming event packets.</td>
</tr>
</tbody>
</table>
<h1 id="network-partitioning-split-brain-syndrome">Network Partitioning - Split Brain Syndrome</h1>
<p>Imagine that you have 10-node cluster and for some reason the network is divided into two in a way that 4 servers cannot see the other 6. As a result, you ended up having two separate clusters; 4-node cluster and 6-node cluster. Members in each sub-cluster are thinking that the other nodes are dead even though they are not. This situation is called Network Partitioning (a.k.a. <em>Split-Brain Syndrome</em>).</p>
<p>However, these two clusters have a combination of the 271 (using default) primary and backup partitions. It’s very likely that not all of the 271 partitions, including both primaries and backups, exist in both mini-clusters.
Therefore, from each mini-cluster’s perspective, data has been lost as some partitions no longer exist (they exist on the other segment).</p>
<p>If a MapStore was in use, those lost partitions would be reloaded from some database, making each mini-cluster complete.
Each mini-cluster will then recreate the missing primary partitions and continue to store data in them, including backups on the other nodes.</p>
<p>When primary partitions exist without a backup, a backup version problem will be detected and a backup partition will be created.
When backups exist without a primary, the backups will be promoted to primary partitions and new backups will be created with proper versioning.
At this time, both mini-clusters have repaired themselves with all 271 partitions with backups, and continue to handle traffic without any knowledge of each other.
Given that they have enough remaining memory (assumption), they are just smaller and can handle less throughput.</p>
<p>If a MapStore is in use and the network to the database is available, one or both of the mini-clusters are now writing updates to the same database.
There is a potential for them to overwrite the same cache entry records if modified in both mini-clusters.
This overwrite scenario represents a potential data loss, and thus the database design should consider an insert and aggregate on read or version strategy rather than update records in place.</p>
<p>If the network to the database is not available, then based on the configured or coded consistency level or transaction, entry updates are just held in cache or updates are rejected (fully synchronous and consistent).
When held in cache, the updates will be considered dirty and will be written to the database when it becomes available. Dirty entry counts per cluster member can be viewed in the Management Center web console (please see <a href="#map-monitoring">Map Monitoring</a>).</p>
<p>Since it is a network failure, there is no way to avoid it programmatically and your application will run as two separate independent clusters.
But we should be able to answer the following questions: &quot;What will happen after the network failure is fixed and connectivity is restored between these two clusters?
Will these two clusters merge into one again? If they do, how are the data conflicts resolved, because you might end up having two different values for the same key in the same map?&quot;</p>
<p>When the network is restored, you should expect all 271 partitions to exist in both mini-clusters and for them all to undergo the merge. Once all primaries are merged,
all backups will be rewritten so their versions are correct. You may want to write a merge policy using the <code>MapMergePolicy</code> interface that rebuilds the entry from the database rather than from memory.</p>
<p>The only meta data available for merge decisions are from the <code>EntryView</code> interface that includes object size (cost), hits count, last updated/stored dates, and a version number that starts at zero and is incremented for each entry update.
You could also create your own versioning scheme or capture a time series of deltas to reconstruct an entry.</p>
<p>Here is, step by step, how Hazelcast split brain merge happens:</p>
<ol>
<li><p>The oldest member of the cluster checks if there is another cluster with the same <em>group-name</em> and <em>group-password</em> in the network.</p>
</li>
<li><p>If the oldest member finds such cluster, then it figures out which cluster should merge to the other.</p>
</li>
<li><p>Each member of the merging cluster will do the following:</p>
<ul>
<li><p>pause</p>
</li>
<li><p>take locally owned map entries</p>
</li>
<li><p>close all of its network connections (detach from its cluster)</p>
</li>
<li><p>join to the new cluster</p>
</li>
<li><p>send merge request for each of its locally owned map entry</p>
</li>
<li><p>resume</p>
</li>
</ul>
</li>
</ol>
<p>So each member of the merging cluster is actually rejoining to the new cluster and sending merge request for each of its locally owned map entry. Two important points:</p>
<ul>
<li>Smaller cluster will merge into the bigger one. If they have equal number of members then a hashing algorithm determines the merging cluster.</li>
<li>Each cluster may have different versions of the same key in the same map. Destination cluster will decide how to handle merging entry based on the <code>MergePolicy</code> set for that map. There are built-in merge policies such as <code>PassThroughMergePolicy</code>, <code>PutIfAbsentMapMergePolicy</code>, <code>HigherHitsMapMergePolicy</code> and <code>LatestUpdateMapMergePolicy</code>. But you can develop your own merge policy by implementing <code>com.hazelcast.map.merge.MapMergePolicy</code>. You should set the full class name of your implementation to the <code>merge-policy</code> configuration.</li>
</ul>
<pre><code class="lang-java">public interface MergePolicy {
  /**
  * Returns the value of the entry after the merge
  * of entries with the same key. Returning value can be
  * You should consider the case where existingEntry is null.
  *
  * @param mapName       name of the map
  * @param mergingEntry  entry merging into the destination cluster
  * @param existingEntry existing entry in the destination cluster
  * @return final value of the entry. If returns null then entry will be removed.
  */
  Object merge( String mapName, EntryView mergingEntry, EntryView existingEntry );
}
</code></pre>
<p>Here is how merge policies are specified per map:</p>
<pre><code class="lang-xml">&lt;hazelcast&gt;
  ...
  &lt;map name=&quot;default&quot;&gt;
    &lt;backup-count&gt;1&lt;/backup-count&gt;
    &lt;eviction-policy&gt;NONE&lt;/eviction-policy&gt;
    &lt;max-size&gt;0&lt;/max-size&gt;
    &lt;eviction-percentage&gt;25&lt;/eviction-percentage&gt;
    &lt;!--
      While recovering from split-brain (network partitioning),
      map entries in the small cluster will merge into the bigger cluster
      based on the policy set here. When an entry merge into the
      cluster, there might an existing entry with the same key already.
      Values of these entries might be different for that same key.
      Which value should be set for the key? Conflict is resolved by
      the policy set here. Default policy is hz.ADD_NEW_ENTRY

      There are built-in merge policies such as
      There are built-in merge policies such as
      com.hazelcast.map.merge.PassThroughMergePolicy; entry will be added if
          there is no existing entry for the key.
      com.hazelcast.map.merge.PutIfAbsentMapMergePolicy ; entry will be
          added if the merging entry doesn&#39;t exist in the cluster.
      com.hazelcast.map.merge.HigherHitsMapMergePolicy ; entry with the
          higher hits wins.
      com.hazelcast.map.merge.LatestUpdateMapMergePolicy ; entry with the
          latest update wins.
    --&gt;
    &lt;merge-policy&gt;MY_MERGE_POLICY_CLASS&lt;/merge-policy&gt;
  &lt;/map&gt;

  ...
&lt;/hazelcast&gt;
</code></pre>
<h1 id="frequently-asked-questions">Frequently Asked Questions</h1>
<h2 id="why-271-as-the-default-partition-count">Why 271 as the default partition count</h2>
<p>The partition count 271, being a prime number, is a good choice since it will be distributed to the nodes almost evenly. For a small to medium sized cluster, the count 271 gives almost even partition distribution and optimal sized partitions.  As your cluster becomes bigger, this count should be made bigger to have evenly distributed partitions.</p>
<h2 id="is-hazelcast-thread-safe">Is Hazelcast thread safe</h2>
<p>Yes. All Hazelcast data structures are thread safe.</p>
<h2 id="how-do-nodes-discover-each-other">How do nodes discover each other</h2>
<p>When a node is started in a cluster, it will dynamically and automatically be discovered. There are three types of discovery.</p>
<ul>
<li>One is the multicast. Nodes in a cluster discover each other by multicast, by default. </li>
<li>Second is discovery by TCP/IP. The first node created in the cluster (leader) will form a list of IP addresses of other joining nodes and send this list to these nodes. So, nodes will know each other.</li>
<li>And, if your application is placed on Amazon EC2, Hazelcast has an automatic discovery mechanism, as the third discovery type. You will just give your Amazon credentials and the joining node will be discovered automatically.</li>
</ul>
<p>Once nodes are discovered, all the communication between them will be via TCP/IP.</p>
<h2 id="what-happens-when-a-node-goes-down">What happens when a node goes down</h2>
<p>Once a node is gone (e.g.crashes) and since data in each node has a backup in other nodes:</p>
<ul>
<li>First, the backups in other nodes are restored</li>
<li>Then, data from these restored backups are recovered</li>
<li>And finally, backups for these recovered data are formed</li>
</ul>
<p>So, eventually, no data is lost.</p>
<h2 id="how-do-i-test-the-connectivity">How do I test the connectivity</h2>
<p>If you notice that there is a problem about a node in joining to a cluster, you may want to perform a connectivity test between the node to be joined and a node from the cluster. The <code>iperf</code> tool can be used for this purpose. For example, you can execute the below command on one node (i.e. listening on port 5701):</p>
<p><code>iperf -s -p 5701</code></p>
<p>And you can execute the below command on the other node:</p>
<p><code>iperf -c</code> <em><code>&lt;IP address&gt;</code></em> <code>-d -p 5701</code></p>
<p>You should see the output which includes connection information such as the IP addresses, transfer speed and bandwidth. Otherwise, if the output says <code>No route to host</code>, it means a network connection problem exists.</p>
<h2 id="how-do-i-choose-keys-properly">How do I choose keys properly</h2>
<p>When you store a key &amp; value in a distributed Map, Hazelcast serializes the key and value, and stores the byte array version of them in local ConcurrentHashMaps. These ConcurrentHashMaps use <code>equals</code> and <code>hashCode</code> methods of byte array version of your key. It does not take into account the actual <code>equals</code> and <code>hashCode</code> implementations of your objects. So it is important that you choose your keys in a proper way. </p>
<p>Implementing <code>equals</code> and <code>hashCode</code> is not enough, it is also important that the object is always serialized into the same byte array. All primitive types like String, Long, Integer, etc. are good candidates for keys to be used in Hazelcast. An unsorted Set is an example of a very bad candidate because Java Serialization may serialize the same unsorted set in two different byte arrays.</p>
<h2 id="how-do-i-reflect-value-modifications">How do I reflect value modifications</h2>
<p>Hazelcast always return a clone copy of a value. Modifying the returned value does not change the actual value in the map (or multimap, list, set). You should put the modified value back to make changes visible to all nodes.</p>
<pre><code class="lang-java">V value = map.get( key );
value.updateSomeProperty();
map.put( key, value );
</code></pre>
<p>Collections which return values of methods such as <code>IMap.keySet</code>, <code>IMap.values</code>, <code>IMap.entrySet</code>, <code>MultiMap.get</code>, <code>MultiMap.remove</code>, <code>IMap.keySet</code>, <code>IMap.values</code>, contain cloned values. These collections are NOT backup by related Hazelcast objects. So changes to the these are <strong>NOT</strong> reflected in the originals, and vice-versa.</p>
<h2 id="how-do-i-test-my-hazelcast-cluster">How do I test my Hazelcast cluster</h2>
<p>Hazelcast allows you to create more than one instance on the same JVM. Each member is called <code>HazelcastInstance</code> and each will have its own configuration, socket and threads, i.e. you can treat them as totally separate instances. </p>
<p>This enables us to write and run cluster unit tests on a single JVM. As you can use this feature for creating separate members different applications running on the same JVM (imagine running multiple web applications on the same JVM), you can also use this feature for testing Hazelcast cluster.</p>
<p>Let&#39;s say you want to test if two members have the same size of a map.</p>
<pre><code class="lang-java">@Test
public void testTwoMemberMapSizes() {
  // start the first member
  HazelcastInstance h1 = Hazelcast.newHazelcastInstance();
  // get the map and put 1000 entries
  Map map1 = h1.getMap( &quot;testmap&quot; );
  for ( int i = 0; i &lt; 1000; i++ ) {
    map1.put( i, &quot;value&quot; + i );
  }
  // check the map size
  assertEquals( 1000, map1.size() );
  // start the second member
  HazelcastInstance h2 = Hazelcast.newHazelcastInstance();
  // get the same map from the second member
  Map map2 = h2.getMap( &quot;testmap&quot; );
  // check the size of map2
  assertEquals( 1000, map2.size() );
  // check the size of map1 again
  assertEquals( 1000, map1.size() );
}
</code></pre>
<p>In the test above, everything happens in the same thread. When developing multi-threaded test, coordination of the thread executions has to be carefully handled. Usage of <code>CountDownLatch</code> for thread coordination is highly recommended. You can certainly use other things. Here is an example where we need to listen for messages and make sure that we got these messages:</p>
<pre><code class="lang-java">@Test
public void testTopic() {
  // start two member cluster
  HazelcastInstance h1 = Hazelcast.newHazelcastInstance();
  HazelcastInstance h2 = Hazelcast.newHazelcastInstance();
  String topicName = &quot;TestMessages&quot;;
  // get a topic from the first member and add a messageListener
  ITopic&lt;String&gt; topic1 = h1.getTopic( topicName );
  final CountDownLatch latch1 = new CountDownLatch( 1 );
  topic1.addMessageListener( new MessageListener() {
    public void onMessage( Object msg ) {
      assertEquals( &quot;Test1&quot;, msg );
      latch1.countDown();
    }
  });
  // get a topic from the second member and add a messageListener
  ITopic&lt;String&gt; topic2 = h2.getTopic(topicName);
  final CountDownLatch latch2 = new CountDownLatch( 2 );
  topic2.addMessageListener( new MessageListener() {
    public void onMessage( Object msg ) {
      assertEquals( &quot;Test1&quot;, msg );
      latch2.countDown();
    }
  } );
  // publish the first message, both should receive this
  topic1.publish( &quot;Test1&quot; );
  // shutdown the first member
  h1.shutdown();
  // publish the second message, second member&#39;s topic should receive this
  topic2.publish( &quot;Test1&quot; );
  try {
    // assert that the first member&#39;s topic got the message
    assertTrue( latch1.await( 5, TimeUnit.SECONDS ) );
    // assert that the second members&#39; topic got two messages
    assertTrue( latch2.await( 5, TimeUnit.SECONDS ) );
  } catch ( InterruptedException ignored ) {
  }
}
</code></pre>
<p>You can surely start Hazelcast members with different configurations. Remember to call <code>Hazelcast.shutdownAll()</code> after each test case to make sure that there is no other running member left from the previous tests.</p>
<pre><code class="lang-java">@After
public void cleanup() throws Exception {
  Hazelcast.shutdownAll();
}
</code></pre>
<p>For more information please <a href="https://github.com/hazelcast/hazelcast/tree/master/hazelcast/src/test/java/com/hazelcast/cluster">check our existing tests.</a></p>
<h2 id="how-do-i-create-separate-clusters">How do I create separate clusters</h2>
<p>By specifying group name and group password, you can separate your clusters in a simple way. Groupings can be by <em>dev</em>, <em>production</em>, <em>test</em>, <em>app</em>, etc.</p>
<pre><code class="lang-xml">&lt;hazelcast&gt;
  &lt;group&gt;
    &lt;name&gt;dev&lt;/name&gt;
    &lt;password&gt;dev-pass&lt;/password&gt;
  &lt;/group&gt;
  ...
&lt;/hazelcast&gt;
</code></pre>
<p>You can also set the <code>groupName</code> with programmatic configuration. JVM can host multiple Hazelcast instances. Each node can only participate in one group and it only joins to its own group, does not mess with others. Following code creates 3 separate Hazelcast nodes, <code>h1</code> belongs to <code>app1</code> cluster, while <code>h2</code> and <code>h3</code> belong to <code>app2</code> cluster.</p>
<pre><code class="lang-java">Config configApp1 = new Config();
configApp1.getGroupConfig().setName( &quot;app1&quot; );

Config configApp2 = new Config();
configApp2.getGroupConfig().setName( &quot;app2&quot; );

HazelcastInstance h1 = Hazelcast.newHazelcastInstance( configApp1 );
HazelcastInstance h2 = Hazelcast.newHazelcastInstance( configApp2 );
HazelcastInstance h3 = Hazelcast.newHazelcastInstance( configApp2 );
</code></pre>
<h2 id="does-hazelcast-support-hundreds-of-nodes">Does Hazelcast support hundreds of nodes</h2>
<p>Yes. Hazelcast performed a successful test on Amazon EC2 with 200 nodes.</p>
<h2 id="does-hazelcast-support-thousands-of-clients">Does Hazelcast support thousands of clients</h2>
<p>Yes. However, there are some points to be considered. First of all, the environment should be LAN with a high stability and the network speed should be 10 Gbps or higher. If number of nodes are high, client type should be selected as Dummy (not Smart Client). In the case of Smart Clients, since each client will open a connection to the nodes, these nodes should be powerful enough (e.g. more cores) to handle hundreds or thousands of connections and client requests. Also, using near caches in clients should be considered to lower the network traffic. And finally, the Hazelcast releases with the NIO implementation should be used (which starts with 3.2).</p>
<p>Also, the clients should be configured attentively. Please refer to <a href="#java-client">Java Clients</a> section for configuration notes.</p>
<h2 id="what-is-the-difference-between-old-litemember-and-new-smart-client">What is the difference between old LiteMember and new Smart Client</h2>
<p>LiteMember supports task execution (distributed executor service), smart client does not. Also LiteMember is highly coupled with cluster, smart client is not.</p>
<h2 id="how-do-you-give-support">How do you give support</h2>
<p>Support services are divided into two: community and commercial support. Community support is provided through our <a href="https://groups.google.com/forum/#!forum/hazelcast">Mail Group</a> and StackOverflow web site. For information on support subscriptions, please see <a href="http://hazelcast.com/support/commercial/">Hazelcast.com</a>.</p>
<h2 id="does-hazelcast-persist">Does Hazelcast persist</h2>
<p>No. But, Hazelcast provides <code>MapStore</code> and <code>MapLoader</code> interfaces. When you implement, for example, <code>MapStore</code> interface, Hazelcast calls your store and load methods whenever needed.</p>
<h2 id="can-i-use-hazelcast-in-a-single-server">Can I use Hazelcast in a single server</h2>
<p>Yes. But, please note that, Hazelcast&#39;s main design focus is multi-node clusters to be used as a distribution platform. </p>
<h2 id="how-can-i-monitor-hazelcast">How can I monitor Hazelcast</h2>
<p><a href="#management-center">Hazelcast Management Center</a> is used to monitor and manage the nodes running Hazelcast. In addition to monitoring overall state of a cluster, data structures can be analyzed and browsed in detail, map configurations can be updated and thread dump from nodes can be taken. </p>
<p>Moreover, JMX monitoring is also provided. Please see <a href="#monitoring-with-jmx">Monitoring with JMX</a> section for details.</p>
<h2 id="how-can-i-see-debug-level-logs">How can I see debug level logs</h2>
<p>By changing the log level to &quot;Debug&quot;. Below sample lines are for <strong>log4j</strong> logging framework. Please see <a href="#logging-configuration">Logging Configuration</a> to learn how to set logging types.</p>
<p>First, set the logging type as follows.</p>
<pre><code class="lang-java">String location = &quot;log4j.configuration&quot;;
String logging = &quot;hazelcast.logging.type&quot;;
System.setProperty( logging, &quot;log4j&quot; );
/**if you want to give a new location. **/
System.setProperty( location, &quot;file:/path/mylog4j.properties&quot; );
</code></pre>
<p>Then set the log level to &quot;Debug&quot; in properties file. Below is a sample content.</p>
<p><code># direct log messages to stdout #</code></p>
<p><code>log4j.appender.stdout=org.apache.log4j.ConsoleAppender</code></p>
<p><code>log4j.appender.stdout.Target=System.out</code></p>
<p><code>log4j.appender.stdout.layout=org.apache.log4j.PatternLayout</code></p>
<p><code>log4j.appender.stdout.layout.ConversionPattern=%d{ABSOLUTE} %5p [%c{1}] - %m%n</code></p>
<p><br> </br></p>
<p><code>log4j.logger.com.hazelcast=debug</code></p>
<p><code>#log4j.logger.com.hazelcast.cluster=debug</code></p>
<p><code>#log4j.logger.com.hazelcast.partition=debug</code></p>
<p><code>#log4j.logger.com.hazelcast.partition.InternalPartitionService=debug</code></p>
<p><code>#log4j.logger.com.hazelcast.nio=debug</code></p>
<p><code>#log4j.logger.com.hazelcast.hibernate=debug</code></p>
<p>The line <code>log4j.logger.com.hazelcast=debug</code> is used to see debug logs for all Hazelcast operations. Below this line, you can select to see specific logs (cluster, partition, hibernate, etc.).</p>
<h2 id="what-is-the-difference-between-client-server-and-embedded-topologies">What is the difference between client-server and embedded topologies</h2>
<p>In the embedded topology, nodes include both the data and application. This type of topology is the most useful if your application focuses on high performance computing and many task executions. Since application is close to data, this topology supports data locality. </p>
<p>In the client-server topology, you create a cluster of nodes and scale the cluster independently. And your applications are hosted on the clients, that communicate with the nodes in the cluster to reach data. </p>
<p>Client-server topology fits better, if there are multiple applications sharing the same data or if application deployment is significantly greater than the cluster size (e.g. 500 application servers vs. 10 node cluster).</p>
<h2 id="how-do-i-know-it-is-safe-to-kill-the-second-node">How do I know it is safe to kill the second node</h2>
<p>Programmatically:</p>
<pre><code class="lang-java">PartitionService partitionService = hazelcastInstance.getPartitionService().isClusterSafe()
if (partitionService().isClusterSafe()) {
  hazelcastInstance.shutdown(); // or terminate
}
</code></pre>
<p>OR </p>
<pre><code class="lang-java">PartitionService partitionService = hazelcastInstance.getPartitionService().isClusterSafe()
if (partitionService().isLocalMemberSafe()) {
  hazelcastInstance.shutdown(); // or terminate
}
</code></pre>
<h2 id="when-do-i-need-off-heap-solutions">When do I need Off-heap solutions</h2>
<p>Off-heap solutions can be preferred;</p>
<ul>
<li>When the amount of data per node is large enough to create significant garbage collection pauses,</li>
<li>When your application requires predictable latency.</li>
</ul>
<h2 id="is-there-any-disadvantage-of-using-near-cache">Is there any disadvantage of using near-cache</h2>
<p>The only disadvantage when using near-cache is that it may cause stale reads.</p>
<h2 id="is-hazelcast-secure">Is Hazelcast secure</h2>
<p>Hazelcast supports symmetric encryption, secure sockets layer (SSL) and Java Authentication and Authorization Service (JAAS). Please see <a href="#security">Security</a> chapter for more information.</p>
<h1 id="glossary">Glossary</h1>
<table>
<thead>
<tr>
<th style="text-align:left">Term</th>
<th style="text-align:left">Definition</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>2-phase Commit</strong></td>
<td style="text-align:left">2-phase commit protocol is an atomic commitment protocol for distributed systems. It consists of two phases: commit-request and commit. In commit-request phase, transaction manager coordinates all of the transaction resources to commit or abort. In commit-phase, transaction manager decides to finalize operation by committing or aborting according to the votes of the each transaction resource.</td>
</tr>
<tr>
<td style="text-align:left"><strong>ACID</strong></td>
<td style="text-align:left">A set of properties (Atomicity, Consistency, Isolation, Durability) guaranteeing that transactions are processed reliably. Atomicity requires that each transaction be all or nothing (i.e. if one part of the transaction fails, the entire transaction will fail). Consistency ensures that only valid data following all rules and constraints is written. Isolation ensures that transactions are securely and independently processed at the same time without interference (and without transaction ordering). Durability means that once a transaction has been committed, it will remain so, no matter if there is a power loss, crash, or error.</td>
</tr>
<tr>
<td style="text-align:left"><strong>Cache</strong></td>
<td style="text-align:left">A high-speed access area that can be either a reserved section of main memory or storage device. </td>
</tr>
<tr>
<td style="text-align:left"><strong>Garbage Collection</strong></td>
<td style="text-align:left">Garbage collection is the recovery of storage that is being used by an application when that application no longer needs the storage. This frees the storage for use by other applications (or processes within an application). It also ensures that an application using increasing amounts of storage does not reach its quota. Programming languages that use garbage collection are often interpreted within virtual machines like the JVM. The environment that runs the code is also responsible for garbage collection.</td>
</tr>
<tr>
<td style="text-align:left"><strong>Hazelcast Cluster</strong></td>
<td style="text-align:left">It is a virtual environment formed by Hazelcast nodes communicating with each other.</td>
</tr>
<tr>
<td style="text-align:left"><strong>Hazelcast Node</strong></td>
<td style="text-align:left">A node in Hazelcast terms, is a Hazelcast instance. Depending on your Hazelcast usage, it can refer to a server or a Java virtual machine (JVM). For example, if there is only one Hazelcast instance in a JVM, that JVM can be called as a node. Nodes are also referred as <code>cluster members</code> that form a cluster. </td>
</tr>
<tr>
<td style="text-align:left"><strong>Hazelcast Partitions</strong></td>
<td style="text-align:left">Memory segments containing the data. Hazelcast is built-on the partition concept, it uses partitions to store and process data. Each partition can have hundreds or thousands of data entries depending on your memory capacity. You can think of a partition as a block of data. In general and optimally, a partition should have a maximum size of 50-100 Megabytes.</td>
</tr>
<tr>
<td style="text-align:left"><strong>IMDG</strong></td>
<td style="text-align:left">An in-memory data grid (IMDG) is a data structure that resides entirely in memory, and is distributed among many nodes in a single location or across multiple locations. IMDGs can support thousands of in-memory data updates per second, and they can be clustered and scaled in ways that support large quantities of data.</td>
</tr>
<tr>
<td style="text-align:left"><strong>Invalidation</strong></td>
<td style="text-align:left">The process of marking an object as being invalid across the distributed cache.</td>
</tr>
<tr>
<td style="text-align:left"><strong>Java heap</strong></td>
<td style="text-align:left">Java heap is the space that Java can reserve and use in memory for dynamic memory allocation. All runtime objects created by a Java application are stored in heap. By default, the heap size is 128 MB, but this limit is reached easily for business applications. Once the heap is full, new objects cannot be created and the Java application shows errors.</td>
</tr>
<tr>
<td style="text-align:left"><strong>LRU, LFU</strong></td>
<td style="text-align:left">LRU and LFU are two of eviction algorithms. LRU is the abbreviation for Least Recently Used. It refers to entries eligible for eviction due to lack of interest by applications. LFU is the abbreviation for Least Frequently Used. It refers to the entries eligible for eviction due to having the lowest usage frequency.</td>
</tr>
<tr>
<td style="text-align:left"><strong>Multicast</strong></td>
<td style="text-align:left">It is a type of communication where data is addressed to a group of destination nodes simultaneously.</td>
</tr>
<tr>
<td style="text-align:left"><strong>Near Cache</strong></td>
<td style="text-align:left">It is a caching model. When it is enabled, an object retrieved from a remote node is put into the local cache and the future requests made to this object will be handled by this local node. For example, if you have a map with data that is mostly read, then using near cache is a good idea.</td>
</tr>
<tr>
<td style="text-align:left"><strong>NoSQL</strong></td>
<td style="text-align:left">&quot;Not Only SQL&quot;. It is a database model that provides a mechanism for storage and retrieval of data that is tailored in means other than the tabular relations used in relational databases. It is a type of database which does not adhering to the traditional relational database management system (RDMS) structure. It is not built on tables and does not employ SQL to manipulate data. It also may not provide full ACID guarantees, but still has a distributed and fault tolerant architecture.</td>
</tr>
<tr>
<td style="text-align:left"><strong>Off-heap</strong></td>
<td style="text-align:left">For very large amounts of data, storing the data in heap is simply not possible (there will be performance penalties of Java&#39;s memory management capabilities). When we try to store the big data in heap, garbage collection pause times will be essentially long. To overcome this, off-heap memory is used. This is the direct buffer. Data is not stored in Java heap but directly in the available internal memory. In this case, Java`s garbage collector will not perform its job and hence there are no performance penalties.</td>
</tr>
<tr>
<td style="text-align:left"><strong>Race Condition</strong></td>
<td style="text-align:left">This condition occurs when two or more threads can access shared data and they try to change it at the same time.</td>
</tr>
<tr>
<td style="text-align:left"><strong>Serialization</strong></td>
<td style="text-align:left">Process of converting an object into a stream of bytes in order to store the object or transmit it to memory, a database, or a file. Its main purpose is to save the state of an object in order to be able to recreate it when needed. The reverse process is called deserialization.</td>
</tr>
<tr>
<td style="text-align:left"><strong>Split Brain</strong></td>
<td style="text-align:left">Split brain syndrome, in a clustering context, is a state in which a cluster of nodes gets divided (or partitioned) into smaller clusters of nodes, each of which believes it is the only active cluster.</td>
</tr>
<tr>
<td style="text-align:left"><strong>Transaction</strong></td>
<td style="text-align:left">Means a sequence of information exchange and related work (such as data store updating) that is treated as a unit for the purposes of satisfying a request and for ensuring data store integrity.</td>
</tr>
</tbody>
</table>




	        </div>	
	        </div>		
    </div>
</body>
</html>
